import 'package:cedar/ast.dart';
import 'package:cedar/cedar.dart';
import 'package:celest_ast/celest_ast.dart';
import 'package:celest_cloud_auth/src/authorization/authorizer.dart';
import 'package:celest_cloud_auth/src/database/auth_database.dart';
import 'package:celest_cloud_auth/src/users/users_repository.dart';
import 'package:logging/logging.dart';
import 'package:pub_semver/pub_semver.dart';
import 'package:test/test.dart';

import '../tester.dart';

// Roles
const roleAdmin = EntityUid.of('Celest::Role', 'admin');
const roleAuthenticated = EntityUid.of('Celest::Role', 'authenticated');
const roleAnonymous = EntityUid.of('Celest::Role', 'anonymous');
const roleEditor = EntityUid.of('Celest::Role', 'editor');
const roleViewer = EntityUid.of('Celest::Role', 'viewer');

// Users
const userAlice = EntityUid.of('Celest::User', 'alice');
const userBob = EntityUid.of('Celest::User', 'bob');
const userCharlie = EntityUid.of('Celest::User', 'charlie');
const userDiana = EntityUid.of('Celest::User', 'diana');

// Actions
const actionCreate = EntityUid.of('Celest::Action', 'create');
const actionGet = EntityUid.of('Celest::Action', 'get');
const actionUpdate = EntityUid.of('Celest::Action', 'update');
const actionDelete = EntityUid.of('Celest::Action', 'delete');
const actionList = EntityUid.of('Celest::Action', 'list');
const actionInvoke = EntityUid.of('Celest::Action', 'invoke');

typedef TestCase =
    ({String description, AuthorizationRequest request, Decision expected});

/// Mirrors the policy generated by the API to ensure that metadata at the
/// function level never overrides the API level.
Policy forbidUnless(
  EntityUid resource, {
  required String id,
  required EntityUid unlessRole,
}) => Policy(
  effect: Effect.forbid,
  principal: const PrincipalAll(),
  action: const ActionEquals(actionInvoke),
  resource: ResourceIn(resource),
  annotations: Annotations({'id': id}),
  conditions: [
    Condition(
      kind: ConditionKind.unless,
      body: Expr.in_(
        left: const Expr.variable(CedarVariable.principal),
        right: Expr.value(Value.entity(uid: unlessRole)),
      ),
    ),
  ],
);

void main() {
  Logger.root.level = Level.WARNING;
  Logger.root.onRecord.listen((record) {
    print('${record.level.name}: ${record.message}');
  });

  group('Authorizer', () {
    late CloudAuthDatabase db;
    late Authorizer authorizer;

    group('core roles', () {
      late CloudAuthDatabase roleDb;
      late UsersRepository users;

      setUp(() async {
        roleDb = CloudAuthDatabase.memory(project: defaultProject);
        await roleDb.ping();
        users = UsersRepository(db: roleDb);
      });

      tearDown(() async {
        await roleDb.close();
      });

      test('viewer and editor roles are assignable', () async {
        final anonymous = await users.createAnonymousUser();

        await roleDb.cloudAuth.setUserRoles(
          userId: anonymous.userId,
          roles: const [roleViewer],
        );
        var updated = await roleDb.cloudAuth.getUser(userId: anonymous.userId);
        expect(updated!.roles, contains(roleViewer));

        await roleDb.cloudAuth.setUserRoles(
          userId: anonymous.userId,
          roles: const [roleEditor],
        );
        updated = await roleDb.cloudAuth.getUser(userId: anonymous.userId);
        expect(updated!.roles, contains(roleEditor));
      });
    });

    Future<void> createEntities(List<Entity> entities) async {
      for (final entity in entities) {
        await db.cloudAuth.createEntity(entity);
      }
    }

    void run(
      List<TestCase> testCases, {
      required List<Entity> entities,
      required ResolvedProject project,
    }) {
      setUpAll(() async {
        db = CloudAuthDatabase.memory(project: project);
        await db.ping();
        await createEntities(entities);
        addTearDown(db.close);

        authorizer = Authorizer(db: db);
      });

      for (final (:description, :request, :expected) in testCases) {
        test(description, () async {
          final response = await authorizer.authorize(
            principal: request.principal,
            action: request.action,
            context: request.context,
            resource: request.resource,
          );
          if (response.decision != expected) {
            fail(
              'Expected $expected but got ${response.decision}: \n'
              'Errors: ${response.errors}\n'
              'Reasons: ${response.reasons}',
            );
          }
        });
      }
    }

    group('function auth', () {
      const apiTest = EntityUid.of('Celest::Api', 'test');

      const functionAdmin = EntityUid.of('Celest::Function', 'test/admin');
      const functionAuthenticated = EntityUid.of(
        'Celest::Function',
        'test/authenticated',
      );
      const functionPublic = EntityUid.of('Celest::Function', 'test/public');

      const entities = <Entity>[
        Entity(uid: userAlice, parents: [roleAdmin]),
        Entity(uid: userBob, parents: [roleAuthenticated]),
        Entity(uid: userCharlie, parents: [roleAnonymous]),
        Entity(uid: userDiana, parents: [roleViewer]),
        Entity(uid: functionAuthenticated, parents: [apiTest]),
        Entity(uid: functionAdmin, parents: [apiTest]),
        Entity(uid: functionPublic, parents: [apiTest]),
      ];

      run(project: defaultProject, entities: entities, const [
        (
          description: 'unauthenticated user cannot invoke admin function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionAdmin,
          ),
          expected: Decision.deny,
        ),
        (
          description:
              'unauthenticated user cannot invoke authenticated function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionAuthenticated,
          ),
          expected: Decision.deny,
        ),
        (
          description: 'unauthenticated user can invoke public function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionPublic,
          ),
          expected: Decision.allow,
        ),
        (
          description: 'anonymous user cannot invoke admin function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionAdmin,
            principal: userCharlie,
          ),
          expected: Decision.deny,
        ),
        (
          description: 'anonymous user cannot invoke authenticated function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionAuthenticated,
            principal: userCharlie,
          ),
          expected: Decision.deny,
        ),
        (
          description: 'anonymous user can invoke public function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionPublic,
            principal: userCharlie,
          ),
          expected: Decision.allow,
        ),
        (
          description: 'authenticated user cannot invoke admin function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionAdmin,
            principal: userBob,
          ),
          expected: Decision.deny,
        ),
        (
          description: 'authenticated user can invoke authenticated function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionAuthenticated,
            principal: userBob,
          ),
          expected: Decision.allow,
        ),
        (
          description: 'authenticated user can invoke public function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionPublic,
            principal: userBob,
          ),
          expected: Decision.allow,
        ),
        (
          description: 'viewer can invoke admin function via viewer policy',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionAdmin,
            principal: userDiana,
          ),
          expected: Decision.allow,
        ),
        (
          description: 'viewer can invoke authenticated function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionAuthenticated,
            principal: userDiana,
          ),
          expected: Decision.allow,
        ),
        (
          description: 'viewer can invoke public function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionPublic,
            principal: userDiana,
          ),
          expected: Decision.allow,
        ),
        (
          description: 'admin user can invoke admin function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionAdmin,
            principal: userAlice,
          ),
          expected: Decision.allow,
        ),
        (
          description: 'admin user can invoke authenticated function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionAuthenticated,
            principal: userAlice,
          ),
          expected: Decision.allow,
        ),
        (
          description: 'admin user can invoke public function',
          request: AuthorizationRequest(
            action: actionInvoke,
            resource: functionPublic,
            principal: userAlice,
          ),
          expected: Decision.allow,
        ),
      ]);
    });

    group('api auth', () {
      const apiAdmin = EntityUid.of('Celest::Api', 'admin');
      const apiAuthenticated = EntityUid.of('Celest::Api', 'authenticated');
      const apiPublic = EntityUid.of('Celest::Api', 'public');

      const adminFunction = EntityUid.of('Celest::Function', 'admin/admin');
      const adminFunctionAdmin = EntityUid.of(
        'Celest::Function',
        'admin/adminAdmin',
      );
      const adminFunctionAuthenticated = EntityUid.of(
        'Celest::Function',
        'admin/adminAuthenticated',
      );
      const adminFunctionPublic = EntityUid.of(
        'Celest::Function',
        'admin/adminPublic',
      );

      const authenticatedFunction = EntityUid.of(
        'Celest::Function',
        'authenticated/authenticated',
      );
      const authenticatedFunctionAdmin = EntityUid.of(
        'Celest::Function',
        'authenticated/authenticatedAdmin',
      );
      const authenticatedFunctionAuthenticated = EntityUid.of(
        'Celest::Function',
        'authenticated/authenticatedAuthenticated',
      );
      const authenticatedFunctionPublic = EntityUid.of(
        'Celest::Function',
        'authenticated/authenticatedPublic',
      );

      const publicFunction = EntityUid.of('Celest::Function', 'public/public');
      const publicFunctionAdmin = EntityUid.of(
        'Celest::Function',
        'public/publicAdmin',
      );
      const publicFunctionAuthenticated = EntityUid.of(
        'Celest::Function',
        'public/publicAuthenticated',
      );
      const publicFunctionPublic = EntityUid.of(
        'Celest::Function',
        'public/publicPublic',
      );

      final project = ResolvedProject(
        projectId: 'test',
        environmentId: 'production',
        sdkConfig: SdkConfiguration(
          celest: Version(1, 0, 0),
          dart: Sdk(type: SdkType.dart, version: Version(3, 5, 0)),
        ),
        apis: {
          'admin': ResolvedApi(
            apiId: 'admin',
            policySet: PolicySet(
              policies: {
                'api-admin_restrict': forbidUnless(
                  apiAdmin,
                  id: 'api-admin_restrict',
                  unlessRole: roleAdmin,
                ),
              },
              templateLinks: const [
                TemplateLink(
                  templateId: 'cloud.functions.admin',
                  newId: 'api-admin',
                  values: {SlotId.resource: apiAdmin},
                ),
              ],
            ),
            functions: {
              'admin': ResolvedCloudFunction(
                apiId: 'admin',
                functionId: 'admin',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/admin/test'),
                ),
              ),
              'adminAdmin': ResolvedCloudFunction(
                apiId: 'admin',
                functionId: 'adminAdmin',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/admin/admin'),
                ),
                policySet: PolicySet(
                  policies: {
                    'admin-admin_restrict': forbidUnless(
                      adminFunctionAdmin,
                      id: 'admin-admin_restrict',
                      unlessRole: roleAdmin,
                    ),
                  },
                  templateLinks: const [
                    TemplateLink(
                      templateId: 'cloud.functions.admin',
                      newId: 'admin-admin',
                      values: {SlotId.resource: adminFunctionAdmin},
                    ),
                  ],
                ),
              ),
              'adminAuthenticated': ResolvedCloudFunction(
                apiId: 'admin',
                functionId: 'adminAuthenticated',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/admin/authenticated'),
                ),
                policySet: PolicySet(
                  policies: {
                    'admin-authenticated_restrict': forbidUnless(
                      adminFunctionAuthenticated,
                      id: 'admin-authenticated_restrict',
                      unlessRole: roleAuthenticated,
                    ),
                  },
                  templateLinks: const [
                    TemplateLink(
                      templateId: 'cloud.functions.authenticated',
                      newId: 'admin-authenticated',
                      values: {SlotId.resource: adminFunctionAuthenticated},
                    ),
                  ],
                ),
              ),
              'adminPublic': ResolvedCloudFunction(
                apiId: 'admin',
                functionId: 'adminPublic',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/admin/public'),
                ),
                policySet: PolicySet(
                  templateLinks: const [
                    TemplateLink(
                      templateId: 'cloud.functions.public',
                      newId: 'admin-public',
                      values: {SlotId.resource: adminFunctionPublic},
                    ),
                  ],
                ),
              ),
            },
          ),
          'authenticated': ResolvedApi(
            apiId: 'authenticated',
            policySet: PolicySet(
              policies: {
                'api-authenticated_restrict': forbidUnless(
                  apiAuthenticated,
                  id: 'api-authenticated_restrict',
                  unlessRole: roleAuthenticated,
                ),
              },
              templateLinks: const [
                TemplateLink(
                  templateId: 'cloud.functions.authenticated',
                  newId: 'api-authenticated',
                  values: {SlotId.resource: apiAuthenticated},
                ),
              ],
            ),
            functions: {
              'authenticated': ResolvedCloudFunction(
                apiId: 'authenticated',
                functionId: 'authenticated',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/authenticated/test'),
                ),
              ),
              'authenticatedAdmin': ResolvedCloudFunction(
                apiId: 'authenticated',
                functionId: 'authenticatedAdmin',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/authenticated/admin'),
                ),
                policySet: PolicySet(
                  policies: {
                    'authenticated-admin_restrict': forbidUnless(
                      authenticatedFunctionAdmin,
                      id: 'authenticated-admin_restrict',
                      unlessRole: roleAdmin,
                    ),
                  },
                  templateLinks: const [
                    TemplateLink(
                      templateId: 'cloud.functions.admin',
                      newId: 'authenticated-admin',
                      values: {SlotId.resource: authenticatedFunctionAdmin},
                    ),
                  ],
                ),
              ),
              'authenticatedAuthenticated': ResolvedCloudFunction(
                apiId: 'authenticated',
                functionId: 'authenticatedAuthenticated',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(
                    path: '/authenticated/authenticated',
                  ),
                ),
                policySet: PolicySet(
                  policies: {
                    'authenticated-authenticated_restrict': forbidUnless(
                      authenticatedFunctionAuthenticated,
                      id: 'authenticated-authenticated_restrict',
                      unlessRole: roleAuthenticated,
                    ),
                  },
                  templateLinks: const [
                    TemplateLink(
                      templateId: 'cloud.functions.authenticated',
                      newId: 'authenticated-authenticated',
                      values: {
                        SlotId.resource: authenticatedFunctionAuthenticated,
                      },
                    ),
                  ],
                ),
              ),
              'authenticatedPublic': ResolvedCloudFunction(
                apiId: 'authenticated',
                functionId: 'authenticatedPublic',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/authenticated/public'),
                ),
                policySet: PolicySet(
                  templateLinks: const [
                    TemplateLink(
                      templateId: 'cloud.functions.public',
                      newId: 'authenticated-public',
                      values: {SlotId.resource: authenticatedFunctionPublic},
                    ),
                  ],
                ),
              ),
            },
          ),
          'public': ResolvedApi(
            apiId: 'public',
            policySet: PolicySet(
              templateLinks: const [
                TemplateLink(
                  templateId: 'cloud.functions.public',
                  newId: 'api-public',
                  values: {SlotId.resource: apiPublic},
                ),
              ],
            ),
            functions: {
              'public': ResolvedCloudFunction(
                apiId: 'public',
                functionId: 'public',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/public/test'),
                ),
              ),
              'publicAdmin': ResolvedCloudFunction(
                apiId: 'public',
                functionId: 'publicAdmin',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/public/admin'),
                ),
                policySet: PolicySet(
                  policies: {
                    'public-admin_restrict': forbidUnless(
                      publicFunctionAdmin,
                      id: 'public-admin_restrict',
                      unlessRole: roleAdmin,
                    ),
                  },
                  templateLinks: const [
                    TemplateLink(
                      templateId: 'cloud.functions.admin',
                      newId: 'public-admin',
                      values: {SlotId.resource: publicFunctionAdmin},
                    ),
                  ],
                ),
              ),
              'publicAuthenticated': ResolvedCloudFunction(
                apiId: 'public',
                functionId: 'publicAuthenticated',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/public/authenticated'),
                ),
                policySet: PolicySet(
                  policies: {
                    'public-authenticated_restrict': forbidUnless(
                      publicFunctionAuthenticated,
                      id: 'public-authenticated_restrict',
                      unlessRole: roleAuthenticated,
                    ),
                  },
                  templateLinks: const [
                    TemplateLink(
                      templateId: 'cloud.functions.authenticated',
                      newId: 'public-authenticated',
                      values: {SlotId.resource: publicFunctionAuthenticated},
                    ),
                  ],
                ),
              ),
              'publicPublic': ResolvedCloudFunction(
                apiId: 'public',
                functionId: 'publicPublic',
                httpConfig: ResolvedHttpConfig(
                  route: ResolvedHttpRoute(path: '/public/public'),
                ),
                policySet: PolicySet(
                  templateLinks: const [
                    TemplateLink(
                      templateId: 'cloud.functions.public',
                      newId: 'public-public',
                      values: {SlotId.resource: publicFunctionPublic},
                    ),
                  ],
                ),
              ),
            },
          ),
        },
      );

      const entities = <Entity>[
        Entity(uid: userAlice, parents: [roleAdmin]),
        Entity(uid: userBob, parents: [roleAuthenticated]),
        Entity(uid: userCharlie, parents: [roleAnonymous]),
        Entity(uid: adminFunction, parents: [apiAdmin]),
        Entity(uid: adminFunctionAuthenticated, parents: [apiAdmin]),
        Entity(uid: adminFunctionAdmin, parents: [apiAdmin]),
        Entity(uid: adminFunctionPublic, parents: [apiAdmin]),
        Entity(uid: authenticatedFunction, parents: [apiAuthenticated]),
        Entity(
          uid: authenticatedFunctionAuthenticated,
          parents: [apiAuthenticated],
        ),
        Entity(uid: authenticatedFunctionAdmin, parents: [apiAuthenticated]),
        Entity(uid: authenticatedFunctionPublic, parents: [apiAuthenticated]),
        Entity(uid: publicFunction, parents: [apiPublic]),
        Entity(uid: publicFunctionAuthenticated, parents: [apiPublic]),
        Entity(uid: publicFunctionAdmin, parents: [apiPublic]),
        Entity(uid: publicFunctionPublic, parents: [apiPublic]),
      ];

      const adminFunctions = [
        adminFunction,
        adminFunctionAdmin,
        adminFunctionAuthenticated,
        adminFunctionPublic,
        authenticatedFunctionAdmin,
        publicFunctionAdmin,
      ];

      const authenticatedFunctions = [
        authenticatedFunction,
        authenticatedFunctionAuthenticated,
        authenticatedFunctionPublic,
        publicFunctionAuthenticated,
      ];

      const publicFunctions = [publicFunction, publicFunctionPublic];

      group('unauthenticated user', () {
        run(project: project, entities: entities, [
          for (final adminFunction in adminFunctions)
            (
              description: '$adminFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: adminFunction,
              ),
              expected: Decision.deny,
            ),
          for (final authenticatedFunction in authenticatedFunctions)
            (
              description: '$authenticatedFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: authenticatedFunction,
              ),
              expected: Decision.deny,
            ),
          for (final publicFunction in publicFunctions)
            (
              description: '$publicFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: publicFunction,
              ),
              expected: Decision.allow,
            ),
        ]);
      });

      group('anonymous user', () {
        run(project: project, entities: entities, [
          for (final adminFunction in adminFunctions)
            (
              description: '$adminFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: adminFunction,
                principal: userCharlie,
              ),
              expected: Decision.deny,
            ),
          for (final authenticatedFunction in authenticatedFunctions)
            (
              description: '$authenticatedFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: authenticatedFunction,
                principal: userCharlie,
              ),
              expected: Decision.deny,
            ),
          for (final publicFunction in publicFunctions)
            (
              description: '$publicFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: publicFunction,
                principal: userCharlie,
              ),
              expected: Decision.allow,
            ),
        ]);
      });

      group('authenticated user', () {
        run(project: project, entities: entities, [
          for (final adminFunction in adminFunctions)
            (
              description: '$adminFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: adminFunction,
                principal: userBob,
              ),
              expected: Decision.deny,
            ),
          for (final authenticatedFunction in authenticatedFunctions)
            (
              description: '$authenticatedFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: authenticatedFunction,
                principal: userBob,
              ),
              expected: Decision.allow,
            ),
          for (final publicFunction in publicFunctions)
            (
              description: '$publicFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: publicFunction,
                principal: userBob,
              ),
              expected: Decision.allow,
            ),
        ]);
      });

      group('admin user', () {
        run(project: project, entities: entities, [
          for (final adminFunction in adminFunctions)
            (
              description: '$adminFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: adminFunction,
                principal: userAlice,
              ),
              expected: Decision.allow,
            ),
          for (final authenticatedFunction in authenticatedFunctions)
            (
              description: '$authenticatedFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: authenticatedFunction,
                principal: userAlice,
              ),
              expected: Decision.allow,
            ),
          for (final publicFunction in publicFunctions)
            (
              description: '$publicFunction',
              request: AuthorizationRequest(
                action: actionInvoke,
                resource: publicFunction,
                principal: userAlice,
              ),
              expected: Decision.allow,
            ),
        ]);
      });
    });
  });
}
