// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Setup some global info
@ffi.Native<ffi.Pointer<libsql_error_t> Function(libsql_config_t)>()
external ffi.Pointer<libsql_error_t> libsql_setup(libsql_config_t config);

/// Get the error message from a error
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<libsql_error_t>)>()
external ffi.Pointer<ffi.Char> libsql_error_message(
  ffi.Pointer<libsql_error_t> self,
);

/// Create or open a database
@ffi.Native<libsql_database_t Function(libsql_database_desc_t)>()
external libsql_database_t libsql_database_init(libsql_database_desc_t desc);

/// Sync frames with the primary
@ffi.Native<libsql_sync_t Function(libsql_database_t)>()
external libsql_sync_t libsql_database_sync(libsql_database_t self);

/// Connect with the database
@ffi.Native<libsql_connection_t Function(libsql_database_t)>()
external libsql_connection_t libsql_database_connect(libsql_database_t self);

/// Begin a transaction
@ffi.Native<libsql_transaction_t Function(libsql_connection_t)>()
external libsql_transaction_t libsql_connection_transaction(
  libsql_connection_t self,
);

/// Send a batch statement in a connection
@ffi.Native<
  libsql_batch_t Function(libsql_connection_t, ffi.Pointer<ffi.Char>)
>()
external libsql_batch_t libsql_connection_batch(
  libsql_connection_t self,
  ffi.Pointer<ffi.Char> sql,
);

/// Send a batch statement in a connection
@ffi.Native<libsql_connection_info_t Function(libsql_connection_t)>()
external libsql_connection_info_t libsql_connection_info(
  libsql_connection_t self,
);

/// Send a batch statement in a transaction
@ffi.Native<
  libsql_batch_t Function(libsql_transaction_t, ffi.Pointer<ffi.Char>)
>()
external libsql_batch_t libsql_transaction_batch(
  libsql_transaction_t self,
  ffi.Pointer<ffi.Char> sql,
);

/// Prepare a statement in a connection
@ffi.Native<
  libsql_statement_t Function(libsql_connection_t, ffi.Pointer<ffi.Char>)
>()
external libsql_statement_t libsql_connection_prepare(
  libsql_connection_t self,
  ffi.Pointer<ffi.Char> sql,
);

/// Prepare a statement in a transaction
@ffi.Native<
  libsql_statement_t Function(libsql_transaction_t, ffi.Pointer<ffi.Char>)
>()
external libsql_statement_t libsql_transaction_prepare(
  libsql_transaction_t self,
  ffi.Pointer<ffi.Char> sql,
);

/// Execute a statement
@ffi.Native<libsql_execute_t Function(libsql_statement_t)>()
external libsql_execute_t libsql_statement_execute(libsql_statement_t self);

/// Query a statement
@ffi.Native<libsql_rows_t Function(libsql_statement_t)>()
external libsql_rows_t libsql_statement_query(libsql_statement_t self);

/// Reset a statement
@ffi.Native<ffi.Void Function(libsql_statement_t)>()
external void libsql_statement_reset(libsql_statement_t self);

/// Column count
@ffi.Native<ffi.Size Function(libsql_statement_t)>()
external int libsql_statement_column_count(libsql_statement_t self);

/// Get the next row from rows
@ffi.Native<libsql_row_t Function(libsql_rows_t)>()
external libsql_row_t libsql_rows_next(libsql_rows_t self);

/// Get the column name at the index
@ffi.Native<libsql_slice_t Function(libsql_rows_t, ffi.Int32)>()
external libsql_slice_t libsql_rows_column_name(libsql_rows_t self, int index);

/// Get rows column count
@ffi.Native<ffi.Int32 Function(libsql_rows_t)>()
external int libsql_rows_column_count(libsql_rows_t self);

/// Get the value at the the index
@ffi.Native<libsql_result_value_t Function(libsql_row_t, ffi.Int32)>()
external libsql_result_value_t libsql_row_value(libsql_row_t self, int index);

/// Get the column name at the the index
@ffi.Native<libsql_slice_t Function(libsql_row_t, ffi.Int32)>()
external libsql_slice_t libsql_row_name(libsql_row_t self, int index);

/// Get row column count
@ffi.Native<ffi.Int32 Function(libsql_row_t)>()
external int libsql_row_length(libsql_row_t self);

/// Check if the row is empty, indicating the end of `libsql_rows_next`
@ffi.Native<ffi.Bool Function(libsql_row_t)>()
external bool libsql_row_empty(libsql_row_t self);

/// Bind a named argument to a statement
@ffi.Native<
  libsql_bind_t Function(
    libsql_statement_t,
    ffi.Pointer<ffi.Char>,
    libsql_value_t,
  )
>()
external libsql_bind_t libsql_statement_bind_named(
  libsql_statement_t self,
  ffi.Pointer<ffi.Char> name,
  libsql_value_t value,
);

/// Bind a positional argument to a statement
@ffi.Native<libsql_bind_t Function(libsql_statement_t, libsql_value_t)>()
external libsql_bind_t libsql_statement_bind_value(
  libsql_statement_t self,
  libsql_value_t value,
);

/// Create a libsql integer value
@ffi.Native<libsql_value_t Function(ffi.Int64)>()
external libsql_value_t libsql_integer(int integer);

/// Create a libsql real value
@ffi.Native<libsql_value_t Function(ffi.Double)>()
external libsql_value_t libsql_real(double real);

/// Create a libsql text value
@ffi.Native<libsql_value_t Function(ffi.Pointer<ffi.Char>, ffi.Size)>()
external libsql_value_t libsql_text(ffi.Pointer<ffi.Char> ptr, int len);

/// Create a libsql blob value
@ffi.Native<libsql_value_t Function(ffi.Pointer<ffi.Uint8>, ffi.Size)>()
external libsql_value_t libsql_blob(ffi.Pointer<ffi.Uint8> ptr, int len);

/// Create a libsql null value
@ffi.Native<libsql_value_t Function()>()
external libsql_value_t libsql_null();

/// Deallocate and close a error
@ffi.Native<ffi.Void Function(ffi.Pointer<libsql_error_t>)>()
external void libsql_error_deinit(ffi.Pointer<libsql_error_t> self);

/// Deallocate and close a database
@ffi.Native<ffi.Void Function(libsql_database_t)>()
external void libsql_database_deinit(libsql_database_t self);

/// Deallocate and close a connection
@ffi.Native<ffi.Void Function(libsql_connection_t)>()
external void libsql_connection_deinit(libsql_connection_t self);

/// Deallocate and close a statement
@ffi.Native<ffi.Void Function(libsql_statement_t)>()
external void libsql_statement_deinit(libsql_statement_t self);

/// Deallocate and commit a transaction (transaction becomes invalid)
@ffi.Native<ffi.Void Function(libsql_transaction_t)>()
external void libsql_transaction_commit(libsql_transaction_t self);

/// Deallocate and rollback a transaction (transaction becomes invalid)
@ffi.Native<ffi.Void Function(libsql_transaction_t)>()
external void libsql_transaction_rollback(libsql_transaction_t self);

/// Deallocate and close rows
@ffi.Native<ffi.Void Function(libsql_rows_t)>()
external void libsql_rows_deinit(libsql_rows_t self);

/// Deallocate and close a row
@ffi.Native<ffi.Void Function(libsql_row_t)>()
external void libsql_row_deinit(libsql_row_t self);

/// Deallocate a slice
@ffi.Native<ffi.Void Function(libsql_slice_t)>()
external void libsql_slice_deinit(libsql_slice_t value);

final class libsql_error_t extends ffi.Opaque {}

enum libsql_cypher_t {
  LIBSQL_CYPHER_DEFAULT(0),
  LIBSQL_CYPHER_AES256(1);

  final int value;
  const libsql_cypher_t(this.value);

  static libsql_cypher_t fromValue(int value) => switch (value) {
    0 => LIBSQL_CYPHER_DEFAULT,
    1 => LIBSQL_CYPHER_AES256,
    _ => throw ArgumentError('Unknown value for libsql_cypher_t: $value'),
  };
}

enum libsql_type_t {
  LIBSQL_TYPE_INTEGER(1),
  LIBSQL_TYPE_REAL(2),
  LIBSQL_TYPE_TEXT(3),
  LIBSQL_TYPE_BLOB(4),
  LIBSQL_TYPE_NULL(5);

  final int value;
  const libsql_type_t(this.value);

  static libsql_type_t fromValue(int value) => switch (value) {
    1 => LIBSQL_TYPE_INTEGER,
    2 => LIBSQL_TYPE_REAL,
    3 => LIBSQL_TYPE_TEXT,
    4 => LIBSQL_TYPE_BLOB,
    5 => LIBSQL_TYPE_NULL,
    _ => throw ArgumentError('Unknown value for libsql_type_t: $value'),
  };
}

enum libsql_tracing_level_t {
  LIBSQL_TRACING_LEVEL_ERROR(1),
  LIBSQL_TRACING_LEVEL_WARN(2),
  LIBSQL_TRACING_LEVEL_INFO(3),
  LIBSQL_TRACING_LEVEL_DEBUG(4),
  LIBSQL_TRACING_LEVEL_TRACE(5);

  final int value;
  const libsql_tracing_level_t(this.value);

  static libsql_tracing_level_t fromValue(int value) => switch (value) {
    1 => LIBSQL_TRACING_LEVEL_ERROR,
    2 => LIBSQL_TRACING_LEVEL_WARN,
    3 => LIBSQL_TRACING_LEVEL_INFO,
    4 => LIBSQL_TRACING_LEVEL_DEBUG,
    5 => LIBSQL_TRACING_LEVEL_TRACE,
    _ => throw ArgumentError(
      'Unknown value for libsql_tracing_level_t: $value',
    ),
  };
}

final class libsql_log_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> message;

  external ffi.Pointer<ffi.Char> target;

  external ffi.Pointer<ffi.Char> file;

  @ffi.Uint64()
  external int timestamp;

  @ffi.Size()
  external int line;

  @ffi.UnsignedInt()
  external int levelAsInt;

  libsql_tracing_level_t get level =>
      libsql_tracing_level_t.fromValue(levelAsInt);
}

final class libsql_database_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;

  external ffi.Pointer<ffi.Void> inner;
}

final class libsql_connection_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;

  external ffi.Pointer<ffi.Void> inner;
}

final class libsql_statement_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;

  external ffi.Pointer<ffi.Void> inner;
}

final class libsql_transaction_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;

  external ffi.Pointer<ffi.Void> inner;
}

final class libsql_rows_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;

  external ffi.Pointer<ffi.Void> inner;
}

final class libsql_row_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;

  external ffi.Pointer<ffi.Void> inner;
}

final class libsql_batch_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;
}

final class libsql_slice_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ptr;

  @ffi.Size()
  external int len;
}

final class libsql_value_union_t extends ffi.Union {
  @ffi.Int64()
  external int integer;

  @ffi.Double()
  external double real;

  external libsql_slice_t text;

  external libsql_slice_t blob;
}

final class libsql_value_t extends ffi.Struct {
  external libsql_value_union_t value;

  @ffi.UnsignedInt()
  external int typeAsInt;

  libsql_type_t get type => libsql_type_t.fromValue(typeAsInt);
}

final class libsql_result_value_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;

  external libsql_value_t ok;
}

final class libsql_sync_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;

  @ffi.Uint64()
  external int frame_no;

  @ffi.Uint64()
  external int frames_synced;
}

final class libsql_bind_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;
}

final class libsql_execute_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;

  @ffi.Uint64()
  external int rows_changed;
}

final class libsql_connection_info_t extends ffi.Struct {
  external ffi.Pointer<libsql_error_t> err;

  @ffi.Int64()
  external int last_inserted_rowid;

  @ffi.Uint64()
  external int total_changes;
}

/// Database description.
final class libsql_database_desc_t extends ffi.Struct {
  /// The url to the primary database
  external ffi.Pointer<ffi.Char> url;

  /// Path to the database file or `:memory:`
  external ffi.Pointer<ffi.Char> path;

  /// Auth token to access the primary
  external ffi.Pointer<ffi.Char> auth_token;

  /// Encryption key to encrypt and decrypt the database in `path`
  external ffi.Pointer<ffi.Char> encryption_key;

  /// Interval to periodicaly sync with primary
  @ffi.Uint64()
  external int sync_interval;

  /// Cypher to be used with `encryption_key`
  @ffi.UnsignedInt()
  external int cypherAsInt;

  libsql_cypher_t get cypher => libsql_cypher_t.fromValue(cypherAsInt);

  /// If set, disable `read_your_writes`. To mantain consistency.
  @ffi.Bool()
  external bool disable_read_your_writes;

  /// Enable Webpki connector
  @ffi.Bool()
  external bool webpki;

  /// Offline writes
  @ffi.Bool()
  external bool synced;

  /// Safety assert
  @ffi.Bool()
  external bool disable_safety_assert;

  /// Provide a namespace through a header.
  external ffi.Pointer<ffi.Char> namespace;
}

final class libsql_config_t extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(libsql_log_t log)>>
  logger;

  external ffi.Pointer<ffi.Char> version;
}
