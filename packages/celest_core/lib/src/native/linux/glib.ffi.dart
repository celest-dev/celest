// ignore_for_file: type=lint
// ignore_for_file: return_of_invalid_type
// ignore_for_file: unnecessary_non_null_assertion

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for glib on Linux.
///
/// Regenerate bindings with `dart run ffigen --config=ffigen.glib.yaml`.
///
class Glib {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Glib(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Glib.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<GHashTable> g_hash_table_new(
    ffi.Pointer<
            ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Void>)>>
        hash_func,
    ffi.Pointer<
            ffi.NativeFunction<
                gboolean Function(
                    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        key_equal_func,
  ) {
    return _g_hash_table_new(
      hash_func,
      key_equal_func,
    );
  }

  late final _g_hash_table_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GHashTable> Function(
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.UnsignedInt Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      gboolean Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('g_hash_table_new');
  late final _g_hash_table_new = _g_hash_table_newPtr.asFunction<
      ffi.Pointer<GHashTable> Function(
          ffi.Pointer<
              ffi
              .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Void>)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  gboolean Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void g_hash_table_destroy(
    ffi.Pointer<GHashTable> hash_table,
  ) {
    return _g_hash_table_destroy(
      hash_table,
    );
  }

  late final _g_hash_table_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GHashTable>)>>(
          'g_hash_table_destroy');
  late final _g_hash_table_destroy = _g_hash_table_destroyPtr
      .asFunction<void Function(ffi.Pointer<GHashTable>)>();

  int g_hash_table_insert(
    ffi.Pointer<GHashTable> hash_table,
    gpointer key,
    gpointer value,
  ) {
    return _g_hash_table_insert(
      hash_table,
      key,
      value,
    );
  }

  late final _g_hash_table_insertPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GHashTable>, gpointer,
              gpointer)>>('g_hash_table_insert');
  late final _g_hash_table_insert = _g_hash_table_insertPtr
      .asFunction<int Function(ffi.Pointer<GHashTable>, gpointer, gpointer)>();
}

final class GError extends ffi.Struct {
  @ffi.UnsignedInt()
  external int domain;

  @gint()
  external int code;

  external ffi.Pointer<ffi.Char> message;
}

typedef gint = ffi.Int;
typedef Dartgint = int;

final class GHashTable extends ffi.Opaque {}

typedef gboolean = gint;
typedef gpointer = ffi.Pointer<ffi.Void>;

/// GObject:
///
/// The base object type.
///
/// All the fields in the `GObject` structure are private to the implementation
/// and should never be accessed directly.
///
/// Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the
/// alignment of the largest basic GLib type (typically this is #guint64 or
/// #gdouble). If you need larger alignment for an element in a #GObject, you
/// should allocate it on the heap (aligned), or arrange for your #GObject to be
/// appropriately padded. This guarantee applies to the #GObject (or derived)
/// struct, the #GObjectClass (or derived) struct, and any private data allocated
/// by G_ADD_PRIVATE().
final class GObject extends ffi.Struct {
  external _GTypeInstance g_type_instance;

  /// (atomic)
  @ffi.UnsignedInt()
  external int ref_count;

  external ffi.Pointer<_GData> qdata;
}

/// GTypeInstance:
///
/// An opaque structure used as the base of all type instances.
final class _GTypeInstance extends ffi.Struct {
  /// < private >
  external ffi.Pointer<_GTypeClass> g_class;
}

/// Basic Type Structures
/// /
/// /**
/// GTypeClass:
///
/// An opaque structure used as the base of all classes.
final class _GTypeClass extends ffi.Struct {
  /// < private >
  @ffi.UnsignedLong()
  external int g_type;
}

final class _GData extends ffi.Opaque {}

final class GCancellable extends ffi.Struct {
  external GObject parent_instance;

  /// < private >
  external ffi.Pointer<_GCancellablePrivate> priv;
}

final class _GCancellablePrivate extends ffi.Opaque {}
