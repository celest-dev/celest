// ignore_for_file: type=lint
// ignore_for_file: return_of_invalid_type
// ignore_for_file: unnecessary_non_null_assertion

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart' as pkg_ffi;

/// Bindings for Foundation on macOS/iOS.
///
/// Regenerate bindings with `dart run ffigen --config=ffigen.foundation.yaml`.
///
class Foundation {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Foundation(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Foundation.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ObjCSel> _registerName1(String name) {
    final cstr = name.toNativeUtf8();
    final sel = _sel_registerName(cstr.cast());
    pkg_ffi.calloc.free(cstr);
    return sel;
  }

  ffi.Pointer<ObjCSel> _sel_registerName(
    ffi.Pointer<ffi.Char> str,
  ) {
    return __sel_registerName(
      str,
    );
  }

  late final __sel_registerNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCSel> Function(
              ffi.Pointer<ffi.Char>)>>('sel_registerName');
  late final __sel_registerName = __sel_registerNamePtr
      .asFunction<ffi.Pointer<ObjCSel> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ObjCObject> _getClass1(String name) {
    final cstr = name.toNativeUtf8();
    final clazz = _objc_getClass(cstr.cast());
    pkg_ffi.calloc.free(cstr);
    if (clazz == ffi.nullptr) {
      throw Exception('Failed to load Objective-C class: $name');
    }
    return clazz;
  }

  ffi.Pointer<ObjCObject> _objc_getClass(
    ffi.Pointer<ffi.Char> str,
  ) {
    return __objc_getClass(
      str,
    );
  }

  late final __objc_getClassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ffi.Char>)>>('objc_getClass');
  late final __objc_getClass = __objc_getClassPtr
      .asFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ObjCObject> _objc_retain(
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_retain(
      value,
    );
  }

  late final __objc_retainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>)>>('objc_retain');
  late final __objc_retain = __objc_retainPtr
      .asFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>)>();

  void _objc_release(
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_release(
      value,
    );
  }

  late final __objc_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ObjCObject>)>>(
          'objc_release');
  late final __objc_release =
      __objc_releasePtr.asFunction<void Function(ffi.Pointer<ObjCObject>)>();

  late final _objc_releaseFinalizer2 =
      ffi.NativeFinalizer(__objc_releasePtr.cast());
  late final _class_NSString1 = _getClass1("NSString");
  bool _objc_msgSend_0(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> clazz,
  ) {
    return __objc_msgSend_0(
      obj,
      sel,
      clazz,
    );
  }

  late final __objc_msgSend_0Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_0 = __objc_msgSend_0Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_isKindOfClass_1 = _registerName1("isKindOfClass:");
  late final _class_NSObject1 = _getClass1("NSObject");
  late final _sel_load1 = _registerName1("load");
  void _objc_msgSend_1(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_1(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_1 = __objc_msgSend_1Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_initialize1 = _registerName1("initialize");
  late final _sel_init1 = _registerName1("init");
  instancetype _objc_msgSend_2(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_2(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_2Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_2 = __objc_msgSend_2Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_new1 = _registerName1("new");
  late final _sel_allocWithZone_1 = _registerName1("allocWithZone:");
  instancetype _objc_msgSend_3(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<NSZone> zone,
  ) {
    return __objc_msgSend_3(
      obj,
      sel,
      zone,
    );
  }

  late final __objc_msgSend_3Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<NSZone>)>>('objc_msgSend');
  late final __objc_msgSend_3 = __objc_msgSend_3Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<NSZone>)>();

  late final _sel_alloc1 = _registerName1("alloc");
  late final _sel_dealloc1 = _registerName1("dealloc");
  late final _sel_finalize1 = _registerName1("finalize");
  late final _sel_copy1 = _registerName1("copy");
  late final _sel_mutableCopy1 = _registerName1("mutableCopy");
  late final _sel_copyWithZone_1 = _registerName1("copyWithZone:");
  late final _sel_mutableCopyWithZone_1 =
      _registerName1("mutableCopyWithZone:");
  late final _sel_instancesRespondToSelector_1 =
      _registerName1("instancesRespondToSelector:");
  bool _objc_msgSend_4(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_4(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_4 = __objc_msgSend_4Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _class_Protocol1 = _getClass1("Protocol");
  late final _sel_conformsToProtocol_1 = _registerName1("conformsToProtocol:");
  bool _objc_msgSend_5(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> protocol,
  ) {
    return __objc_msgSend_5(
      obj,
      sel,
      protocol,
    );
  }

  late final __objc_msgSend_5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_5 = __objc_msgSend_5Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_methodForSelector_1 = _registerName1("methodForSelector:");
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _objc_msgSend_6(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_6(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_6 = __objc_msgSend_6Ptr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _sel_instanceMethodForSelector_1 =
      _registerName1("instanceMethodForSelector:");
  late final _sel_doesNotRecognizeSelector_1 =
      _registerName1("doesNotRecognizeSelector:");
  void _objc_msgSend_7(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_7(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_7 = __objc_msgSend_7Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _sel_forwardingTargetForSelector_1 =
      _registerName1("forwardingTargetForSelector:");
  ffi.Pointer<ObjCObject> _objc_msgSend_8(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_8(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_8 = __objc_msgSend_8Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>();

  late final _class_NSInvocation1 = _getClass1("NSInvocation");
  late final _sel_forwardInvocation_1 = _registerName1("forwardInvocation:");
  void _objc_msgSend_9(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anInvocation,
  ) {
    return __objc_msgSend_9(
      obj,
      sel,
      anInvocation,
    );
  }

  late final __objc_msgSend_9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_9 = __objc_msgSend_9Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _class_NSMethodSignature1 = _getClass1("NSMethodSignature");
  late final _sel_methodSignatureForSelector_1 =
      _registerName1("methodSignatureForSelector:");
  ffi.Pointer<ObjCObject> _objc_msgSend_10(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_10(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_10 = __objc_msgSend_10Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>();

  late final _sel_instanceMethodSignatureForSelector_1 =
      _registerName1("instanceMethodSignatureForSelector:");
  late final _sel_allowsWeakReference1 = _registerName1("allowsWeakReference");
  bool _objc_msgSend_11(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_11(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_11 = __objc_msgSend_11Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_retainWeakReference1 = _registerName1("retainWeakReference");
  late final _sel_isSubclassOfClass_1 = _registerName1("isSubclassOfClass:");
  late final _sel_resolveClassMethod_1 = _registerName1("resolveClassMethod:");
  late final _sel_resolveInstanceMethod_1 =
      _registerName1("resolveInstanceMethod:");
  late final _sel_hash1 = _registerName1("hash");
  int _objc_msgSend_12(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_12(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_12 = __objc_msgSend_12Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_superclass1 = _registerName1("superclass");
  late final _sel_class1 = _registerName1("class");
  late final _sel_description1 = _registerName1("description");
  ffi.Pointer<ObjCObject> _objc_msgSend_13(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_13(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_13 = __objc_msgSend_13Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_debugDescription1 = _registerName1("debugDescription");
  late final _class_NSURL1 = _getClass1("NSURL");
  late final _sel_initWithScheme_host_path_1 =
      _registerName1("initWithScheme:host:path:");
  instancetype _objc_msgSend_14(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> scheme,
    ffi.Pointer<ObjCObject> host,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_14(
      obj,
      sel,
      scheme,
      host,
      path,
    );
  }

  late final __objc_msgSend_14Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_14 = __objc_msgSend_14Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initFileURLWithPath_isDirectory_relativeToURL_1 =
      _registerName1("initFileURLWithPath:isDirectory:relativeToURL:");
  instancetype _objc_msgSend_15(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool isDir,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_15(
      obj,
      sel,
      path,
      isDir,
      baseURL,
    );
  }

  late final __objc_msgSend_15Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_15 = __objc_msgSend_15Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool, ffi.Pointer<ObjCObject>)>();

  late final _sel_initFileURLWithPath_relativeToURL_1 =
      _registerName1("initFileURLWithPath:relativeToURL:");
  instancetype _objc_msgSend_16(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_16(
      obj,
      sel,
      path,
      baseURL,
    );
  }

  late final __objc_msgSend_16Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_16 = __objc_msgSend_16Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_initFileURLWithPath_isDirectory_1 =
      _registerName1("initFileURLWithPath:isDirectory:");
  instancetype _objc_msgSend_17(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool isDir,
  ) {
    return __objc_msgSend_17(
      obj,
      sel,
      path,
      isDir,
    );
  }

  late final __objc_msgSend_17Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_17 = __objc_msgSend_17Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_initFileURLWithPath_1 =
      _registerName1("initFileURLWithPath:");
  instancetype _objc_msgSend_18(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_18(
      obj,
      sel,
      path,
    );
  }

  late final __objc_msgSend_18Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_18 = __objc_msgSend_18Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_fileURLWithPath_isDirectory_relativeToURL_1 =
      _registerName1("fileURLWithPath:isDirectory:relativeToURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_19(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool isDir,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_19(
      obj,
      sel,
      path,
      isDir,
      baseURL,
    );
  }

  late final __objc_msgSend_19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_19 = __objc_msgSend_19Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          bool,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_fileURLWithPath_relativeToURL_1 =
      _registerName1("fileURLWithPath:relativeToURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_20(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_20(
      obj,
      sel,
      path,
      baseURL,
    );
  }

  late final __objc_msgSend_20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_20 = __objc_msgSend_20Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_fileURLWithPath_isDirectory_1 =
      _registerName1("fileURLWithPath:isDirectory:");
  ffi.Pointer<ObjCObject> _objc_msgSend_21(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool isDir,
  ) {
    return __objc_msgSend_21(
      obj,
      sel,
      path,
      isDir,
    );
  }

  late final __objc_msgSend_21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_21 = __objc_msgSend_21Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_fileURLWithPath_1 = _registerName1("fileURLWithPath:");
  ffi.Pointer<ObjCObject> _objc_msgSend_22(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_22(
      obj,
      sel,
      path,
    );
  }

  late final __objc_msgSend_22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_22 = __objc_msgSend_22Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL_1 =
      _registerName1(
          "initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:");
  instancetype _objc_msgSend_23(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> path,
    bool isDir,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_23(
      obj,
      sel,
      path,
      isDir,
      baseURL,
    );
  }

  late final __objc_msgSend_23Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_23 = __objc_msgSend_23Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>, bool, ffi.Pointer<ObjCObject>)>();

  late final _sel_fileURLWithFileSystemRepresentation_isDirectory_relativeToURL_1 =
      _registerName1(
          "fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_24(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> path,
    bool isDir,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_24(
      obj,
      sel,
      path,
      isDir,
      baseURL,
    );
  }

  late final __objc_msgSend_24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_24 = __objc_msgSend_24Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>,
          bool,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithString_1 = _registerName1("initWithString:");
  instancetype _objc_msgSend_25(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> URLString,
  ) {
    return __objc_msgSend_25(
      obj,
      sel,
      URLString,
    );
  }

  late final __objc_msgSend_25Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_25 = __objc_msgSend_25Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithString_relativeToURL_1 =
      _registerName1("initWithString:relativeToURL:");
  instancetype _objc_msgSend_26(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> URLString,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_26(
      obj,
      sel,
      URLString,
      baseURL,
    );
  }

  late final __objc_msgSend_26Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_26 = __objc_msgSend_26Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_URLWithString_1 = _registerName1("URLWithString:");
  late final _sel_URLWithString_relativeToURL_1 =
      _registerName1("URLWithString:relativeToURL:");
  late final _sel_initWithString_encodingInvalidCharacters_1 =
      _registerName1("initWithString:encodingInvalidCharacters:");
  instancetype _objc_msgSend_27(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> URLString,
    bool encodingInvalidCharacters,
  ) {
    return __objc_msgSend_27(
      obj,
      sel,
      URLString,
      encodingInvalidCharacters,
    );
  }

  late final __objc_msgSend_27Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_27 = __objc_msgSend_27Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_URLWithString_encodingInvalidCharacters_1 =
      _registerName1("URLWithString:encodingInvalidCharacters:");
  late final _class_NSData1 = _getClass1("NSData");
  late final _sel_bytes1 = _registerName1("bytes");
  ffi.Pointer<ffi.Void> _objc_msgSend_28(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_28(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_28Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_28 = __objc_msgSend_28Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_initWithDataRepresentation_relativeToURL_1 =
      _registerName1("initWithDataRepresentation:relativeToURL:");
  instancetype _objc_msgSend_29(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_29(
      obj,
      sel,
      data,
      baseURL,
    );
  }

  late final __objc_msgSend_29Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_29 = __objc_msgSend_29Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_URLWithDataRepresentation_relativeToURL_1 =
      _registerName1("URLWithDataRepresentation:relativeToURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_30(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_30(
      obj,
      sel,
      data,
      baseURL,
    );
  }

  late final __objc_msgSend_30Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_30 = __objc_msgSend_30Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initAbsoluteURLWithDataRepresentation_relativeToURL_1 =
      _registerName1("initAbsoluteURLWithDataRepresentation:relativeToURL:");
  late final _sel_absoluteURLWithDataRepresentation_relativeToURL_1 =
      _registerName1("absoluteURLWithDataRepresentation:relativeToURL:");
  late final _sel_dataRepresentation1 = _registerName1("dataRepresentation");
  ffi.Pointer<ObjCObject> _objc_msgSend_31(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_31(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_31Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_31 = __objc_msgSend_31Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_absoluteString1 = _registerName1("absoluteString");
  ffi.Pointer<ObjCObject> _objc_msgSend_32(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_32(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_32 = __objc_msgSend_32Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_relativeString1 = _registerName1("relativeString");
  late final _sel_baseURL1 = _registerName1("baseURL");
  ffi.Pointer<ObjCObject> _objc_msgSend_33(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_33(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_33Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_33 = __objc_msgSend_33Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_absoluteURL1 = _registerName1("absoluteURL");
  late final _sel_scheme1 = _registerName1("scheme");
  late final _sel_resourceSpecifier1 = _registerName1("resourceSpecifier");
  late final _sel_host1 = _registerName1("host");
  late final _class_NSNumber1 = _getClass1("NSNumber");
  late final _class_NSValue1 = _getClass1("NSValue");
  late final _sel_getValue_size_1 = _registerName1("getValue:size:");
  void _objc_msgSend_34(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> value,
    int size,
  ) {
    return __objc_msgSend_34(
      obj,
      sel,
      value,
      size,
    );
  }

  late final __objc_msgSend_34Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_34 = __objc_msgSend_34Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, int)>();

  late final _sel_objCType1 = _registerName1("objCType");
  ffi.Pointer<ffi.Char> _objc_msgSend_35(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_35(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_35Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_35 = __objc_msgSend_35Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_initWithBytes_objCType_1 =
      _registerName1("initWithBytes:objCType:");
  instancetype _objc_msgSend_36(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> value,
    ffi.Pointer<ffi.Char> type,
  ) {
    return __objc_msgSend_36(
      obj,
      sel,
      value,
      type,
    );
  }

  late final __objc_msgSend_36Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>>('objc_msgSend');
  late final __objc_msgSend_36 = __objc_msgSend_36Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>();

  late final _class_NSCoder1 = _getClass1("NSCoder");
  late final _sel_initWithCoder_1 = _registerName1("initWithCoder:");
  instancetype _objc_msgSend_37(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> coder,
  ) {
    return __objc_msgSend_37(
      obj,
      sel,
      coder,
    );
  }

  late final __objc_msgSend_37Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_37 = __objc_msgSend_37Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithChar_1 = _registerName1("initWithChar:");
  ffi.Pointer<ObjCObject> _objc_msgSend_38(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_38(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_38Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Char)>>('objc_msgSend');
  late final __objc_msgSend_38 = __objc_msgSend_38Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithUnsignedChar_1 =
      _registerName1("initWithUnsignedChar:");
  ffi.Pointer<ObjCObject> _objc_msgSend_39(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_39(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_39Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedChar)>>('objc_msgSend');
  late final __objc_msgSend_39 = __objc_msgSend_39Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithShort_1 = _registerName1("initWithShort:");
  ffi.Pointer<ObjCObject> _objc_msgSend_40(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_40(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_40Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Short)>>('objc_msgSend');
  late final __objc_msgSend_40 = __objc_msgSend_40Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithUnsignedShort_1 =
      _registerName1("initWithUnsignedShort:");
  ffi.Pointer<ObjCObject> _objc_msgSend_41(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_41(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_41Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedShort)>>('objc_msgSend');
  late final __objc_msgSend_41 = __objc_msgSend_41Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithInt_1 = _registerName1("initWithInt:");
  ffi.Pointer<ObjCObject> _objc_msgSend_42(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_42(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_42Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Int)>>('objc_msgSend');
  late final __objc_msgSend_42 = __objc_msgSend_42Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithUnsignedInt_1 =
      _registerName1("initWithUnsignedInt:");
  ffi.Pointer<ObjCObject> _objc_msgSend_43(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_43(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_43Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedInt)>>('objc_msgSend');
  late final __objc_msgSend_43 = __objc_msgSend_43Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithLong_1 = _registerName1("initWithLong:");
  ffi.Pointer<ObjCObject> _objc_msgSend_44(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_44(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_44Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Long)>>('objc_msgSend');
  late final __objc_msgSend_44 = __objc_msgSend_44Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithUnsignedLong_1 =
      _registerName1("initWithUnsignedLong:");
  ffi.Pointer<ObjCObject> _objc_msgSend_45(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_45(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_45Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_45 = __objc_msgSend_45Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithLongLong_1 = _registerName1("initWithLongLong:");
  ffi.Pointer<ObjCObject> _objc_msgSend_46(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_46(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_46Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.LongLong)>>('objc_msgSend');
  late final __objc_msgSend_46 = __objc_msgSend_46Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithUnsignedLongLong_1 =
      _registerName1("initWithUnsignedLongLong:");
  ffi.Pointer<ObjCObject> _objc_msgSend_47(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_47(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_47Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLongLong)>>('objc_msgSend');
  late final __objc_msgSend_47 = __objc_msgSend_47Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithFloat_1 = _registerName1("initWithFloat:");
  ffi.Pointer<ObjCObject> _objc_msgSend_48(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    double value,
  ) {
    return __objc_msgSend_48(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Float)>>('objc_msgSend');
  late final __objc_msgSend_48 = __objc_msgSend_48Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, double)>();

  late final _sel_initWithDouble_1 = _registerName1("initWithDouble:");
  ffi.Pointer<ObjCObject> _objc_msgSend_49(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    double value,
  ) {
    return __objc_msgSend_49(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_49Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Double)>>('objc_msgSend');
  late final __objc_msgSend_49 = __objc_msgSend_49Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, double)>();

  late final _sel_initWithBool_1 = _registerName1("initWithBool:");
  ffi.Pointer<ObjCObject> _objc_msgSend_50(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    bool value,
  ) {
    return __objc_msgSend_50(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_50Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_50 = __objc_msgSend_50Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, bool)>();

  late final _sel_initWithInteger_1 = _registerName1("initWithInteger:");
  late final _sel_initWithUnsignedInteger_1 =
      _registerName1("initWithUnsignedInteger:");
  late final _sel_charValue1 = _registerName1("charValue");
  int _objc_msgSend_51(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_51(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_51Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Char Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_51 = __objc_msgSend_51Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_unsignedCharValue1 = _registerName1("unsignedCharValue");
  int _objc_msgSend_52(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_52(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_52Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedChar Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_52 = __objc_msgSend_52Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_shortValue1 = _registerName1("shortValue");
  int _objc_msgSend_53(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_53(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_53Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_53 = __objc_msgSend_53Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_unsignedShortValue1 = _registerName1("unsignedShortValue");
  int _objc_msgSend_54(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_54(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_54Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedShort Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_54 = __objc_msgSend_54Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_intValue1 = _registerName1("intValue");
  int _objc_msgSend_55(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_55(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_55Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_55 = __objc_msgSend_55Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_unsignedIntValue1 = _registerName1("unsignedIntValue");
  int _objc_msgSend_56(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_56(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_56Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_56 = __objc_msgSend_56Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_longValue1 = _registerName1("longValue");
  int _objc_msgSend_57(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_57(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_57Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_57 = __objc_msgSend_57Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_unsignedLongValue1 = _registerName1("unsignedLongValue");
  late final _sel_longLongValue1 = _registerName1("longLongValue");
  int _objc_msgSend_58(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_58(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_58Ptr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_58 = __objc_msgSend_58Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_unsignedLongLongValue1 =
      _registerName1("unsignedLongLongValue");
  int _objc_msgSend_59(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_59(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_59Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_59 = __objc_msgSend_59Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_floatValue1 = _registerName1("floatValue");
  late final _objc_msgSend_useVariants1 = ffi.Abi.current() == ffi.Abi.iosX64 ||
      ffi.Abi.current() == ffi.Abi.macosX64;
  double _objc_msgSend_60(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_60(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_60Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_60 = __objc_msgSend_60Ptr.asFunction<
      double Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  double _objc_msgSend_60_fpret(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_60_fpret(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_60_fpretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend_fpret');
  late final __objc_msgSend_60_fpret = __objc_msgSend_60_fpretPtr.asFunction<
      double Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_doubleValue1 = _registerName1("doubleValue");
  double _objc_msgSend_61(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_61(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_61Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_61 = __objc_msgSend_61Ptr.asFunction<
      double Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  double _objc_msgSend_61_fpret(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_61_fpret(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_61_fpretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend_fpret');
  late final __objc_msgSend_61_fpret = __objc_msgSend_61_fpretPtr.asFunction<
      double Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_boolValue1 = _registerName1("boolValue");
  late final _sel_integerValue1 = _registerName1("integerValue");
  late final _sel_unsignedIntegerValue1 =
      _registerName1("unsignedIntegerValue");
  late final _sel_stringValue1 = _registerName1("stringValue");
  late final _sel_compare_1 = _registerName1("compare:");
  int _objc_msgSend_62(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> otherNumber,
  ) {
    return __objc_msgSend_62(
      obj,
      sel,
      otherNumber,
    );
  }

  late final __objc_msgSend_62Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_62 = __objc_msgSend_62Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_isEqualToNumber_1 = _registerName1("isEqualToNumber:");
  bool _objc_msgSend_63(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> number,
  ) {
    return __objc_msgSend_63(
      obj,
      sel,
      number,
    );
  }

  late final __objc_msgSend_63Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_63 = __objc_msgSend_63Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_descriptionWithLocale_1 =
      _registerName1("descriptionWithLocale:");
  ffi.Pointer<ObjCObject> _objc_msgSend_64(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> locale,
  ) {
    return __objc_msgSend_64(
      obj,
      sel,
      locale,
    );
  }

  late final __objc_msgSend_64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_64 = __objc_msgSend_64Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_port1 = _registerName1("port");
  ffi.Pointer<ObjCObject> _objc_msgSend_65(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_65(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_65Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_65 = __objc_msgSend_65Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_user1 = _registerName1("user");
  late final _sel_password1 = _registerName1("password");
  late final _sel_path1 = _registerName1("path");
  late final _sel_fragment1 = _registerName1("fragment");
  late final _sel_parameterString1 = _registerName1("parameterString");
  late final _sel_query1 = _registerName1("query");
  late final _sel_relativePath1 = _registerName1("relativePath");
  late final _sel_hasDirectoryPath1 = _registerName1("hasDirectoryPath");
  late final _sel_getFileSystemRepresentation_maxLength_1 =
      _registerName1("getFileSystemRepresentation:maxLength:");
  bool _objc_msgSend_66(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> buffer,
    int maxBufferLength,
  ) {
    return __objc_msgSend_66(
      obj,
      sel,
      buffer,
      maxBufferLength,
    );
  }

  late final __objc_msgSend_66Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_66 = __objc_msgSend_66Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>, int)>();

  late final _sel_fileSystemRepresentation1 =
      _registerName1("fileSystemRepresentation");
  late final _sel_isFileURL1 = _registerName1("isFileURL");
  late final _sel_standardizedURL1 = _registerName1("standardizedURL");
  late final _sel_isFileReferenceURL1 = _registerName1("isFileReferenceURL");
  late final _sel_fileReferenceURL1 = _registerName1("fileReferenceURL");
  late final _sel_filePathURL1 = _registerName1("filePathURL");
  late final _class_NSError1 = _getClass1("NSError");
  late final _class_NSDictionary1 = _getClass1("NSDictionary");
  late final _sel_initWithDomain_code_userInfo_1 =
      _registerName1("initWithDomain:code:userInfo:");
  instancetype _objc_msgSend_67(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> domain,
    int code,
    ffi.Pointer<ObjCObject> dict,
  ) {
    return __objc_msgSend_67(
      obj,
      sel,
      domain,
      code,
      dict,
    );
  }

  late final __objc_msgSend_67Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Long,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_67 = __objc_msgSend_67Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int, ffi.Pointer<ObjCObject>)>();

  late final _sel_errorWithDomain_code_userInfo_1 =
      _registerName1("errorWithDomain:code:userInfo:");
  late final _sel_domain1 = _registerName1("domain");
  late final _sel_code1 = _registerName1("code");
  late final _sel_userInfo1 = _registerName1("userInfo");
  ffi.Pointer<ObjCObject> _objc_msgSend_68(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_68(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_68Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_68 = __objc_msgSend_68Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_localizedDescription1 =
      _registerName1("localizedDescription");
  late final _sel_localizedFailureReason1 =
      _registerName1("localizedFailureReason");
  late final _sel_localizedRecoverySuggestion1 =
      _registerName1("localizedRecoverySuggestion");
  late final _sel_localizedRecoveryOptions1 =
      _registerName1("localizedRecoveryOptions");
  ffi.Pointer<ObjCObject> _objc_msgSend_69(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_69(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_69Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_69 = __objc_msgSend_69Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_recoveryAttempter1 = _registerName1("recoveryAttempter");
  late final _sel_helpAnchor1 = _registerName1("helpAnchor");
  late final _sel_underlyingErrors1 = _registerName1("underlyingErrors");
  ffi.Pointer<_ObjCBlockDesc> _newBlockDesc1() {
    final d =
        pkg_ffi.calloc.allocate<_ObjCBlockDesc>(ffi.sizeOf<_ObjCBlockDesc>());
    d.ref.reserved = 0;
    d.ref.size = ffi.sizeOf<_ObjCBlock>();
    d.ref.copy_helper = ffi.nullptr;
    d.ref.dispose_helper = ffi.nullptr;
    d.ref.signature = ffi.nullptr;
    return d;
  }

  late final _objc_block_desc1 = _newBlockDesc1();
  late final _objc_concrete_global_block1 =
      _lookup<ffi.Void>('_NSConcreteGlobalBlock');
  ffi.Pointer<_ObjCBlock> _newBlock1(
      ffi.Pointer<ffi.Void> invoke, ffi.Pointer<ffi.Void> target) {
    final b = pkg_ffi.calloc.allocate<_ObjCBlock>(ffi.sizeOf<_ObjCBlock>());
    b.ref.isa = _objc_concrete_global_block1;
    b.ref.flags = 0;
    b.ref.reserved = 0;
    b.ref.invoke = invoke;
    b.ref.target = target;
    b.ref.descriptor = _objc_block_desc1;
    final copy = _Block_copy(b.cast()).cast<_ObjCBlock>();
    pkg_ffi.calloc.free(b);
    return copy;
  }

  ffi.Pointer<ffi.Void> _Block_copy(
    ffi.Pointer<ffi.Void> value,
  ) {
    return __Block_copy(
      value,
    );
  }

  late final __Block_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>)>>('_Block_copy');
  late final __Block_copy = __Block_copyPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  void _Block_release(
    ffi.Pointer<ffi.Void> value,
  ) {
    return __Block_release(
      value,
    );
  }

  late final __Block_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          '_Block_release');
  late final __Block_release =
      __Block_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  late final _objc_releaseFinalizer11 =
      ffi.NativeFinalizer(__Block_releasePtr.cast());
  late final _sel_setUserInfoValueProviderForDomain_provider_1 =
      _registerName1("setUserInfoValueProviderForDomain:provider:");
  void _objc_msgSend_70(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> errorDomain,
    ffi.Pointer<_ObjCBlock> provider,
  ) {
    return __objc_msgSend_70(
      obj,
      sel,
      errorDomain,
      provider,
    );
  }

  late final __objc_msgSend_70Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_70 = __objc_msgSend_70Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_userInfoValueProviderForDomain_1 =
      _registerName1("userInfoValueProviderForDomain:");
  ffi.Pointer<_ObjCBlock> _objc_msgSend_71(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> err,
    ffi.Pointer<ObjCObject> userInfoKey,
    ffi.Pointer<ObjCObject> errorDomain,
  ) {
    return __objc_msgSend_71(
      obj,
      sel,
      err,
      userInfoKey,
      errorDomain,
    );
  }

  late final __objc_msgSend_71Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<_ObjCBlock> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_71 = __objc_msgSend_71Ptr.asFunction<
      ffi.Pointer<_ObjCBlock> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_getResourceValue_forKey_error_1 =
      _registerName1("getResourceValue:forKey:error:");
  bool _objc_msgSend_72(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Pointer<ObjCObject>> value,
    ffi.Pointer<ObjCObject> key,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_72(
      obj,
      sel,
      value,
      key,
      error,
    );
  }

  late final __objc_msgSend_72Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_72 = __objc_msgSend_72Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_resourceValuesForKeys_error_1 =
      _registerName1("resourceValuesForKeys:error:");
  ffi.Pointer<ObjCObject> _objc_msgSend_73(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> keys,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_73(
      obj,
      sel,
      keys,
      error,
    );
  }

  late final __objc_msgSend_73Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_73 = __objc_msgSend_73Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_setResourceValue_forKey_error_1 =
      _registerName1("setResourceValue:forKey:error:");
  bool _objc_msgSend_74(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
    ffi.Pointer<ObjCObject> key,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_74(
      obj,
      sel,
      value,
      key,
      error,
    );
  }

  late final __objc_msgSend_74Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_74 = __objc_msgSend_74Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_setResourceValues_error_1 =
      _registerName1("setResourceValues:error:");
  bool _objc_msgSend_75(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> keyedValues,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_75(
      obj,
      sel,
      keyedValues,
      error,
    );
  }

  late final __objc_msgSend_75Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_75 = __objc_msgSend_75Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_removeCachedResourceValueForKey_1 =
      _registerName1("removeCachedResourceValueForKey:");
  void _objc_msgSend_76(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> key,
  ) {
    return __objc_msgSend_76(
      obj,
      sel,
      key,
    );
  }

  late final __objc_msgSend_76Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_76 = __objc_msgSend_76Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_removeAllCachedResourceValues1 =
      _registerName1("removeAllCachedResourceValues");
  late final _sel_setTemporaryResourceValue_forKey_1 =
      _registerName1("setTemporaryResourceValue:forKey:");
  void _objc_msgSend_77(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
    ffi.Pointer<ObjCObject> key,
  ) {
    return __objc_msgSend_77(
      obj,
      sel,
      value,
      key,
    );
  }

  late final __objc_msgSend_77Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_77 = __objc_msgSend_77Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error_1 =
      _registerName1(
          "bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error:");
  ffi.Pointer<ObjCObject> _objc_msgSend_78(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int options,
    ffi.Pointer<ObjCObject> keys,
    ffi.Pointer<ObjCObject> relativeURL,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_78(
      obj,
      sel,
      options,
      keys,
      relativeURL,
      error,
    );
  }

  late final __objc_msgSend_78Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Int32,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_78 = __objc_msgSend_78Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          int,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_1 =
      _registerName1(
          "initByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:");
  instancetype _objc_msgSend_79(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> bookmarkData,
    int options,
    ffi.Pointer<ObjCObject> relativeURL,
    ffi.Pointer<ffi.Bool> isStale,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_79(
      obj,
      sel,
      bookmarkData,
      options,
      relativeURL,
      isStale,
      error,
    );
  }

  late final __objc_msgSend_79Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Bool>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_79 = __objc_msgSend_79Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Bool>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_1 =
      _registerName1(
          "URLByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:");
  late final _sel_resourceValuesForKeys_fromBookmarkData_1 =
      _registerName1("resourceValuesForKeys:fromBookmarkData:");
  ffi.Pointer<ObjCObject> _objc_msgSend_80(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> keys,
    ffi.Pointer<ObjCObject> bookmarkData,
  ) {
    return __objc_msgSend_80(
      obj,
      sel,
      keys,
      bookmarkData,
    );
  }

  late final __objc_msgSend_80Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_80 = __objc_msgSend_80Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_writeBookmarkData_toURL_options_error_1 =
      _registerName1("writeBookmarkData:toURL:options:error:");
  bool _objc_msgSend_81(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> bookmarkData,
    ffi.Pointer<ObjCObject> bookmarkFileURL,
    int options,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_81(
      obj,
      sel,
      bookmarkData,
      bookmarkFileURL,
      options,
      error,
    );
  }

  late final __objc_msgSend_81Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_81 = __objc_msgSend_81Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_bookmarkDataWithContentsOfURL_error_1 =
      _registerName1("bookmarkDataWithContentsOfURL:error:");
  ffi.Pointer<ObjCObject> _objc_msgSend_82(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> bookmarkFileURL,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_82(
      obj,
      sel,
      bookmarkFileURL,
      error,
    );
  }

  late final __objc_msgSend_82Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_82 = __objc_msgSend_82Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_URLByResolvingAliasFileAtURL_options_error_1 =
      _registerName1("URLByResolvingAliasFileAtURL:options:error:");
  instancetype _objc_msgSend_83(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    int options,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_83(
      obj,
      sel,
      url,
      options,
      error,
    );
  }

  late final __objc_msgSend_83Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_83 = __objc_msgSend_83Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_startAccessingSecurityScopedResource1 =
      _registerName1("startAccessingSecurityScopedResource");
  late final _sel_stopAccessingSecurityScopedResource1 =
      _registerName1("stopAccessingSecurityScopedResource");
  late final _sel_getPromisedItemResourceValue_forKey_error_1 =
      _registerName1("getPromisedItemResourceValue:forKey:error:");
  late final _sel_promisedItemResourceValuesForKeys_error_1 =
      _registerName1("promisedItemResourceValuesForKeys:error:");
  late final _sel_checkPromisedItemIsReachableAndReturnError_1 =
      _registerName1("checkPromisedItemIsReachableAndReturnError:");
  bool _objc_msgSend_84(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_84(
      obj,
      sel,
      error,
    );
  }

  late final __objc_msgSend_84Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_84 = __objc_msgSend_84Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_fileURLWithPathComponents_1 =
      _registerName1("fileURLWithPathComponents:");
  ffi.Pointer<ObjCObject> _objc_msgSend_85(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> components,
  ) {
    return __objc_msgSend_85(
      obj,
      sel,
      components,
    );
  }

  late final __objc_msgSend_85Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_85 = __objc_msgSend_85Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_pathComponents1 = _registerName1("pathComponents");
  late final _sel_lastPathComponent1 = _registerName1("lastPathComponent");
  late final _sel_pathExtension1 = _registerName1("pathExtension");
  late final _sel_URLByAppendingPathComponent_1 =
      _registerName1("URLByAppendingPathComponent:");
  ffi.Pointer<ObjCObject> _objc_msgSend_86(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> pathComponent,
  ) {
    return __objc_msgSend_86(
      obj,
      sel,
      pathComponent,
    );
  }

  late final __objc_msgSend_86Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_86 = __objc_msgSend_86Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_URLByAppendingPathComponent_isDirectory_1 =
      _registerName1("URLByAppendingPathComponent:isDirectory:");
  ffi.Pointer<ObjCObject> _objc_msgSend_87(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> pathComponent,
    bool isDirectory,
  ) {
    return __objc_msgSend_87(
      obj,
      sel,
      pathComponent,
      isDirectory,
    );
  }

  late final __objc_msgSend_87Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_87 = __objc_msgSend_87Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_URLByDeletingLastPathComponent1 =
      _registerName1("URLByDeletingLastPathComponent");
  late final _sel_URLByAppendingPathExtension_1 =
      _registerName1("URLByAppendingPathExtension:");
  late final _sel_URLByDeletingPathExtension1 =
      _registerName1("URLByDeletingPathExtension");
  late final _sel_checkResourceIsReachableAndReturnError_1 =
      _registerName1("checkResourceIsReachableAndReturnError:");
  late final _sel_URLByStandardizingPath1 =
      _registerName1("URLByStandardizingPath");
  late final _sel_URLByResolvingSymlinksInPath1 =
      _registerName1("URLByResolvingSymlinksInPath");
  late final _sel_resourceDataUsingCache_1 =
      _registerName1("resourceDataUsingCache:");
  ffi.Pointer<ObjCObject> _objc_msgSend_88(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    bool shouldUseCache,
  ) {
    return __objc_msgSend_88(
      obj,
      sel,
      shouldUseCache,
    );
  }

  late final __objc_msgSend_88Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_88 = __objc_msgSend_88Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, bool)>();

  late final _sel_loadResourceDataNotifyingClient_usingCache_1 =
      _registerName1("loadResourceDataNotifyingClient:usingCache:");
  void _objc_msgSend_89(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> client,
    bool shouldUseCache,
  ) {
    return __objc_msgSend_89(
      obj,
      sel,
      client,
      shouldUseCache,
    );
  }

  late final __objc_msgSend_89Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_89 = __objc_msgSend_89Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_propertyForKey_1 = _registerName1("propertyForKey:");
  late final _sel_setResourceData_1 = _registerName1("setResourceData:");
  bool _objc_msgSend_90(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
  ) {
    return __objc_msgSend_90(
      obj,
      sel,
      data,
    );
  }

  late final __objc_msgSend_90Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_90 = __objc_msgSend_90Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_setProperty_forKey_1 = _registerName1("setProperty:forKey:");
  bool _objc_msgSend_91(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> property,
    ffi.Pointer<ObjCObject> propertyKey,
  ) {
    return __objc_msgSend_91(
      obj,
      sel,
      property,
      propertyKey,
    );
  }

  late final __objc_msgSend_91Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_91 = __objc_msgSend_91Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSURLHandle1 = _getClass1("NSURLHandle");
  late final _sel_registerURLHandleClass_1 =
      _registerName1("registerURLHandleClass:");
  void _objc_msgSend_92(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anURLHandleSubclass,
  ) {
    return __objc_msgSend_92(
      obj,
      sel,
      anURLHandleSubclass,
    );
  }

  late final __objc_msgSend_92Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_92 = __objc_msgSend_92Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_URLHandleClassForURL_1 =
      _registerName1("URLHandleClassForURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_93(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anURL,
  ) {
    return __objc_msgSend_93(
      obj,
      sel,
      anURL,
    );
  }

  late final __objc_msgSend_93Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_93 = __objc_msgSend_93Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_status1 = _registerName1("status");
  int _objc_msgSend_94(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_94(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_94Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_94 = __objc_msgSend_94Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_failureReason1 = _registerName1("failureReason");
  late final _sel_addClient_1 = _registerName1("addClient:");
  late final _sel_removeClient_1 = _registerName1("removeClient:");
  late final _sel_loadInBackground1 = _registerName1("loadInBackground");
  late final _sel_cancelLoadInBackground1 =
      _registerName1("cancelLoadInBackground");
  late final _sel_resourceData1 = _registerName1("resourceData");
  late final _sel_availableResourceData1 =
      _registerName1("availableResourceData");
  late final _sel_expectedResourceDataSize1 =
      _registerName1("expectedResourceDataSize");
  late final _sel_flushCachedData1 = _registerName1("flushCachedData");
  late final _sel_backgroundLoadDidFailWithReason_1 =
      _registerName1("backgroundLoadDidFailWithReason:");
  late final _sel_didLoadBytes_loadComplete_1 =
      _registerName1("didLoadBytes:loadComplete:");
  void _objc_msgSend_95(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> newBytes,
    bool yorn,
  ) {
    return __objc_msgSend_95(
      obj,
      sel,
      newBytes,
      yorn,
    );
  }

  late final __objc_msgSend_95Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_95 = __objc_msgSend_95Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_canInitWithURL_1 = _registerName1("canInitWithURL:");
  bool _objc_msgSend_96(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anURL,
  ) {
    return __objc_msgSend_96(
      obj,
      sel,
      anURL,
    );
  }

  late final __objc_msgSend_96Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_96 = __objc_msgSend_96Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_cachedHandleForURL_1 = _registerName1("cachedHandleForURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_97(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anURL,
  ) {
    return __objc_msgSend_97(
      obj,
      sel,
      anURL,
    );
  }

  late final __objc_msgSend_97Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_97 = __objc_msgSend_97Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithURL_cached_1 = _registerName1("initWithURL:cached:");
  ffi.Pointer<ObjCObject> _objc_msgSend_98(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anURL,
    bool willCache,
  ) {
    return __objc_msgSend_98(
      obj,
      sel,
      anURL,
      willCache,
    );
  }

  late final __objc_msgSend_98Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_98 = __objc_msgSend_98Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_propertyForKeyIfAvailable_1 =
      _registerName1("propertyForKeyIfAvailable:");
  late final _sel_writeProperty_forKey_1 =
      _registerName1("writeProperty:forKey:");
  late final _sel_writeData_1 = _registerName1("writeData:");
  late final _sel_loadInForeground1 = _registerName1("loadInForeground");
  late final _sel_beginLoadInBackground1 =
      _registerName1("beginLoadInBackground");
  late final _sel_endLoadInBackground1 = _registerName1("endLoadInBackground");
  late final _sel_URLHandleUsingCache_1 =
      _registerName1("URLHandleUsingCache:");
  ffi.Pointer<ObjCObject> _objc_msgSend_99(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    bool shouldUseCache,
  ) {
    return __objc_msgSend_99(
      obj,
      sel,
      shouldUseCache,
    );
  }

  late final __objc_msgSend_99Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_99 = __objc_msgSend_99Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, bool)>();

  late final _sel_URL_resourceDataDidBecomeAvailable_1 =
      _registerName1("URL:resourceDataDidBecomeAvailable:");
  void _objc_msgSend_100(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> sender,
    ffi.Pointer<ObjCObject> newBytes,
  ) {
    return __objc_msgSend_100(
      obj,
      sel,
      sender,
      newBytes,
    );
  }

  late final __objc_msgSend_100Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_100 = __objc_msgSend_100Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_URLResourceDidFinishLoading_1 =
      _registerName1("URLResourceDidFinishLoading:");
  void _objc_msgSend_101(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> sender,
  ) {
    return __objc_msgSend_101(
      obj,
      sel,
      sender,
    );
  }

  late final __objc_msgSend_101Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_101 = __objc_msgSend_101Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_URLResourceDidCancelLoading_1 =
      _registerName1("URLResourceDidCancelLoading:");
  late final _sel_URL_resourceDidFailLoadingWithReason_1 =
      _registerName1("URL:resourceDidFailLoadingWithReason:");
  void _objc_msgSend_102(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> sender,
    ffi.Pointer<ObjCObject> reason,
  ) {
    return __objc_msgSend_102(
      obj,
      sel,
      sender,
      reason,
    );
  }

  late final __objc_msgSend_102Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_102 = __objc_msgSend_102Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo_1 =
      _registerName1(
          "attemptRecoveryFromError:optionIndex:delegate:didRecoverSelector:contextInfo:");
  void _objc_msgSend_103(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> error,
    int recoveryOptionIndex,
    ffi.Pointer<ObjCObject> delegate,
    ffi.Pointer<ObjCSel> didRecoverSelector,
    ffi.Pointer<ffi.Void> contextInfo,
  ) {
    return __objc_msgSend_103(
      obj,
      sel,
      error,
      recoveryOptionIndex,
      delegate,
      didRecoverSelector,
      contextInfo,
    );
  }

  late final __objc_msgSend_103Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.UnsignedLong,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>)>>('objc_msgSend');
  late final __objc_msgSend_103 = __objc_msgSend_103Ptr.asFunction<
      void Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>)>();

  late final _sel_attemptRecoveryFromError_optionIndex_1 =
      _registerName1("attemptRecoveryFromError:optionIndex:");
  bool _objc_msgSend_104(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> error,
    int recoveryOptionIndex,
  ) {
    return __objc_msgSend_104(
      obj,
      sel,
      error,
      recoveryOptionIndex,
    );
  }

  late final __objc_msgSend_104Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_104 = __objc_msgSend_104Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  late final _sel_length1 = _registerName1("length");
  late final _sel_characterAtIndex_1 = _registerName1("characterAtIndex:");
  int _objc_msgSend_105(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int index,
  ) {
    return __objc_msgSend_105(
      obj,
      sel,
      index,
    );
  }

  late final __objc_msgSend_105Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedShort Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_105 = __objc_msgSend_105Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_substringFromIndex_1 = _registerName1("substringFromIndex:");
  ffi.Pointer<ObjCObject> _objc_msgSend_106(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int from,
  ) {
    return __objc_msgSend_106(
      obj,
      sel,
      from,
    );
  }

  late final __objc_msgSend_106Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_106 = __objc_msgSend_106Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_substringToIndex_1 = _registerName1("substringToIndex:");
  late final _sel_substringWithRange_1 = _registerName1("substringWithRange:");
  ffi.Pointer<ObjCObject> _objc_msgSend_107(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
  ) {
    return __objc_msgSend_107(
      obj,
      sel,
      range,
    );
  }

  late final __objc_msgSend_107Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_107 = __objc_msgSend_107Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange)>();

  late final _sel_getCharacters_range_1 =
      _registerName1("getCharacters:range:");
  void _objc_msgSend_108(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.UnsignedShort> buffer,
    NSRange range,
  ) {
    return __objc_msgSend_108(
      obj,
      sel,
      buffer,
      range,
    );
  }

  late final __objc_msgSend_108Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.UnsignedShort>, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_108 = __objc_msgSend_108Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.UnsignedShort>, NSRange)>();

  int _objc_msgSend_109(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> string,
  ) {
    return __objc_msgSend_109(
      obj,
      sel,
      string,
    );
  }

  late final __objc_msgSend_109Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_109 = __objc_msgSend_109Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_compare_options_1 = _registerName1("compare:options:");
  int _objc_msgSend_110(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> string,
    int mask,
  ) {
    return __objc_msgSend_110(
      obj,
      sel,
      string,
      mask,
    );
  }

  late final __objc_msgSend_110Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_110 = __objc_msgSend_110Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  late final _sel_compare_options_range_1 =
      _registerName1("compare:options:range:");
  int _objc_msgSend_111(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> string,
    int mask,
    NSRange rangeOfReceiverToCompare,
  ) {
    return __objc_msgSend_111(
      obj,
      sel,
      string,
      mask,
      rangeOfReceiverToCompare,
    );
  }

  late final __objc_msgSend_111Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Int32, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_111 = __objc_msgSend_111Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int, NSRange)>();

  late final _sel_compare_options_range_locale_1 =
      _registerName1("compare:options:range:locale:");
  int _objc_msgSend_112(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> string,
    int mask,
    NSRange rangeOfReceiverToCompare,
    ffi.Pointer<ObjCObject> locale,
  ) {
    return __objc_msgSend_112(
      obj,
      sel,
      string,
      mask,
      rangeOfReceiverToCompare,
      locale,
    );
  }

  late final __objc_msgSend_112Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              NSRange,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_112 = __objc_msgSend_112Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int, NSRange, ffi.Pointer<ObjCObject>)>();

  late final _sel_caseInsensitiveCompare_1 =
      _registerName1("caseInsensitiveCompare:");
  late final _sel_localizedCompare_1 = _registerName1("localizedCompare:");
  late final _sel_localizedCaseInsensitiveCompare_1 =
      _registerName1("localizedCaseInsensitiveCompare:");
  late final _sel_localizedStandardCompare_1 =
      _registerName1("localizedStandardCompare:");
  late final _sel_isEqualToString_1 = _registerName1("isEqualToString:");
  bool _objc_msgSend_113(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> aString,
  ) {
    return __objc_msgSend_113(
      obj,
      sel,
      aString,
    );
  }

  late final __objc_msgSend_113Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_113 = __objc_msgSend_113Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_hasPrefix_1 = _registerName1("hasPrefix:");
  late final _sel_hasSuffix_1 = _registerName1("hasSuffix:");
  late final _sel_commonPrefixWithString_options_1 =
      _registerName1("commonPrefixWithString:options:");
  ffi.Pointer<ObjCObject> _objc_msgSend_114(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> str,
    int mask,
  ) {
    return __objc_msgSend_114(
      obj,
      sel,
      str,
      mask,
    );
  }

  late final __objc_msgSend_114Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_114 = __objc_msgSend_114Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, int)>();

  late final _sel_containsString_1 = _registerName1("containsString:");
  late final _sel_localizedCaseInsensitiveContainsString_1 =
      _registerName1("localizedCaseInsensitiveContainsString:");
  late final _sel_localizedStandardContainsString_1 =
      _registerName1("localizedStandardContainsString:");
  late final _sel_localizedStandardRangeOfString_1 =
      _registerName1("localizedStandardRangeOfString:");
  NSRange _objc_msgSend_115(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> str,
  ) {
    return __objc_msgSend_115(
      obj,
      sel,
      str,
    );
  }

  late final __objc_msgSend_115Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_115 = __objc_msgSend_115Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  void _objc_msgSend_115_stret(
    ffi.Pointer<NSRange> stret,
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> str,
  ) {
    return __objc_msgSend_115_stret(
      stret,
      obj,
      sel,
      str,
    );
  }

  late final __objc_msgSend_115_stretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NSRange>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend_stret');
  late final __objc_msgSend_115_stret = __objc_msgSend_115_stretPtr.asFunction<
      void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_rangeOfString_1 = _registerName1("rangeOfString:");
  late final _sel_rangeOfString_options_1 =
      _registerName1("rangeOfString:options:");
  NSRange _objc_msgSend_116(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchString,
    int mask,
  ) {
    return __objc_msgSend_116(
      obj,
      sel,
      searchString,
      mask,
    );
  }

  late final __objc_msgSend_116Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_116 = __objc_msgSend_116Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  void _objc_msgSend_116_stret(
    ffi.Pointer<NSRange> stret,
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchString,
    int mask,
  ) {
    return __objc_msgSend_116_stret(
      stret,
      obj,
      sel,
      searchString,
      mask,
    );
  }

  late final __objc_msgSend_116_stretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NSRange>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32)>>('objc_msgSend_stret');
  late final __objc_msgSend_116_stret = __objc_msgSend_116_stretPtr.asFunction<
      void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, int)>();

  late final _sel_rangeOfString_options_range_1 =
      _registerName1("rangeOfString:options:range:");
  NSRange _objc_msgSend_117(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchString,
    int mask,
    NSRange rangeOfReceiverToSearch,
  ) {
    return __objc_msgSend_117(
      obj,
      sel,
      searchString,
      mask,
      rangeOfReceiverToSearch,
    );
  }

  late final __objc_msgSend_117Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Int32, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_117 = __objc_msgSend_117Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int, NSRange)>();

  void _objc_msgSend_117_stret(
    ffi.Pointer<NSRange> stret,
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchString,
    int mask,
    NSRange rangeOfReceiverToSearch,
  ) {
    return __objc_msgSend_117_stret(
      stret,
      obj,
      sel,
      searchString,
      mask,
      rangeOfReceiverToSearch,
    );
  }

  late final __objc_msgSend_117_stretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NSRange>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              NSRange)>>('objc_msgSend_stret');
  late final __objc_msgSend_117_stret = __objc_msgSend_117_stretPtr.asFunction<
      void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, int, NSRange)>();

  late final _class_NSLocale1 = _getClass1("NSLocale");
  late final _sel_rangeOfString_options_range_locale_1 =
      _registerName1("rangeOfString:options:range:locale:");
  NSRange _objc_msgSend_118(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchString,
    int mask,
    NSRange rangeOfReceiverToSearch,
    ffi.Pointer<ObjCObject> locale,
  ) {
    return __objc_msgSend_118(
      obj,
      sel,
      searchString,
      mask,
      rangeOfReceiverToSearch,
      locale,
    );
  }

  late final __objc_msgSend_118Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              NSRange,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_118 = __objc_msgSend_118Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int, NSRange, ffi.Pointer<ObjCObject>)>();

  void _objc_msgSend_118_stret(
    ffi.Pointer<NSRange> stret,
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchString,
    int mask,
    NSRange rangeOfReceiverToSearch,
    ffi.Pointer<ObjCObject> locale,
  ) {
    return __objc_msgSend_118_stret(
      stret,
      obj,
      sel,
      searchString,
      mask,
      rangeOfReceiverToSearch,
      locale,
    );
  }

  late final __objc_msgSend_118_stretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NSRange>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              NSRange,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend_stret');
  late final __objc_msgSend_118_stret = __objc_msgSend_118_stretPtr.asFunction<
      void Function(
          ffi.Pointer<NSRange>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          NSRange,
          ffi.Pointer<ObjCObject>)>();

  late final _class_NSCharacterSet1 = _getClass1("NSCharacterSet");
  late final _sel_controlCharacterSet1 = _registerName1("controlCharacterSet");
  ffi.Pointer<ObjCObject> _objc_msgSend_119(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_119(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_119Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_119 = __objc_msgSend_119Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_whitespaceCharacterSet1 =
      _registerName1("whitespaceCharacterSet");
  late final _sel_whitespaceAndNewlineCharacterSet1 =
      _registerName1("whitespaceAndNewlineCharacterSet");
  late final _sel_decimalDigitCharacterSet1 =
      _registerName1("decimalDigitCharacterSet");
  late final _sel_letterCharacterSet1 = _registerName1("letterCharacterSet");
  late final _sel_lowercaseLetterCharacterSet1 =
      _registerName1("lowercaseLetterCharacterSet");
  late final _sel_uppercaseLetterCharacterSet1 =
      _registerName1("uppercaseLetterCharacterSet");
  late final _sel_nonBaseCharacterSet1 = _registerName1("nonBaseCharacterSet");
  late final _sel_alphanumericCharacterSet1 =
      _registerName1("alphanumericCharacterSet");
  late final _sel_decomposableCharacterSet1 =
      _registerName1("decomposableCharacterSet");
  late final _sel_illegalCharacterSet1 = _registerName1("illegalCharacterSet");
  late final _sel_punctuationCharacterSet1 =
      _registerName1("punctuationCharacterSet");
  late final _sel_capitalizedLetterCharacterSet1 =
      _registerName1("capitalizedLetterCharacterSet");
  late final _sel_symbolCharacterSet1 = _registerName1("symbolCharacterSet");
  late final _sel_newlineCharacterSet1 = _registerName1("newlineCharacterSet");
  late final _sel_characterSetWithRange_1 =
      _registerName1("characterSetWithRange:");
  ffi.Pointer<ObjCObject> _objc_msgSend_120(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange aRange,
  ) {
    return __objc_msgSend_120(
      obj,
      sel,
      aRange,
    );
  }

  late final __objc_msgSend_120Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_120 = __objc_msgSend_120Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange)>();

  late final _sel_characterSetWithCharactersInString_1 =
      _registerName1("characterSetWithCharactersInString:");
  ffi.Pointer<ObjCObject> _objc_msgSend_121(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> aString,
  ) {
    return __objc_msgSend_121(
      obj,
      sel,
      aString,
    );
  }

  late final __objc_msgSend_121Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_121 = __objc_msgSend_121Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_characterSetWithBitmapRepresentation_1 =
      _registerName1("characterSetWithBitmapRepresentation:");
  ffi.Pointer<ObjCObject> _objc_msgSend_122(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
  ) {
    return __objc_msgSend_122(
      obj,
      sel,
      data,
    );
  }

  late final __objc_msgSend_122Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_122 = __objc_msgSend_122Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_characterSetWithContentsOfFile_1 =
      _registerName1("characterSetWithContentsOfFile:");
  ffi.Pointer<ObjCObject> _objc_msgSend_123(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> fName,
  ) {
    return __objc_msgSend_123(
      obj,
      sel,
      fName,
    );
  }

  late final __objc_msgSend_123Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_123 = __objc_msgSend_123Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  instancetype _objc_msgSend_124(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> coder,
  ) {
    return __objc_msgSend_124(
      obj,
      sel,
      coder,
    );
  }

  late final __objc_msgSend_124Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_124 = __objc_msgSend_124Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_characterIsMember_1 = _registerName1("characterIsMember:");
  bool _objc_msgSend_125(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int aCharacter,
  ) {
    return __objc_msgSend_125(
      obj,
      sel,
      aCharacter,
    );
  }

  late final __objc_msgSend_125Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.UnsignedShort)>>('objc_msgSend');
  late final __objc_msgSend_125 = __objc_msgSend_125Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_bitmapRepresentation1 =
      _registerName1("bitmapRepresentation");
  late final _sel_invertedSet1 = _registerName1("invertedSet");
  late final _sel_longCharacterIsMember_1 =
      _registerName1("longCharacterIsMember:");
  bool _objc_msgSend_126(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int theLongChar,
  ) {
    return __objc_msgSend_126(
      obj,
      sel,
      theLongChar,
    );
  }

  late final __objc_msgSend_126Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.UnsignedInt)>>('objc_msgSend');
  late final __objc_msgSend_126 = __objc_msgSend_126Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_isSupersetOfSet_1 = _registerName1("isSupersetOfSet:");
  bool _objc_msgSend_127(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> theOtherSet,
  ) {
    return __objc_msgSend_127(
      obj,
      sel,
      theOtherSet,
    );
  }

  late final __objc_msgSend_127Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_127 = __objc_msgSend_127Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_hasMemberInPlane_1 = _registerName1("hasMemberInPlane:");
  bool _objc_msgSend_128(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int thePlane,
  ) {
    return __objc_msgSend_128(
      obj,
      sel,
      thePlane,
    );
  }

  late final __objc_msgSend_128Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Uint8)>>('objc_msgSend');
  late final __objc_msgSend_128 = __objc_msgSend_128Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_URLUserAllowedCharacterSet1 =
      _registerName1("URLUserAllowedCharacterSet");
  late final _sel_URLPasswordAllowedCharacterSet1 =
      _registerName1("URLPasswordAllowedCharacterSet");
  late final _sel_URLHostAllowedCharacterSet1 =
      _registerName1("URLHostAllowedCharacterSet");
  late final _sel_URLPathAllowedCharacterSet1 =
      _registerName1("URLPathAllowedCharacterSet");
  late final _sel_URLQueryAllowedCharacterSet1 =
      _registerName1("URLQueryAllowedCharacterSet");
  late final _sel_URLFragmentAllowedCharacterSet1 =
      _registerName1("URLFragmentAllowedCharacterSet");
  late final _sel_rangeOfCharacterFromSet_1 =
      _registerName1("rangeOfCharacterFromSet:");
  NSRange _objc_msgSend_129(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchSet,
  ) {
    return __objc_msgSend_129(
      obj,
      sel,
      searchSet,
    );
  }

  late final __objc_msgSend_129Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_129 = __objc_msgSend_129Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  void _objc_msgSend_129_stret(
    ffi.Pointer<NSRange> stret,
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchSet,
  ) {
    return __objc_msgSend_129_stret(
      stret,
      obj,
      sel,
      searchSet,
    );
  }

  late final __objc_msgSend_129_stretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NSRange>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend_stret');
  late final __objc_msgSend_129_stret = __objc_msgSend_129_stretPtr.asFunction<
      void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_rangeOfCharacterFromSet_options_1 =
      _registerName1("rangeOfCharacterFromSet:options:");
  NSRange _objc_msgSend_130(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchSet,
    int mask,
  ) {
    return __objc_msgSend_130(
      obj,
      sel,
      searchSet,
      mask,
    );
  }

  late final __objc_msgSend_130Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_130 = __objc_msgSend_130Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  void _objc_msgSend_130_stret(
    ffi.Pointer<NSRange> stret,
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchSet,
    int mask,
  ) {
    return __objc_msgSend_130_stret(
      stret,
      obj,
      sel,
      searchSet,
      mask,
    );
  }

  late final __objc_msgSend_130_stretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NSRange>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32)>>('objc_msgSend_stret');
  late final __objc_msgSend_130_stret = __objc_msgSend_130_stretPtr.asFunction<
      void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, int)>();

  late final _sel_rangeOfCharacterFromSet_options_range_1 =
      _registerName1("rangeOfCharacterFromSet:options:range:");
  NSRange _objc_msgSend_131(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchSet,
    int mask,
    NSRange rangeOfReceiverToSearch,
  ) {
    return __objc_msgSend_131(
      obj,
      sel,
      searchSet,
      mask,
      rangeOfReceiverToSearch,
    );
  }

  late final __objc_msgSend_131Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Int32, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_131 = __objc_msgSend_131Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int, NSRange)>();

  void _objc_msgSend_131_stret(
    ffi.Pointer<NSRange> stret,
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> searchSet,
    int mask,
    NSRange rangeOfReceiverToSearch,
  ) {
    return __objc_msgSend_131_stret(
      stret,
      obj,
      sel,
      searchSet,
      mask,
      rangeOfReceiverToSearch,
    );
  }

  late final __objc_msgSend_131_stretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NSRange>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              NSRange)>>('objc_msgSend_stret');
  late final __objc_msgSend_131_stret = __objc_msgSend_131_stretPtr.asFunction<
      void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, int, NSRange)>();

  late final _sel_rangeOfComposedCharacterSequenceAtIndex_1 =
      _registerName1("rangeOfComposedCharacterSequenceAtIndex:");
  NSRange _objc_msgSend_132(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int index,
  ) {
    return __objc_msgSend_132(
      obj,
      sel,
      index,
    );
  }

  late final __objc_msgSend_132Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_132 = __objc_msgSend_132Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  void _objc_msgSend_132_stret(
    ffi.Pointer<NSRange> stret,
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int index,
  ) {
    return __objc_msgSend_132_stret(
      stret,
      obj,
      sel,
      index,
    );
  }

  late final __objc_msgSend_132_stretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLong)>>('objc_msgSend_stret');
  late final __objc_msgSend_132_stret = __objc_msgSend_132_stretPtr.asFunction<
      void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, int)>();

  late final _sel_rangeOfComposedCharacterSequencesForRange_1 =
      _registerName1("rangeOfComposedCharacterSequencesForRange:");
  NSRange _objc_msgSend_133(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
  ) {
    return __objc_msgSend_133(
      obj,
      sel,
      range,
    );
  }

  late final __objc_msgSend_133Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange)>>('objc_msgSend');
  late final __objc_msgSend_133 = __objc_msgSend_133Ptr.asFunction<
      NSRange Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange)>();

  void _objc_msgSend_133_stret(
    ffi.Pointer<NSRange> stret,
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
  ) {
    return __objc_msgSend_133_stret(
      stret,
      obj,
      sel,
      range,
    );
  }

  late final __objc_msgSend_133_stretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, NSRange)>>('objc_msgSend_stret');
  late final __objc_msgSend_133_stret = __objc_msgSend_133_stretPtr.asFunction<
      void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, NSRange)>();

  late final _sel_stringByAppendingString_1 =
      _registerName1("stringByAppendingString:");
  ffi.Pointer<ObjCObject> _objc_msgSend_134(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> aString,
  ) {
    return __objc_msgSend_134(
      obj,
      sel,
      aString,
    );
  }

  late final __objc_msgSend_134Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_134 = __objc_msgSend_134Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_stringByAppendingFormat_1 =
      _registerName1("stringByAppendingFormat:");
  late final _sel_uppercaseString1 = _registerName1("uppercaseString");
  late final _sel_lowercaseString1 = _registerName1("lowercaseString");
  late final _sel_capitalizedString1 = _registerName1("capitalizedString");
  late final _sel_localizedUppercaseString1 =
      _registerName1("localizedUppercaseString");
  late final _sel_localizedLowercaseString1 =
      _registerName1("localizedLowercaseString");
  late final _sel_localizedCapitalizedString1 =
      _registerName1("localizedCapitalizedString");
  late final _sel_uppercaseStringWithLocale_1 =
      _registerName1("uppercaseStringWithLocale:");
  ffi.Pointer<ObjCObject> _objc_msgSend_135(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> locale,
  ) {
    return __objc_msgSend_135(
      obj,
      sel,
      locale,
    );
  }

  late final __objc_msgSend_135Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_135 = __objc_msgSend_135Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_lowercaseStringWithLocale_1 =
      _registerName1("lowercaseStringWithLocale:");
  late final _sel_capitalizedStringWithLocale_1 =
      _registerName1("capitalizedStringWithLocale:");
  late final _sel_getLineStart_end_contentsEnd_forRange_1 =
      _registerName1("getLineStart:end:contentsEnd:forRange:");
  void _objc_msgSend_136(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.UnsignedLong> startPtr,
    ffi.Pointer<ffi.UnsignedLong> lineEndPtr,
    ffi.Pointer<ffi.UnsignedLong> contentsEndPtr,
    NSRange range,
  ) {
    return __objc_msgSend_136(
      obj,
      sel,
      startPtr,
      lineEndPtr,
      contentsEndPtr,
      range,
    );
  }

  late final __objc_msgSend_136Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Pointer<ffi.UnsignedLong>,
              NSRange)>>('objc_msgSend');
  late final __objc_msgSend_136 = __objc_msgSend_136Ptr.asFunction<
      void Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.Pointer<ffi.UnsignedLong>,
          NSRange)>();

  late final _sel_lineRangeForRange_1 = _registerName1("lineRangeForRange:");
  late final _sel_getParagraphStart_end_contentsEnd_forRange_1 =
      _registerName1("getParagraphStart:end:contentsEnd:forRange:");
  late final _sel_paragraphRangeForRange_1 =
      _registerName1("paragraphRangeForRange:");
  late final _sel_enumerateSubstringsInRange_options_usingBlock_1 =
      _registerName1("enumerateSubstringsInRange:options:usingBlock:");
  void _objc_msgSend_137(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    int opts,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_137(
      obj,
      sel,
      range,
      opts,
      block,
    );
  }

  late final __objc_msgSend_137Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange, ffi.Int32, ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_137 = __objc_msgSend_137Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange, int,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_enumerateLinesUsingBlock_1 =
      _registerName1("enumerateLinesUsingBlock:");
  void _objc_msgSend_138(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_138(
      obj,
      sel,
      block,
    );
  }

  late final __objc_msgSend_138Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_138 = __objc_msgSend_138Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_UTF8String1 = _registerName1("UTF8String");
  late final _sel_fastestEncoding1 = _registerName1("fastestEncoding");
  late final _sel_smallestEncoding1 = _registerName1("smallestEncoding");
  late final _sel_dataUsingEncoding_allowLossyConversion_1 =
      _registerName1("dataUsingEncoding:allowLossyConversion:");
  ffi.Pointer<ObjCObject> _objc_msgSend_139(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int encoding,
    bool lossy,
  ) {
    return __objc_msgSend_139(
      obj,
      sel,
      encoding,
      lossy,
    );
  }

  late final __objc_msgSend_139Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.UnsignedLong,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_139 = __objc_msgSend_139Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int, bool)>();

  late final _sel_dataUsingEncoding_1 = _registerName1("dataUsingEncoding:");
  ffi.Pointer<ObjCObject> _objc_msgSend_140(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int encoding,
  ) {
    return __objc_msgSend_140(
      obj,
      sel,
      encoding,
    );
  }

  late final __objc_msgSend_140Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_140 = __objc_msgSend_140Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_canBeConvertedToEncoding_1 =
      _registerName1("canBeConvertedToEncoding:");
  bool _objc_msgSend_141(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int encoding,
  ) {
    return __objc_msgSend_141(
      obj,
      sel,
      encoding,
    );
  }

  late final __objc_msgSend_141Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_141 = __objc_msgSend_141Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_cStringUsingEncoding_1 =
      _registerName1("cStringUsingEncoding:");
  ffi.Pointer<ffi.Char> _objc_msgSend_142(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int encoding,
  ) {
    return __objc_msgSend_142(
      obj,
      sel,
      encoding,
    );
  }

  late final __objc_msgSend_142Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_142 = __objc_msgSend_142Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_getCString_maxLength_encoding_1 =
      _registerName1("getCString:maxLength:encoding:");
  bool _objc_msgSend_143(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> buffer,
    int maxBufferCount,
    int encoding,
  ) {
    return __objc_msgSend_143(
      obj,
      sel,
      buffer,
      maxBufferCount,
      encoding,
    );
  }

  late final __objc_msgSend_143Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong,
              ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_143 = __objc_msgSend_143Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>, int, int)>();

  late final _sel_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_1 =
      _registerName1(
          "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:");
  bool _objc_msgSend_144(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> buffer,
    int maxBufferCount,
    ffi.Pointer<ffi.UnsignedLong> usedBufferCount,
    int encoding,
    int options,
    NSRange range,
    ffi.Pointer<NSRange> leftover,
  ) {
    return __objc_msgSend_144(
      obj,
      sel,
      buffer,
      maxBufferCount,
      usedBufferCount,
      encoding,
      options,
      range,
      leftover,
    );
  }

  late final __objc_msgSend_144Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.UnsignedLong,
              ffi.Int32,
              NSRange,
              ffi.Pointer<NSRange>)>>('objc_msgSend');
  late final __objc_msgSend_144 = __objc_msgSend_144Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.UnsignedLong>,
          int,
          int,
          NSRange,
          ffi.Pointer<NSRange>)>();

  late final _sel_maximumLengthOfBytesUsingEncoding_1 =
      _registerName1("maximumLengthOfBytesUsingEncoding:");
  int _objc_msgSend_145(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int enc,
  ) {
    return __objc_msgSend_145(
      obj,
      sel,
      enc,
    );
  }

  late final __objc_msgSend_145Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_145 = __objc_msgSend_145Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_lengthOfBytesUsingEncoding_1 =
      _registerName1("lengthOfBytesUsingEncoding:");
  late final _sel_availableStringEncodings1 =
      _registerName1("availableStringEncodings");
  ffi.Pointer<ffi.UnsignedLong> _objc_msgSend_146(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_146(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_146Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedLong> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_146 = __objc_msgSend_146Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedLong> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_localizedNameOfStringEncoding_1 =
      _registerName1("localizedNameOfStringEncoding:");
  late final _sel_defaultCStringEncoding1 =
      _registerName1("defaultCStringEncoding");
  late final _sel_decomposedStringWithCanonicalMapping1 =
      _registerName1("decomposedStringWithCanonicalMapping");
  late final _sel_precomposedStringWithCanonicalMapping1 =
      _registerName1("precomposedStringWithCanonicalMapping");
  late final _sel_decomposedStringWithCompatibilityMapping1 =
      _registerName1("decomposedStringWithCompatibilityMapping");
  late final _sel_precomposedStringWithCompatibilityMapping1 =
      _registerName1("precomposedStringWithCompatibilityMapping");
  late final _sel_componentsSeparatedByString_1 =
      _registerName1("componentsSeparatedByString:");
  late final _sel_componentsSeparatedByCharactersInSet_1 =
      _registerName1("componentsSeparatedByCharactersInSet:");
  ffi.Pointer<ObjCObject> _objc_msgSend_147(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> separator,
  ) {
    return __objc_msgSend_147(
      obj,
      sel,
      separator,
    );
  }

  late final __objc_msgSend_147Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_147 = __objc_msgSend_147Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_stringByTrimmingCharactersInSet_1 =
      _registerName1("stringByTrimmingCharactersInSet:");
  ffi.Pointer<ObjCObject> _objc_msgSend_148(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> set1,
  ) {
    return __objc_msgSend_148(
      obj,
      sel,
      set1,
    );
  }

  late final __objc_msgSend_148Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_148 = __objc_msgSend_148Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_stringByPaddingToLength_withString_startingAtIndex_1 =
      _registerName1("stringByPaddingToLength:withString:startingAtIndex:");
  ffi.Pointer<ObjCObject> _objc_msgSend_149(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int newLength,
    ffi.Pointer<ObjCObject> padString,
    int padIndex,
  ) {
    return __objc_msgSend_149(
      obj,
      sel,
      newLength,
      padString,
      padIndex,
    );
  }

  late final __objc_msgSend_149Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.UnsignedLong,
              ffi.Pointer<ObjCObject>,
              ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_149 = __objc_msgSend_149Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, int, ffi.Pointer<ObjCObject>, int)>();

  late final _sel_stringByFoldingWithOptions_locale_1 =
      _registerName1("stringByFoldingWithOptions:locale:");
  ffi.Pointer<ObjCObject> _objc_msgSend_150(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int options,
    ffi.Pointer<ObjCObject> locale,
  ) {
    return __objc_msgSend_150(
      obj,
      sel,
      options,
      locale,
    );
  }

  late final __objc_msgSend_150Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Int32,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_150 = __objc_msgSend_150Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, int, ffi.Pointer<ObjCObject>)>();

  late final _sel_stringByReplacingOccurrencesOfString_withString_options_range_1 =
      _registerName1(
          "stringByReplacingOccurrencesOfString:withString:options:range:");
  ffi.Pointer<ObjCObject> _objc_msgSend_151(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> target,
    ffi.Pointer<ObjCObject> replacement,
    int options,
    NSRange searchRange,
  ) {
    return __objc_msgSend_151(
      obj,
      sel,
      target,
      replacement,
      options,
      searchRange,
    );
  }

  late final __objc_msgSend_151Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              NSRange)>>('objc_msgSend');
  late final __objc_msgSend_151 = __objc_msgSend_151Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          int,
          NSRange)>();

  late final _sel_stringByReplacingOccurrencesOfString_withString_1 =
      _registerName1("stringByReplacingOccurrencesOfString:withString:");
  ffi.Pointer<ObjCObject> _objc_msgSend_152(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> target,
    ffi.Pointer<ObjCObject> replacement,
  ) {
    return __objc_msgSend_152(
      obj,
      sel,
      target,
      replacement,
    );
  }

  late final __objc_msgSend_152Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_152 = __objc_msgSend_152Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_stringByReplacingCharactersInRange_withString_1 =
      _registerName1("stringByReplacingCharactersInRange:withString:");
  ffi.Pointer<ObjCObject> _objc_msgSend_153(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    ffi.Pointer<ObjCObject> replacement,
  ) {
    return __objc_msgSend_153(
      obj,
      sel,
      range,
      replacement,
    );
  }

  late final __objc_msgSend_153Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              NSRange,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_153 = __objc_msgSend_153Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, NSRange, ffi.Pointer<ObjCObject>)>();

  late final _sel_stringByApplyingTransform_reverse_1 =
      _registerName1("stringByApplyingTransform:reverse:");
  ffi.Pointer<ObjCObject> _objc_msgSend_154(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> transform,
    bool reverse,
  ) {
    return __objc_msgSend_154(
      obj,
      sel,
      transform,
      reverse,
    );
  }

  late final __objc_msgSend_154Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_154 = __objc_msgSend_154Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_writeToURL_atomically_encoding_error_1 =
      _registerName1("writeToURL:atomically:encoding:error:");
  bool _objc_msgSend_155(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    bool useAuxiliaryFile,
    int enc,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_155(
      obj,
      sel,
      url,
      useAuxiliaryFile,
      enc,
      error,
    );
  }

  late final __objc_msgSend_155Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_155 = __objc_msgSend_155Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          bool,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_writeToFile_atomically_encoding_error_1 =
      _registerName1("writeToFile:atomically:encoding:error:");
  bool _objc_msgSend_156(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool useAuxiliaryFile,
    int enc,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_156(
      obj,
      sel,
      path,
      useAuxiliaryFile,
      enc,
      error,
    );
  }

  late final __objc_msgSend_156Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_156 = __objc_msgSend_156Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          bool,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_initWithCharactersNoCopy_length_freeWhenDone_1 =
      _registerName1("initWithCharactersNoCopy:length:freeWhenDone:");
  instancetype _objc_msgSend_157(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.UnsignedShort> characters,
    int length,
    bool freeBuffer,
  ) {
    return __objc_msgSend_157(
      obj,
      sel,
      characters,
      length,
      freeBuffer,
    );
  }

  late final __objc_msgSend_157Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.UnsignedLong,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_157 = __objc_msgSend_157Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.UnsignedShort>, int, bool)>();

  late final _sel_initWithCharactersNoCopy_length_deallocator_1 =
      _registerName1("initWithCharactersNoCopy:length:deallocator:");
  instancetype _objc_msgSend_158(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.UnsignedShort> chars,
    int len,
    ffi.Pointer<_ObjCBlock> deallocator,
  ) {
    return __objc_msgSend_158(
      obj,
      sel,
      chars,
      len,
      deallocator,
    );
  }

  late final __objc_msgSend_158Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.UnsignedLong,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_158 = __objc_msgSend_158Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.UnsignedShort>, int, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_initWithCharacters_length_1 =
      _registerName1("initWithCharacters:length:");
  instancetype _objc_msgSend_159(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.UnsignedShort> characters,
    int length,
  ) {
    return __objc_msgSend_159(
      obj,
      sel,
      characters,
      length,
    );
  }

  late final __objc_msgSend_159Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_159 = __objc_msgSend_159Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.UnsignedShort>, int)>();

  late final _sel_initWithUTF8String_1 = _registerName1("initWithUTF8String:");
  instancetype _objc_msgSend_160(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> nullTerminatedCString,
  ) {
    return __objc_msgSend_160(
      obj,
      sel,
      nullTerminatedCString,
    );
  }

  late final __objc_msgSend_160Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>)>>('objc_msgSend');
  late final __objc_msgSend_160 = __objc_msgSend_160Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>)>();

  late final _sel_initWithFormat_1 = _registerName1("initWithFormat:");
  late final _sel_initWithFormat_arguments_1 =
      _registerName1("initWithFormat:arguments:");
  instancetype _objc_msgSend_161(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> format,
    ffi.Pointer<ffi.Char> argList,
  ) {
    return __objc_msgSend_161(
      obj,
      sel,
      format,
      argList,
    );
  }

  late final __objc_msgSend_161Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Char>)>>('objc_msgSend');
  late final __objc_msgSend_161 = __objc_msgSend_161Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Char>)>();

  late final _sel_initWithFormat_locale_1 =
      _registerName1("initWithFormat:locale:");
  instancetype _objc_msgSend_162(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> format,
    ffi.Pointer<ObjCObject> locale,
  ) {
    return __objc_msgSend_162(
      obj,
      sel,
      format,
      locale,
    );
  }

  late final __objc_msgSend_162Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_162 = __objc_msgSend_162Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithFormat_locale_arguments_1 =
      _registerName1("initWithFormat:locale:arguments:");
  instancetype _objc_msgSend_163(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> format,
    ffi.Pointer<ObjCObject> locale,
    ffi.Pointer<ffi.Char> argList,
  ) {
    return __objc_msgSend_163(
      obj,
      sel,
      format,
      locale,
      argList,
    );
  }

  late final __objc_msgSend_163Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Char>)>>('objc_msgSend');
  late final __objc_msgSend_163 = __objc_msgSend_163Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Char>)>();

  late final _sel_initWithValidatedFormat_validFormatSpecifiers_error_1 =
      _registerName1("initWithValidatedFormat:validFormatSpecifiers:error:");
  instancetype _objc_msgSend_164(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> format,
    ffi.Pointer<ObjCObject> validFormatSpecifiers,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_164(
      obj,
      sel,
      format,
      validFormatSpecifiers,
      error,
    );
  }

  late final __objc_msgSend_164Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_164 = __objc_msgSend_164Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_initWithValidatedFormat_validFormatSpecifiers_locale_error_1 =
      _registerName1(
          "initWithValidatedFormat:validFormatSpecifiers:locale:error:");
  instancetype _objc_msgSend_165(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> format,
    ffi.Pointer<ObjCObject> validFormatSpecifiers,
    ffi.Pointer<ObjCObject> locale,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_165(
      obj,
      sel,
      format,
      validFormatSpecifiers,
      locale,
      error,
    );
  }

  late final __objc_msgSend_165Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_165 = __objc_msgSend_165Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_initWithValidatedFormat_validFormatSpecifiers_arguments_error_1 =
      _registerName1(
          "initWithValidatedFormat:validFormatSpecifiers:arguments:error:");
  instancetype _objc_msgSend_166(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> format,
    ffi.Pointer<ObjCObject> validFormatSpecifiers,
    ffi.Pointer<ffi.Char> argList,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_166(
      obj,
      sel,
      format,
      validFormatSpecifiers,
      argList,
      error,
    );
  }

  late final __objc_msgSend_166Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_166 = __objc_msgSend_166Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_initWithValidatedFormat_validFormatSpecifiers_locale_arguments_error_1 =
      _registerName1(
          "initWithValidatedFormat:validFormatSpecifiers:locale:arguments:error:");
  instancetype _objc_msgSend_167(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> format,
    ffi.Pointer<ObjCObject> validFormatSpecifiers,
    ffi.Pointer<ObjCObject> locale,
    ffi.Pointer<ffi.Char> argList,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_167(
      obj,
      sel,
      format,
      validFormatSpecifiers,
      locale,
      argList,
      error,
    );
  }

  late final __objc_msgSend_167Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_167 = __objc_msgSend_167Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_initWithData_encoding_1 =
      _registerName1("initWithData:encoding:");
  instancetype _objc_msgSend_168(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
    int encoding,
  ) {
    return __objc_msgSend_168(
      obj,
      sel,
      data,
      encoding,
    );
  }

  late final __objc_msgSend_168Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_168 = __objc_msgSend_168Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  late final _sel_initWithBytes_length_encoding_1 =
      _registerName1("initWithBytes:length:encoding:");
  instancetype _objc_msgSend_169(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> bytes,
    int len,
    int encoding,
  ) {
    return __objc_msgSend_169(
      obj,
      sel,
      bytes,
      len,
      encoding,
    );
  }

  late final __objc_msgSend_169Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_169 = __objc_msgSend_169Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, int, int)>();

  late final _sel_initWithBytesNoCopy_length_encoding_freeWhenDone_1 =
      _registerName1("initWithBytesNoCopy:length:encoding:freeWhenDone:");
  instancetype _objc_msgSend_170(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> bytes,
    int len,
    int encoding,
    bool freeBuffer,
  ) {
    return __objc_msgSend_170(
      obj,
      sel,
      bytes,
      len,
      encoding,
      freeBuffer,
    );
  }

  late final __objc_msgSend_170Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_170 = __objc_msgSend_170Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, int, int, bool)>();

  late final _sel_initWithBytesNoCopy_length_encoding_deallocator_1 =
      _registerName1("initWithBytesNoCopy:length:encoding:deallocator:");
  instancetype _objc_msgSend_171(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> bytes,
    int len,
    int encoding,
    ffi.Pointer<_ObjCBlock> deallocator,
  ) {
    return __objc_msgSend_171(
      obj,
      sel,
      bytes,
      len,
      encoding,
      deallocator,
    );
  }

  late final __objc_msgSend_171Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_171 = __objc_msgSend_171Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_string1 = _registerName1("string");
  late final _sel_stringWithString_1 = _registerName1("stringWithString:");
  late final _sel_stringWithCharacters_length_1 =
      _registerName1("stringWithCharacters:length:");
  late final _sel_stringWithUTF8String_1 =
      _registerName1("stringWithUTF8String:");
  late final _sel_stringWithFormat_1 = _registerName1("stringWithFormat:");
  late final _sel_localizedStringWithFormat_1 =
      _registerName1("localizedStringWithFormat:");
  late final _sel_stringWithValidatedFormat_validFormatSpecifiers_error_1 =
      _registerName1("stringWithValidatedFormat:validFormatSpecifiers:error:");
  late final _sel_localizedStringWithValidatedFormat_validFormatSpecifiers_error_1 =
      _registerName1(
          "localizedStringWithValidatedFormat:validFormatSpecifiers:error:");
  late final _sel_initWithCString_encoding_1 =
      _registerName1("initWithCString:encoding:");
  instancetype _objc_msgSend_172(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> nullTerminatedCString,
    int encoding,
  ) {
    return __objc_msgSend_172(
      obj,
      sel,
      nullTerminatedCString,
      encoding,
    );
  }

  late final __objc_msgSend_172Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_172 = __objc_msgSend_172Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>, int)>();

  late final _sel_stringWithCString_encoding_1 =
      _registerName1("stringWithCString:encoding:");
  late final _sel_initWithContentsOfURL_encoding_error_1 =
      _registerName1("initWithContentsOfURL:encoding:error:");
  instancetype _objc_msgSend_173(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    int enc,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_173(
      obj,
      sel,
      url,
      enc,
      error,
    );
  }

  late final __objc_msgSend_173Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_173 = __objc_msgSend_173Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_initWithContentsOfFile_encoding_error_1 =
      _registerName1("initWithContentsOfFile:encoding:error:");
  instancetype _objc_msgSend_174(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    int enc,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_174(
      obj,
      sel,
      path,
      enc,
      error,
    );
  }

  late final __objc_msgSend_174Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_174 = __objc_msgSend_174Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_stringWithContentsOfURL_encoding_error_1 =
      _registerName1("stringWithContentsOfURL:encoding:error:");
  late final _sel_stringWithContentsOfFile_encoding_error_1 =
      _registerName1("stringWithContentsOfFile:encoding:error:");
  late final _sel_initWithContentsOfURL_usedEncoding_error_1 =
      _registerName1("initWithContentsOfURL:usedEncoding:error:");
  instancetype _objc_msgSend_175(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    ffi.Pointer<ffi.UnsignedLong> enc,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_175(
      obj,
      sel,
      url,
      enc,
      error,
    );
  }

  late final __objc_msgSend_175Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_175 = __objc_msgSend_175Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_initWithContentsOfFile_usedEncoding_error_1 =
      _registerName1("initWithContentsOfFile:usedEncoding:error:");
  instancetype _objc_msgSend_176(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    ffi.Pointer<ffi.UnsignedLong> enc,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_176(
      obj,
      sel,
      path,
      enc,
      error,
    );
  }

  late final __objc_msgSend_176Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_176 = __objc_msgSend_176Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_stringWithContentsOfURL_usedEncoding_error_1 =
      _registerName1("stringWithContentsOfURL:usedEncoding:error:");
  late final _sel_stringWithContentsOfFile_usedEncoding_error_1 =
      _registerName1("stringWithContentsOfFile:usedEncoding:error:");
  late final _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_1 =
      _registerName1(
          "stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:");
  int _objc_msgSend_177(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
    ffi.Pointer<ObjCObject> opts,
    ffi.Pointer<ffi.Pointer<ObjCObject>> string,
    ffi.Pointer<ffi.Bool> usedLossyConversion,
  ) {
    return __objc_msgSend_177(
      obj,
      sel,
      data,
      opts,
      string,
      usedLossyConversion,
    );
  }

  late final __objc_msgSend_177Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>,
              ffi.Pointer<ffi.Bool>)>>('objc_msgSend');
  late final __objc_msgSend_177 = __objc_msgSend_177Ptr.asFunction<
      int Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>,
          ffi.Pointer<ffi.Bool>)>();

  late final _sel_propertyList1 = _registerName1("propertyList");
  late final _sel_propertyListFromStringsFileFormat1 =
      _registerName1("propertyListFromStringsFileFormat");
  ffi.Pointer<ObjCObject> _objc_msgSend_178(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_178(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_178Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_178 = __objc_msgSend_178Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_cString1 = _registerName1("cString");
  late final _sel_lossyCString1 = _registerName1("lossyCString");
  late final _sel_cStringLength1 = _registerName1("cStringLength");
  late final _sel_getCString_1 = _registerName1("getCString:");
  void _objc_msgSend_179(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> bytes,
  ) {
    return __objc_msgSend_179(
      obj,
      sel,
      bytes,
    );
  }

  late final __objc_msgSend_179Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>)>>('objc_msgSend');
  late final __objc_msgSend_179 = __objc_msgSend_179Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>)>();

  late final _sel_getCString_maxLength_1 =
      _registerName1("getCString:maxLength:");
  void _objc_msgSend_180(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> bytes,
    int maxLength,
  ) {
    return __objc_msgSend_180(
      obj,
      sel,
      bytes,
      maxLength,
    );
  }

  late final __objc_msgSend_180Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_180 = __objc_msgSend_180Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>, int)>();

  late final _sel_getCString_maxLength_range_remainingRange_1 =
      _registerName1("getCString:maxLength:range:remainingRange:");
  void _objc_msgSend_181(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> bytes,
    int maxLength,
    NSRange aRange,
    ffi.Pointer<NSRange> leftoverRange,
  ) {
    return __objc_msgSend_181(
      obj,
      sel,
      bytes,
      maxLength,
      aRange,
      leftoverRange,
    );
  }

  late final __objc_msgSend_181Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong,
              NSRange,
              ffi.Pointer<NSRange>)>>('objc_msgSend');
  late final __objc_msgSend_181 = __objc_msgSend_181Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>, int, NSRange, ffi.Pointer<NSRange>)>();

  late final _sel_writeToFile_atomically_1 =
      _registerName1("writeToFile:atomically:");
  bool _objc_msgSend_182(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool useAuxiliaryFile,
  ) {
    return __objc_msgSend_182(
      obj,
      sel,
      path,
      useAuxiliaryFile,
    );
  }

  late final __objc_msgSend_182Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_182 = __objc_msgSend_182Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_writeToURL_atomically_1 =
      _registerName1("writeToURL:atomically:");
  bool _objc_msgSend_183(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    bool atomically,
  ) {
    return __objc_msgSend_183(
      obj,
      sel,
      url,
      atomically,
    );
  }

  late final __objc_msgSend_183Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_183 = __objc_msgSend_183Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_initWithContentsOfFile_1 =
      _registerName1("initWithContentsOfFile:");
  late final _sel_initWithContentsOfURL_1 =
      _registerName1("initWithContentsOfURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_184(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
  ) {
    return __objc_msgSend_184(
      obj,
      sel,
      url,
    );
  }

  late final __objc_msgSend_184Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_184 = __objc_msgSend_184Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_stringWithContentsOfFile_1 =
      _registerName1("stringWithContentsOfFile:");
  late final _sel_stringWithContentsOfURL_1 =
      _registerName1("stringWithContentsOfURL:");
  late final _sel_initWithCStringNoCopy_length_freeWhenDone_1 =
      _registerName1("initWithCStringNoCopy:length:freeWhenDone:");
  ffi.Pointer<ObjCObject> _objc_msgSend_185(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> bytes,
    int length,
    bool freeBuffer,
  ) {
    return __objc_msgSend_185(
      obj,
      sel,
      bytes,
      length,
      freeBuffer,
    );
  }

  late final __objc_msgSend_185Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_185 = __objc_msgSend_185Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ffi.Char>, int, bool)>();

  late final _sel_initWithCString_length_1 =
      _registerName1("initWithCString:length:");
  late final _sel_initWithCString_1 = _registerName1("initWithCString:");
  late final _sel_stringWithCString_length_1 =
      _registerName1("stringWithCString:length:");
  late final _sel_stringWithCString_1 = _registerName1("stringWithCString:");
  late final _sel_getCharacters_1 = _registerName1("getCharacters:");
  void _objc_msgSend_186(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.UnsignedShort> buffer,
  ) {
    return __objc_msgSend_186(
      obj,
      sel,
      buffer,
    );
  }

  late final __objc_msgSend_186Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.UnsignedShort>)>>('objc_msgSend');
  late final __objc_msgSend_186 = __objc_msgSend_186Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.UnsignedShort>)>();

  late final _sel_stringByAddingPercentEncodingWithAllowedCharacters_1 =
      _registerName1("stringByAddingPercentEncodingWithAllowedCharacters:");
  ffi.Pointer<ObjCObject> _objc_msgSend_187(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> allowedCharacters,
  ) {
    return __objc_msgSend_187(
      obj,
      sel,
      allowedCharacters,
    );
  }

  late final __objc_msgSend_187Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_187 = __objc_msgSend_187Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_stringByRemovingPercentEncoding1 =
      _registerName1("stringByRemovingPercentEncoding");
  late final _sel_stringByAddingPercentEscapesUsingEncoding_1 =
      _registerName1("stringByAddingPercentEscapesUsingEncoding:");
  ffi.Pointer<ObjCObject> _objc_msgSend_188(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int enc,
  ) {
    return __objc_msgSend_188(
      obj,
      sel,
      enc,
    );
  }

  late final __objc_msgSend_188Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_188 = __objc_msgSend_188Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_stringByReplacingPercentEscapesUsingEncoding_1 =
      _registerName1("stringByReplacingPercentEscapesUsingEncoding:");
  late final _class_NSMutableString1 = _getClass1("NSMutableString");
  late final _sel_replaceCharactersInRange_withString_1 =
      _registerName1("replaceCharactersInRange:withString:");
  void _objc_msgSend_189(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    ffi.Pointer<ObjCObject> aString,
  ) {
    return __objc_msgSend_189(
      obj,
      sel,
      range,
      aString,
    );
  }

  late final __objc_msgSend_189Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_189 = __objc_msgSend_189Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_insertString_atIndex_1 =
      _registerName1("insertString:atIndex:");
  void _objc_msgSend_190(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> aString,
    int loc,
  ) {
    return __objc_msgSend_190(
      obj,
      sel,
      aString,
      loc,
    );
  }

  late final __objc_msgSend_190Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_190 = __objc_msgSend_190Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  late final _sel_deleteCharactersInRange_1 =
      _registerName1("deleteCharactersInRange:");
  void _objc_msgSend_191(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
  ) {
    return __objc_msgSend_191(
      obj,
      sel,
      range,
    );
  }

  late final __objc_msgSend_191Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange)>>('objc_msgSend');
  late final __objc_msgSend_191 = __objc_msgSend_191Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange)>();

  late final _sel_appendString_1 = _registerName1("appendString:");
  late final _sel_appendFormat_1 = _registerName1("appendFormat:");
  late final _sel_setString_1 = _registerName1("setString:");
  late final _sel_replaceOccurrencesOfString_withString_options_range_1 =
      _registerName1("replaceOccurrencesOfString:withString:options:range:");
  int _objc_msgSend_192(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> target,
    ffi.Pointer<ObjCObject> replacement,
    int options,
    NSRange searchRange,
  ) {
    return __objc_msgSend_192(
      obj,
      sel,
      target,
      replacement,
      options,
      searchRange,
    );
  }

  late final __objc_msgSend_192Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              NSRange)>>('objc_msgSend');
  late final __objc_msgSend_192 = __objc_msgSend_192Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>, int, NSRange)>();

  late final _sel_applyTransform_reverse_range_updatedRange_1 =
      _registerName1("applyTransform:reverse:range:updatedRange:");
  bool _objc_msgSend_193(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> transform,
    bool reverse,
    NSRange range,
    ffi.Pointer<NSRange> resultingRange,
  ) {
    return __objc_msgSend_193(
      obj,
      sel,
      transform,
      reverse,
      range,
      resultingRange,
    );
  }

  late final __objc_msgSend_193Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool,
              NSRange,
              ffi.Pointer<NSRange>)>>('objc_msgSend');
  late final __objc_msgSend_193 = __objc_msgSend_193Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool, NSRange, ffi.Pointer<NSRange>)>();

  late final _sel_initWithCapacity_1 = _registerName1("initWithCapacity:");
  ffi.Pointer<ObjCObject> _objc_msgSend_194(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int capacity,
  ) {
    return __objc_msgSend_194(
      obj,
      sel,
      capacity,
    );
  }

  late final __objc_msgSend_194Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_194 = __objc_msgSend_194Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_stringWithCapacity_1 = _registerName1("stringWithCapacity:");
  late final _class_NSSimpleCString1 = _getClass1("NSSimpleCString");
  late final _class_NSConstantString1 = _getClass1("NSConstantString");
  late final _class_NSURLQueryItem1 = _getClass1("NSURLQueryItem");
  late final _sel_initWithName_value_1 = _registerName1("initWithName:value:");
  instancetype _objc_msgSend_195(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> name,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_195(
      obj,
      sel,
      name,
      value,
    );
  }

  late final __objc_msgSend_195Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_195 = __objc_msgSend_195Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_queryItemWithName_value_1 =
      _registerName1("queryItemWithName:value:");
  late final _sel_name1 = _registerName1("name");
  late final _sel_value1 = _registerName1("value");
  late final _class_NSURLComponents1 = _getClass1("NSURLComponents");
  late final _sel_initWithURL_resolvingAgainstBaseURL_1 =
      _registerName1("initWithURL:resolvingAgainstBaseURL:");
  instancetype _objc_msgSend_196(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    bool resolve,
  ) {
    return __objc_msgSend_196(
      obj,
      sel,
      url,
      resolve,
    );
  }

  late final __objc_msgSend_196Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_196 = __objc_msgSend_196Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_componentsWithURL_resolvingAgainstBaseURL_1 =
      _registerName1("componentsWithURL:resolvingAgainstBaseURL:");
  late final _sel_componentsWithString_1 =
      _registerName1("componentsWithString:");
  late final _sel_componentsWithString_encodingInvalidCharacters_1 =
      _registerName1("componentsWithString:encodingInvalidCharacters:");
  late final _sel_URL1 = _registerName1("URL");
  late final _sel_URLRelativeToURL_1 = _registerName1("URLRelativeToURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_197(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_197(
      obj,
      sel,
      baseURL,
    );
  }

  late final __objc_msgSend_197Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_197 = __objc_msgSend_197Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_setScheme_1 = _registerName1("setScheme:");
  void _objc_msgSend_198(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_198(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_198Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_198 = __objc_msgSend_198Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_setUser_1 = _registerName1("setUser:");
  late final _sel_setPassword_1 = _registerName1("setPassword:");
  late final _sel_setHost_1 = _registerName1("setHost:");
  late final _sel_setPort_1 = _registerName1("setPort:");
  void _objc_msgSend_199(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_199(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_199Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_199 = __objc_msgSend_199Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_setPath_1 = _registerName1("setPath:");
  late final _sel_setQuery_1 = _registerName1("setQuery:");
  late final _sel_setFragment_1 = _registerName1("setFragment:");
  late final _sel_percentEncodedUser1 = _registerName1("percentEncodedUser");
  late final _sel_setPercentEncodedUser_1 =
      _registerName1("setPercentEncodedUser:");
  late final _sel_percentEncodedPassword1 =
      _registerName1("percentEncodedPassword");
  late final _sel_setPercentEncodedPassword_1 =
      _registerName1("setPercentEncodedPassword:");
  late final _sel_percentEncodedHost1 = _registerName1("percentEncodedHost");
  late final _sel_setPercentEncodedHost_1 =
      _registerName1("setPercentEncodedHost:");
  late final _sel_percentEncodedPath1 = _registerName1("percentEncodedPath");
  late final _sel_setPercentEncodedPath_1 =
      _registerName1("setPercentEncodedPath:");
  late final _sel_percentEncodedQuery1 = _registerName1("percentEncodedQuery");
  late final _sel_setPercentEncodedQuery_1 =
      _registerName1("setPercentEncodedQuery:");
  late final _sel_percentEncodedFragment1 =
      _registerName1("percentEncodedFragment");
  late final _sel_setPercentEncodedFragment_1 =
      _registerName1("setPercentEncodedFragment:");
  late final _sel_encodedHost1 = _registerName1("encodedHost");
  late final _sel_setEncodedHost_1 = _registerName1("setEncodedHost:");
  late final _sel_rangeOfScheme1 = _registerName1("rangeOfScheme");
  NSRange _objc_msgSend_200(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_200(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_200Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_200 = __objc_msgSend_200Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  void _objc_msgSend_200_stret(
    ffi.Pointer<NSRange> stret,
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_200_stret(
      stret,
      obj,
      sel,
    );
  }

  late final __objc_msgSend_200_stretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend_stret');
  late final __objc_msgSend_200_stret = __objc_msgSend_200_stretPtr.asFunction<
      void Function(ffi.Pointer<NSRange>, ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>)>();

  late final _sel_rangeOfUser1 = _registerName1("rangeOfUser");
  late final _sel_rangeOfPassword1 = _registerName1("rangeOfPassword");
  late final _sel_rangeOfHost1 = _registerName1("rangeOfHost");
  late final _sel_rangeOfPort1 = _registerName1("rangeOfPort");
  late final _sel_rangeOfPath1 = _registerName1("rangeOfPath");
  late final _sel_rangeOfQuery1 = _registerName1("rangeOfQuery");
  late final _sel_rangeOfFragment1 = _registerName1("rangeOfFragment");
  late final _sel_queryItems1 = _registerName1("queryItems");
  late final _sel_setQueryItems_1 = _registerName1("setQueryItems:");
  void _objc_msgSend_201(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_201(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_201Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_201 = __objc_msgSend_201Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_percentEncodedQueryItems1 =
      _registerName1("percentEncodedQueryItems");
  late final _sel_setPercentEncodedQueryItems_1 =
      _registerName1("setPercentEncodedQueryItems:");
  late final _class_NSFileSecurity1 = _getClass1("NSFileSecurity");
}

class _ObjCWrapper implements ffi.Finalizable {
  final ffi.Pointer<ObjCObject> _id;
  final Foundation _lib;
  bool _pendingRelease;

  _ObjCWrapper._(this._id, this._lib,
      {bool retain = false, bool release = false})
      : _pendingRelease = release {
    if (retain) {
      _lib._objc_retain(_id.cast());
    }
    if (release) {
      _lib._objc_releaseFinalizer2.attach(this, _id.cast(), detach: this);
    }
  }

  /// Releases the reference to the underlying ObjC object held by this wrapper.
  /// Throws a StateError if this wrapper doesn't currently hold a reference.
  void release() {
    if (_pendingRelease) {
      _pendingRelease = false;
      _lib._objc_release(_id.cast());
      _lib._objc_releaseFinalizer2.detach(this);
    } else {
      throw StateError(
          'Released an ObjC object that was unowned or already released.');
    }
  }

  @override
  bool operator ==(Object other) {
    return other is _ObjCWrapper && _id == other._id;
  }

  @override
  int get hashCode => _id.hashCode;

  /// Return a pointer to this object.
  ffi.Pointer<ObjCObject> get pointer => _id;

  ffi.Pointer<ObjCObject> _retainAndReturnId() {
    _lib._objc_retain(_id.cast());
    return _id;
  }
}

class NSString extends NSObject {
  NSString._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSString] that points to the same underlying object as [other].
  static NSString castFrom<T extends _ObjCWrapper>(T other) {
    return NSString._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSString] that wraps the given raw object pointer.
  static NSString castFromPointer(Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSString._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSString].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSString1);
  }

  factory NSString(Foundation _lib, String str) {
    final cstr = str.toNativeUtf16();
    final nsstr = stringWithCharacters_length_(_lib, cstr.cast(), str.length);
    pkg_ffi.calloc.free(cstr);
    return nsstr;
  }

  @override
  String toString() {
    final data =
        dataUsingEncoding_(0x94000100 /* NSUTF16LittleEndianStringEncoding */);
    return data!.bytes.cast<pkg_ffi.Utf16>().toDartString(length: length);
  }

  /// NSString primitives. A minimal subclass of NSString just needs to implement these two, along with an init method appropriate for that subclass. We also recommend overriding getCharacters:range: for performance.
  int get length {
    return _lib._objc_msgSend_12(_id, _lib._sel_length1);
  }

  int characterAtIndex_(int index) {
    return _lib._objc_msgSend_105(_id, _lib._sel_characterAtIndex_1, index);
  }

  /// The initializers available to subclasses. See further below for additional init methods.
  @override
  NSString init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? initWithCoder_(NSCoder coder) {
    final _ret =
        _lib._objc_msgSend_37(_id, _lib._sel_initWithCoder_1, coder._id);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// To avoid breaking up character sequences such as Emoji, you can do:
  /// [str substringFromIndex:[str rangeOfComposedCharacterSequenceAtIndex:index].location]
  /// [str substringToIndex:NSMaxRange([str rangeOfComposedCharacterSequenceAtIndex:index])]
  /// [str substringWithRange:[str rangeOfComposedCharacterSequencesForRange:range]
  NSString substringFromIndex_(int from) {
    final _ret =
        _lib._objc_msgSend_106(_id, _lib._sel_substringFromIndex_1, from);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString substringToIndex_(int to) {
    final _ret = _lib._objc_msgSend_106(_id, _lib._sel_substringToIndex_1, to);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Use with rangeOfComposedCharacterSequencesForRange: to avoid breaking up character sequences
  NSString substringWithRange_(NSRange range) {
    final _ret =
        _lib._objc_msgSend_107(_id, _lib._sel_substringWithRange_1, range);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Use with rangeOfComposedCharacterSequencesForRange: to avoid breaking up character sequences
  void getCharacters_range_(
      ffi.Pointer<ffi.UnsignedShort> buffer, NSRange range) {
    _lib._objc_msgSend_108(_id, _lib._sel_getCharacters_range_1, buffer, range);
  }

  /// In the compare: methods, the range argument specifies the subrange, rather than the whole, of the receiver to use in the comparison. The range is not applied to the search string.  For example, [@"AB" compare:@"ABC" options:0 range:NSMakeRange(0,1)] compares "A" to "ABC", not "A" to "A", and will return NSOrderedAscending. It is an error to specify a range that is outside of the receiver's bounds, and an exception may be raised.
  int compare_(NSString string) {
    return _lib._objc_msgSend_109(_id, _lib._sel_compare_1, string._id);
  }

  int compare_options_(NSString string, int mask) {
    return _lib._objc_msgSend_110(
        _id, _lib._sel_compare_options_1, string._id, mask);
  }

  int compare_options_range_(
      NSString string, int mask, NSRange rangeOfReceiverToCompare) {
    return _lib._objc_msgSend_111(_id, _lib._sel_compare_options_range_1,
        string._id, mask, rangeOfReceiverToCompare);
  }

  /// locale arg used to be a dictionary pre-Leopard. We now accept NSLocale. Assumes the current locale if non-nil and non-NSLocale. nil continues to mean canonical compare, which doesn't depend on user's locale choice.
  int compare_options_range_locale_(NSString string, int mask,
      NSRange rangeOfReceiverToCompare, NSObject? locale) {
    return _lib._objc_msgSend_112(_id, _lib._sel_compare_options_range_locale_1,
        string._id, mask, rangeOfReceiverToCompare, locale?._id ?? ffi.nullptr);
  }

  int caseInsensitiveCompare_(NSString string) {
    return _lib._objc_msgSend_109(
        _id, _lib._sel_caseInsensitiveCompare_1, string._id);
  }

  int localizedCompare_(NSString string) {
    return _lib._objc_msgSend_109(
        _id, _lib._sel_localizedCompare_1, string._id);
  }

  int localizedCaseInsensitiveCompare_(NSString string) {
    return _lib._objc_msgSend_109(
        _id, _lib._sel_localizedCaseInsensitiveCompare_1, string._id);
  }

  /// localizedStandardCompare:, added in 10.6, should be used whenever file names or other strings are presented in lists and tables where Finder-like sorting is appropriate.  The exact behavior of this method may be tweaked in future releases, and will be different under different localizations, so clients should not depend on the exact sorting order of the strings.
  int localizedStandardCompare_(NSString string) {
    return _lib._objc_msgSend_109(
        _id, _lib._sel_localizedStandardCompare_1, string._id);
  }

  bool isEqualToString_(NSString aString) {
    return _lib._objc_msgSend_113(
        _id, _lib._sel_isEqualToString_1, aString._id);
  }

  /// These perform locale unaware prefix or suffix match. If you need locale awareness, use rangeOfString:options:range:locale:, passing NSAnchoredSearch (or'ed with NSBackwardsSearch for suffix, and NSCaseInsensitiveSearch|NSDiacriticInsensitiveSearch if needed) for options, NSMakeRange(0, [receiver length]) for range, and [NSLocale currentLocale] for locale.
  bool hasPrefix_(NSString str) {
    return _lib._objc_msgSend_113(_id, _lib._sel_hasPrefix_1, str._id);
  }

  bool hasSuffix_(NSString str) {
    return _lib._objc_msgSend_113(_id, _lib._sel_hasSuffix_1, str._id);
  }

  NSString commonPrefixWithString_options_(NSString str, int mask) {
    final _ret = _lib._objc_msgSend_114(
        _id, _lib._sel_commonPrefixWithString_options_1, str._id, mask);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Simple convenience methods for string searching. containsString: returns YES if the target string is contained within the receiver. Same as calling rangeOfString:options: with no options, thus doing a case-sensitive, locale-unaware search. localizedCaseInsensitiveContainsString: is the case-insensitive variant which also takes the current locale into effect. Starting in 10.11 and iOS9, the new localizedStandardRangeOfString: or localizedStandardContainsString: APIs are even better convenience methods for user level searching.   More sophisticated needs can be achieved by calling rangeOfString:options:range:locale: directly.
  bool containsString_(NSString str) {
    return _lib._objc_msgSend_113(_id, _lib._sel_containsString_1, str._id);
  }

  bool localizedCaseInsensitiveContainsString_(NSString str) {
    return _lib._objc_msgSend_113(
        _id, _lib._sel_localizedCaseInsensitiveContainsString_1, str._id);
  }

  /// The following two are the most appropriate methods for doing user-level string searches, similar to how searches are done generally in the system.  The search is locale-aware, case and diacritic insensitive. As with other APIs, "standard" in the name implies "system default behavior," so the exact list of search options applied may change over time.  If you need more control over the search options, please use the rangeOfString:options:range:locale: method. You can pass [NSLocale currentLocale] for searches in user's locale.
  bool localizedStandardContainsString_(NSString str) {
    return _lib._objc_msgSend_113(
        _id, _lib._sel_localizedStandardContainsString_1, str._id);
  }

  void localizedStandardRangeOfString_(
      ffi.Pointer<NSRange> stret, NSString str) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_115_stret(
            stret, _id, _lib._sel_localizedStandardRangeOfString_1, str._id)
        : stret.ref = _lib._objc_msgSend_115(
            _id, _lib._sel_localizedStandardRangeOfString_1, str._id);
  }

  /// These methods perform string search, looking for the searchString within the receiver string.  These return length==0 if the target string is not found. So, to check for containment: ([str rangeOfString:@"target"].length > 0).  Note that the length of the range returned by these methods might be different than the length of the target string, due composed characters and such.
  ///
  /// Note that the first three methods do not take locale arguments, and perform the search in a non-locale aware fashion, which is not appropriate for user-level searching. To do user-level string searching, use the last method, specifying locale:[NSLocale currentLocale], or better yet, use localizedStandardRangeOfString: or localizedStandardContainsString:.
  ///
  /// The range argument specifies the subrange, rather than the whole, of the receiver to use in the search.  It is an error to specify a range that is outside of the receiver's bounds, and an exception may be raised.
  void rangeOfString_(ffi.Pointer<NSRange> stret, NSString searchString) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_115_stret(
            stret, _id, _lib._sel_rangeOfString_1, searchString._id)
        : stret.ref = _lib._objc_msgSend_115(
            _id, _lib._sel_rangeOfString_1, searchString._id);
  }

  void rangeOfString_options_(
      ffi.Pointer<NSRange> stret, NSString searchString, int mask) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_116_stret(stret, _id,
            _lib._sel_rangeOfString_options_1, searchString._id, mask)
        : stret.ref = _lib._objc_msgSend_116(
            _id, _lib._sel_rangeOfString_options_1, searchString._id, mask);
  }

  void rangeOfString_options_range_(ffi.Pointer<NSRange> stret,
      NSString searchString, int mask, NSRange rangeOfReceiverToSearch) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_117_stret(
            stret,
            _id,
            _lib._sel_rangeOfString_options_range_1,
            searchString._id,
            mask,
            rangeOfReceiverToSearch)
        : stret.ref = _lib._objc_msgSend_117(
            _id,
            _lib._sel_rangeOfString_options_range_1,
            searchString._id,
            mask,
            rangeOfReceiverToSearch);
  }

  void rangeOfString_options_range_locale_(
      ffi.Pointer<NSRange> stret,
      NSString searchString,
      int mask,
      NSRange rangeOfReceiverToSearch,
      NSLocale? locale) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_118_stret(
            stret,
            _id,
            _lib._sel_rangeOfString_options_range_locale_1,
            searchString._id,
            mask,
            rangeOfReceiverToSearch,
            locale?._id ?? ffi.nullptr)
        : stret.ref = _lib._objc_msgSend_118(
            _id,
            _lib._sel_rangeOfString_options_range_locale_1,
            searchString._id,
            mask,
            rangeOfReceiverToSearch,
            locale?._id ?? ffi.nullptr);
  }

  /// These return the range of the first character from the set in the string, not the range of a sequence of characters.
  ///
  /// The range argument specifies the subrange, rather than the whole, of the receiver to use in the search.  It is an error to specify a range that is outside of the receiver's bounds, and an exception may be raised.
  void rangeOfCharacterFromSet_(
      ffi.Pointer<NSRange> stret, NSCharacterSet searchSet) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_129_stret(
            stret, _id, _lib._sel_rangeOfCharacterFromSet_1, searchSet._id)
        : stret.ref = _lib._objc_msgSend_129(
            _id, _lib._sel_rangeOfCharacterFromSet_1, searchSet._id);
  }

  void rangeOfCharacterFromSet_options_(
      ffi.Pointer<NSRange> stret, NSCharacterSet searchSet, int mask) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_130_stret(stret, _id,
            _lib._sel_rangeOfCharacterFromSet_options_1, searchSet._id, mask)
        : stret.ref = _lib._objc_msgSend_130(_id,
            _lib._sel_rangeOfCharacterFromSet_options_1, searchSet._id, mask);
  }

  void rangeOfCharacterFromSet_options_range_(ffi.Pointer<NSRange> stret,
      NSCharacterSet searchSet, int mask, NSRange rangeOfReceiverToSearch) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_131_stret(
            stret,
            _id,
            _lib._sel_rangeOfCharacterFromSet_options_range_1,
            searchSet._id,
            mask,
            rangeOfReceiverToSearch)
        : stret.ref = _lib._objc_msgSend_131(
            _id,
            _lib._sel_rangeOfCharacterFromSet_options_range_1,
            searchSet._id,
            mask,
            rangeOfReceiverToSearch);
  }

  void rangeOfComposedCharacterSequenceAtIndex_(
      ffi.Pointer<NSRange> stret, int index) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_132_stret(stret, _id,
            _lib._sel_rangeOfComposedCharacterSequenceAtIndex_1, index)
        : stret.ref = _lib._objc_msgSend_132(
            _id, _lib._sel_rangeOfComposedCharacterSequenceAtIndex_1, index);
  }

  void rangeOfComposedCharacterSequencesForRange_(
      ffi.Pointer<NSRange> stret, NSRange range) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_133_stret(stret, _id,
            _lib._sel_rangeOfComposedCharacterSequencesForRange_1, range)
        : stret.ref = _lib._objc_msgSend_133(
            _id, _lib._sel_rangeOfComposedCharacterSequencesForRange_1, range);
  }

  NSString stringByAppendingString_(NSString aString) {
    final _ret = _lib._objc_msgSend_134(
        _id, _lib._sel_stringByAppendingString_1, aString._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString stringByAppendingFormat_(NSString format) {
    final _ret = _lib._objc_msgSend_134(
        _id, _lib._sel_stringByAppendingFormat_1, format._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// The following convenience methods all skip initial space characters (whitespaceSet) and ignore trailing characters. They are not locale-aware. NSScanner or NSNumberFormatter can be used for more powerful and locale-aware parsing of numbers.
  double get doubleValue {
    return _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_61_fpret(_id, _lib._sel_doubleValue1)
        : _lib._objc_msgSend_61(_id, _lib._sel_doubleValue1);
  }

  double get floatValue {
    return _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_60_fpret(_id, _lib._sel_floatValue1)
        : _lib._objc_msgSend_60(_id, _lib._sel_floatValue1);
  }

  int get intValue {
    return _lib._objc_msgSend_55(_id, _lib._sel_intValue1);
  }

  int get integerValue {
    return _lib._objc_msgSend_57(_id, _lib._sel_integerValue1);
  }

  int get longLongValue {
    return _lib._objc_msgSend_58(_id, _lib._sel_longLongValue1);
  }

  /// Skips initial space characters (whitespaceSet), or optional -/+ sign followed by zeroes. Returns YES on encountering one of "Y", "y", "T", "t", or a digit 1-9. It ignores any trailing characters.
  bool get boolValue {
    return _lib._objc_msgSend_11(_id, _lib._sel_boolValue1);
  }

  /// The following three return the canonical (non-localized) mappings. They are suitable for programming operations that require stable results not depending on the user's locale preference.  For locale-aware case mapping for strings presented to users, use the "localized" methods below.
  NSString get uppercaseString {
    final _ret = _lib._objc_msgSend_13(_id, _lib._sel_uppercaseString1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString get lowercaseString {
    final _ret = _lib._objc_msgSend_13(_id, _lib._sel_lowercaseString1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString get capitalizedString {
    final _ret = _lib._objc_msgSend_13(_id, _lib._sel_capitalizedString1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// The following three return the locale-aware case mappings. They are suitable for strings presented to the user.
  NSString get localizedUppercaseString {
    final _ret =
        _lib._objc_msgSend_13(_id, _lib._sel_localizedUppercaseString1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString get localizedLowercaseString {
    final _ret =
        _lib._objc_msgSend_13(_id, _lib._sel_localizedLowercaseString1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString get localizedCapitalizedString {
    final _ret =
        _lib._objc_msgSend_13(_id, _lib._sel_localizedCapitalizedString1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// The following methods perform localized case mappings based on the locale specified. Passing nil indicates the canonical mapping.  For the user preference locale setting, specify +[NSLocale currentLocale].
  NSString uppercaseStringWithLocale_(NSLocale? locale) {
    final _ret = _lib._objc_msgSend_135(
        _id, _lib._sel_uppercaseStringWithLocale_1, locale?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString lowercaseStringWithLocale_(NSLocale? locale) {
    final _ret = _lib._objc_msgSend_135(
        _id, _lib._sel_lowercaseStringWithLocale_1, locale?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString capitalizedStringWithLocale_(NSLocale? locale) {
    final _ret = _lib._objc_msgSend_135(_id,
        _lib._sel_capitalizedStringWithLocale_1, locale?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  void getLineStart_end_contentsEnd_forRange_(
      ffi.Pointer<ffi.UnsignedLong> startPtr,
      ffi.Pointer<ffi.UnsignedLong> lineEndPtr,
      ffi.Pointer<ffi.UnsignedLong> contentsEndPtr,
      NSRange range) {
    _lib._objc_msgSend_136(
        _id,
        _lib._sel_getLineStart_end_contentsEnd_forRange_1,
        startPtr,
        lineEndPtr,
        contentsEndPtr,
        range);
  }

  void lineRangeForRange_(ffi.Pointer<NSRange> stret, NSRange range) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_133_stret(
            stret, _id, _lib._sel_lineRangeForRange_1, range)
        : stret.ref =
            _lib._objc_msgSend_133(_id, _lib._sel_lineRangeForRange_1, range);
  }

  void getParagraphStart_end_contentsEnd_forRange_(
      ffi.Pointer<ffi.UnsignedLong> startPtr,
      ffi.Pointer<ffi.UnsignedLong> parEndPtr,
      ffi.Pointer<ffi.UnsignedLong> contentsEndPtr,
      NSRange range) {
    _lib._objc_msgSend_136(
        _id,
        _lib._sel_getParagraphStart_end_contentsEnd_forRange_1,
        startPtr,
        parEndPtr,
        contentsEndPtr,
        range);
  }

  void paragraphRangeForRange_(ffi.Pointer<NSRange> stret, NSRange range) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_133_stret(
            stret, _id, _lib._sel_paragraphRangeForRange_1, range)
        : stret.ref = _lib._objc_msgSend_133(
            _id, _lib._sel_paragraphRangeForRange_1, range);
  }

  /// In the enumerate methods, the blocks will be invoked inside an autorelease pool, so any values assigned inside the block should be retained.
  void enumerateSubstringsInRange_options_usingBlock_(NSRange range, int opts,
      ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool block) {
    _lib._objc_msgSend_137(
        _id,
        _lib._sel_enumerateSubstringsInRange_options_usingBlock_1,
        range,
        opts,
        block._id);
  }

  void enumerateLinesUsingBlock_(ObjCBlock_ffiVoid_NSString_bool block) {
    _lib._objc_msgSend_138(
        _id, _lib._sel_enumerateLinesUsingBlock_1, block._id);
  }

  /// Convenience to return null-terminated UTF8 representation
  ffi.Pointer<ffi.Char> get UTF8String {
    return _lib._objc_msgSend_35(_id, _lib._sel_UTF8String1);
  }

  /// Result in O(1) time; a rough estimate
  int get fastestEncoding {
    return _lib._objc_msgSend_12(_id, _lib._sel_fastestEncoding1);
  }

  /// Result in O(n) time; the encoding in which the string is most compact
  int get smallestEncoding {
    return _lib._objc_msgSend_12(_id, _lib._sel_smallestEncoding1);
  }

  /// External representation
  NSData? dataUsingEncoding_allowLossyConversion_(int encoding, bool lossy) {
    final _ret = _lib._objc_msgSend_139(_id,
        _lib._sel_dataUsingEncoding_allowLossyConversion_1, encoding, lossy);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  /// External representation
  NSData? dataUsingEncoding_(int encoding) {
    final _ret =
        _lib._objc_msgSend_140(_id, _lib._sel_dataUsingEncoding_1, encoding);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  bool canBeConvertedToEncoding_(int encoding) {
    return _lib._objc_msgSend_141(
        _id, _lib._sel_canBeConvertedToEncoding_1, encoding);
  }

  /// "Autoreleased"; NULL return if encoding conversion not possible; for performance reasons, lifetime of this should not be considered longer than the lifetime of the receiving string (if the receiver string is freed, this might go invalid then, before the end of the autorelease scope). Use only with 8-bit encodings, and not encodings such as UTF-16 or UTF-32.
  ffi.Pointer<ffi.Char> cStringUsingEncoding_(int encoding) {
    return _lib._objc_msgSend_142(
        _id, _lib._sel_cStringUsingEncoding_1, encoding);
  }

  /// NO return if conversion not possible due to encoding errors or too small of a buffer. The buffer should include room for maxBufferCount bytes; this number should accomodate the expected size of the return value plus the NULL termination character, which this method adds. (So note that the maxLength passed to this method is one more than the one you would have passed to the deprecated getCString:maxLength:.) Use only with 8-bit encodings, and not encodings such as UTF-16 or UTF-32.
  bool getCString_maxLength_encoding_(
      ffi.Pointer<ffi.Char> buffer, int maxBufferCount, int encoding) {
    return _lib._objc_msgSend_143(
        _id,
        _lib._sel_getCString_maxLength_encoding_1,
        buffer,
        maxBufferCount,
        encoding);
  }

  /// Use this to convert string section at a time into a fixed-size buffer, without any allocations.  Does not NULL-terminate.
  /// buffer is the buffer to write to; if NULL, this method can be used to computed size of needed buffer.
  /// maxBufferCount is the length of the buffer in bytes. It's a good idea to make sure this is at least enough to hold one character's worth of conversion.
  /// usedBufferCount is the length of the buffer used up by the current conversion. Can be NULL.
  /// encoding is the encoding to convert to.
  /// options specifies the options to apply.
  /// range is the range to convert.
  /// leftOver is the remaining range. Can be NULL.
  /// YES return indicates some characters were converted. Conversion might usually stop when the buffer fills,
  /// but it might also stop when the conversion isn't possible due to the chosen encoding.
  bool getBytes_maxLength_usedLength_encoding_options_range_remainingRange_(
      ffi.Pointer<ffi.Void> buffer,
      int maxBufferCount,
      ffi.Pointer<ffi.UnsignedLong> usedBufferCount,
      int encoding,
      int options,
      NSRange range,
      ffi.Pointer<NSRange> leftover) {
    return _lib._objc_msgSend_144(
        _id,
        _lib._sel_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_1,
        buffer,
        maxBufferCount,
        usedBufferCount,
        encoding,
        options,
        range,
        leftover);
  }

  /// Result in O(1) time; the estimate may be way over what's needed. Returns 0 on error (overflow)
  int maximumLengthOfBytesUsingEncoding_(int enc) {
    return _lib._objc_msgSend_145(
        _id, _lib._sel_maximumLengthOfBytesUsingEncoding_1, enc);
  }

  /// Result in O(n) time; the result is exact. Returns 0 on error (cannot convert to specified encoding, or overflow)
  int lengthOfBytesUsingEncoding_(int enc) {
    return _lib._objc_msgSend_145(
        _id, _lib._sel_lengthOfBytesUsingEncoding_1, enc);
  }

  static ffi.Pointer<ffi.UnsignedLong> getAvailableStringEncodings(
      Foundation _lib) {
    return _lib._objc_msgSend_146(
        _lib._class_NSString1, _lib._sel_availableStringEncodings1);
  }

  static NSString localizedNameOfStringEncoding_(
      Foundation _lib, int encoding) {
    final _ret = _lib._objc_msgSend_106(_lib._class_NSString1,
        _lib._sel_localizedNameOfStringEncoding_1, encoding);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Should be rarely used
  static int getDefaultCStringEncoding(Foundation _lib) {
    return _lib._objc_msgSend_12(
        _lib._class_NSString1, _lib._sel_defaultCStringEncoding1);
  }

  NSString get decomposedStringWithCanonicalMapping {
    final _ret = _lib._objc_msgSend_13(
        _id, _lib._sel_decomposedStringWithCanonicalMapping1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString get precomposedStringWithCanonicalMapping {
    final _ret = _lib._objc_msgSend_13(
        _id, _lib._sel_precomposedStringWithCanonicalMapping1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString get decomposedStringWithCompatibilityMapping {
    final _ret = _lib._objc_msgSend_13(
        _id, _lib._sel_decomposedStringWithCompatibilityMapping1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString get precomposedStringWithCompatibilityMapping {
    final _ret = _lib._objc_msgSend_13(
        _id, _lib._sel_precomposedStringWithCompatibilityMapping1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSObject componentsSeparatedByString_(NSString separator) {
    final _ret = _lib._objc_msgSend_18(
        _id, _lib._sel_componentsSeparatedByString_1, separator._id);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSObject componentsSeparatedByCharactersInSet_(NSCharacterSet separator) {
    final _ret = _lib._objc_msgSend_147(
        _id, _lib._sel_componentsSeparatedByCharactersInSet_1, separator._id);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSString stringByTrimmingCharactersInSet_(NSCharacterSet set) {
    final _ret = _lib._objc_msgSend_148(
        _id, _lib._sel_stringByTrimmingCharactersInSet_1, set._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString stringByPaddingToLength_withString_startingAtIndex_(
      int newLength, NSString padString, int padIndex) {
    final _ret = _lib._objc_msgSend_149(
        _id,
        _lib._sel_stringByPaddingToLength_withString_startingAtIndex_1,
        newLength,
        padString._id,
        padIndex);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a string with the character folding options applied. theOptions is a mask of compare flags with *InsensitiveSearch suffix.
  NSString stringByFoldingWithOptions_locale_(int options, NSLocale? locale) {
    final _ret = _lib._objc_msgSend_150(
        _id,
        _lib._sel_stringByFoldingWithOptions_locale_1,
        options,
        locale?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Replace all occurrences of the target string in the specified range with replacement. Specified compare options are used for matching target. If NSRegularExpressionSearch is specified, the replacement is treated as a template, as in the corresponding NSRegularExpression methods, and no other options can apply except NSCaseInsensitiveSearch and NSAnchoredSearch.
  NSString stringByReplacingOccurrencesOfString_withString_options_range_(
      NSString target, NSString replacement, int options, NSRange searchRange) {
    final _ret = _lib._objc_msgSend_151(
        _id,
        _lib._sel_stringByReplacingOccurrencesOfString_withString_options_range_1,
        target._id,
        replacement._id,
        options,
        searchRange);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Replace all occurrences of the target string with replacement. Invokes the above method with 0 options and range of the whole string.
  NSString stringByReplacingOccurrencesOfString_withString_(
      NSString target, NSString replacement) {
    final _ret = _lib._objc_msgSend_152(
        _id,
        _lib._sel_stringByReplacingOccurrencesOfString_withString_1,
        target._id,
        replacement._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Replace characters in range with the specified string, returning new string.
  NSString stringByReplacingCharactersInRange_withString_(
      NSRange range, NSString replacement) {
    final _ret = _lib._objc_msgSend_153(
        _id,
        _lib._sel_stringByReplacingCharactersInRange_withString_1,
        range,
        replacement._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Returns nil if reverse not applicable or transform is invalid
  NSString? stringByApplyingTransform_reverse_(
      NSString transform, bool reverse) {
    final _ret = _lib._objc_msgSend_154(_id,
        _lib._sel_stringByApplyingTransform_reverse_1, transform._id, reverse);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Write to specified url or path using the specified encoding.  The optional error return is to indicate file system or encoding errors.
  bool writeToURL_atomically_encoding_error_(NSURL url, bool useAuxiliaryFile,
      int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_155(
        _id,
        _lib._sel_writeToURL_atomically_encoding_error_1,
        url._id,
        useAuxiliaryFile,
        enc,
        error);
  }

  bool writeToFile_atomically_encoding_error_(
      NSString path,
      bool useAuxiliaryFile,
      int enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_156(
        _id,
        _lib._sel_writeToFile_atomically_encoding_error_1,
        path._id,
        useAuxiliaryFile,
        enc,
        error);
  }

  NSString get description {
    final _ret = _lib._objc_msgSend_13(_id, _lib._sel_description1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  int get hash {
    return _lib._objc_msgSend_12(_id, _lib._sel_hash1);
  }

  /// "NoCopy" is a hint
  NSString initWithCharactersNoCopy_length_freeWhenDone_(
      ffi.Pointer<ffi.UnsignedShort> characters, int length, bool freeBuffer) {
    final _ret = _lib._objc_msgSend_157(
        _id,
        _lib._sel_initWithCharactersNoCopy_length_freeWhenDone_1,
        characters,
        length,
        freeBuffer);
    return NSString._(_ret, _lib, retain: false, release: true);
  }

  NSString initWithCharactersNoCopy_length_deallocator_(
      ffi.Pointer<ffi.UnsignedShort> chars,
      int len,
      ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong? deallocator) {
    final _ret = _lib._objc_msgSend_158(
        _id,
        _lib._sel_initWithCharactersNoCopy_length_deallocator_1,
        chars,
        len,
        deallocator?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: false, release: true);
  }

  NSString initWithCharacters_length_(
      ffi.Pointer<ffi.UnsignedShort> characters, int length) {
    final _ret = _lib._objc_msgSend_159(
        _id, _lib._sel_initWithCharacters_length_1, characters, length);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? initWithUTF8String_(ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final _ret = _lib._objc_msgSend_160(
        _id, _lib._sel_initWithUTF8String_1, nullTerminatedCString);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString initWithString_(NSString aString) {
    final _ret =
        _lib._objc_msgSend_18(_id, _lib._sel_initWithString_1, aString._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString initWithFormat_(NSString format) {
    final _ret =
        _lib._objc_msgSend_18(_id, _lib._sel_initWithFormat_1, format._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString initWithFormat_arguments_(
      NSString format, ffi.Pointer<ffi.Char> argList) {
    final _ret = _lib._objc_msgSend_161(
        _id, _lib._sel_initWithFormat_arguments_1, format._id, argList);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString initWithFormat_locale_(NSString format, NSObject? locale) {
    final _ret = _lib._objc_msgSend_162(_id, _lib._sel_initWithFormat_locale_1,
        format._id, locale?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString initWithFormat_locale_arguments_(
      NSString format, NSObject? locale, ffi.Pointer<ffi.Char> argList) {
    final _ret = _lib._objc_msgSend_163(
        _id,
        _lib._sel_initWithFormat_locale_arguments_1,
        format._id,
        locale?._id ?? ffi.nullptr,
        argList);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? initWithValidatedFormat_validFormatSpecifiers_error_(
      NSString format,
      NSString validFormatSpecifiers,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? initWithValidatedFormat_validFormatSpecifiers_locale_error_(
      NSString format,
      NSString validFormatSpecifiers,
      NSObject? locale,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_165(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_locale_error_1,
        format._id,
        validFormatSpecifiers._id,
        locale?._id ?? ffi.nullptr,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? initWithValidatedFormat_validFormatSpecifiers_arguments_error_(
      NSString format,
      NSString validFormatSpecifiers,
      ffi.Pointer<ffi.Char> argList,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_166(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_arguments_error_1,
        format._id,
        validFormatSpecifiers._id,
        argList,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString?
      initWithValidatedFormat_validFormatSpecifiers_locale_arguments_error_(
          NSString format,
          NSString validFormatSpecifiers,
          NSObject? locale,
          ffi.Pointer<ffi.Char> argList,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_167(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_locale_arguments_error_1,
        format._id,
        validFormatSpecifiers._id,
        locale?._id ?? ffi.nullptr,
        argList,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? initWithData_encoding_(NSData data, int encoding) {
    final _ret = _lib._objc_msgSend_168(
        _id, _lib._sel_initWithData_encoding_1, data._id, encoding);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? initWithBytes_length_encoding_(
      ffi.Pointer<ffi.Void> bytes, int len, int encoding) {
    final _ret = _lib._objc_msgSend_169(
        _id, _lib._sel_initWithBytes_length_encoding_1, bytes, len, encoding);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// "NoCopy" is a hint
  NSString? initWithBytesNoCopy_length_encoding_freeWhenDone_(
      ffi.Pointer<ffi.Void> bytes, int len, int encoding, bool freeBuffer) {
    final _ret = _lib._objc_msgSend_170(
        _id,
        _lib._sel_initWithBytesNoCopy_length_encoding_freeWhenDone_1,
        bytes,
        len,
        encoding,
        freeBuffer);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: false, release: true);
  }

  NSString? initWithBytesNoCopy_length_encoding_deallocator_(
      ffi.Pointer<ffi.Void> bytes,
      int len,
      int encoding,
      ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong? deallocator) {
    final _ret = _lib._objc_msgSend_171(
        _id,
        _lib._sel_initWithBytesNoCopy_length_encoding_deallocator_1,
        bytes,
        len,
        encoding,
        deallocator?._id ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: false, release: true);
  }

  static NSString string(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSString1, _lib._sel_string1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString stringWithString_(Foundation _lib, NSString string) {
    final _ret = _lib._objc_msgSend_18(
        _lib._class_NSString1, _lib._sel_stringWithString_1, string._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString stringWithCharacters_length_(
      Foundation _lib, ffi.Pointer<ffi.UnsignedShort> characters, int length) {
    final _ret = _lib._objc_msgSend_159(_lib._class_NSString1,
        _lib._sel_stringWithCharacters_length_1, characters, length);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString? stringWithUTF8String_(
      Foundation _lib, ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final _ret = _lib._objc_msgSend_160(_lib._class_NSString1,
        _lib._sel_stringWithUTF8String_1, nullTerminatedCString);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString stringWithFormat_(Foundation _lib, NSString format) {
    final _ret = _lib._objc_msgSend_18(
        _lib._class_NSString1, _lib._sel_stringWithFormat_1, format._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString localizedStringWithFormat_(Foundation _lib, NSString format) {
    final _ret = _lib._objc_msgSend_18(_lib._class_NSString1,
        _lib._sel_localizedStringWithFormat_1, format._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString? stringWithValidatedFormat_validFormatSpecifiers_error_(
      Foundation _lib,
      NSString format,
      NSString validFormatSpecifiers,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _lib._class_NSString1,
        _lib._sel_stringWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString?
      localizedStringWithValidatedFormat_validFormatSpecifiers_error_(
          Foundation _lib,
          NSString format,
          NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _lib._class_NSString1,
        _lib._sel_localizedStringWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? initWithCString_encoding_(
      ffi.Pointer<ffi.Char> nullTerminatedCString, int encoding) {
    final _ret = _lib._objc_msgSend_172(_id,
        _lib._sel_initWithCString_encoding_1, nullTerminatedCString, encoding);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString? stringWithCString_encoding_(
      Foundation _lib, ffi.Pointer<ffi.Char> cString, int enc) {
    final _ret = _lib._objc_msgSend_172(_lib._class_NSString1,
        _lib._sel_stringWithCString_encoding_1, cString, enc);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// These use the specified encoding.  If nil is returned, the optional error return indicates problem that was encountered (for instance, file system or encoding errors).
  NSString? initWithContentsOfURL_encoding_error_(
      NSURL url, int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_173(_id,
        _lib._sel_initWithContentsOfURL_encoding_error_1, url._id, enc, error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? initWithContentsOfFile_encoding_error_(
      NSString path, int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_174(
        _id,
        _lib._sel_initWithContentsOfFile_encoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString? stringWithContentsOfURL_encoding_error_(Foundation _lib,
      NSURL url, int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_173(
        _lib._class_NSString1,
        _lib._sel_stringWithContentsOfURL_encoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString? stringWithContentsOfFile_encoding_error_(Foundation _lib,
      NSString path, int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_174(
        _lib._class_NSString1,
        _lib._sel_stringWithContentsOfFile_encoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// These try to determine the encoding, and return the encoding which was used.  Note that these methods might get "smarter" in subsequent releases of the system, and use additional techniques for recognizing encodings. If nil is returned, the optional error return indicates problem that was encountered (for instance, file system or encoding errors).
  NSString? initWithContentsOfURL_usedEncoding_error_(
      NSURL url,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_175(
        _id,
        _lib._sel_initWithContentsOfURL_usedEncoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? initWithContentsOfFile_usedEncoding_error_(
      NSString path,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_176(
        _id,
        _lib._sel_initWithContentsOfFile_usedEncoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString? stringWithContentsOfURL_usedEncoding_error_(
      Foundation _lib,
      NSURL url,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_175(
        _lib._class_NSString1,
        _lib._sel_stringWithContentsOfURL_usedEncoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString? stringWithContentsOfFile_usedEncoding_error_(
      Foundation _lib,
      NSString path,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_176(
        _lib._class_NSString1,
        _lib._sel_stringWithContentsOfFile_usedEncoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// This API is used to detect the string encoding of a given raw data. It can also do lossy string conversion. It converts the data to a string in the detected string encoding. The data object contains the raw bytes, and the option dictionary contains the hints and parameters for the analysis. The opts dictionary can be nil. If the string parameter is not NULL, the string created by the detected string encoding is returned. The lossy substitution string is emitted in the output string for characters that could not be converted when lossy conversion is enabled. The usedLossyConversion indicates if there is any lossy conversion in the resulted string. If no encoding can be detected, 0 is returned.
  ///
  /// The possible items for the dictionary are:
  /// 1) an array of suggested string encodings (without specifying the 3rd option in this list, all string encodings are considered but the ones in the array will have a higher preference; moreover, the order of the encodings in the array is important: the first encoding has a higher preference than the second one in the array)
  /// 2) an array of string encodings not to use (the string encodings in this list will not be considered at all)
  /// 3) a boolean option indicating whether only the suggested string encodings are considered
  /// 4) a boolean option indicating whether lossy is allowed
  /// 5) an option that gives a specific string to substitude for mystery bytes
  /// 6) the current user's language
  /// 7) a boolean option indicating whether the data is generated by Windows
  ///
  /// If the values in the dictionary have wrong types (for example, the value of NSStringEncodingDetectionSuggestedEncodingsKey is not an array), an exception is thrown.
  /// If the values in the dictionary are unknown (for example, the value in the array of suggested string encodings is not a valid encoding), the values will be ignored.
  static int
      stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_(
          Foundation _lib,
          NSData data,
          NSObject? opts,
          ffi.Pointer<ffi.Pointer<ObjCObject>> string,
          ffi.Pointer<ffi.Bool> usedLossyConversion) {
    return _lib._objc_msgSend_177(
        _lib._class_NSString1,
        _lib._sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_1,
        data._id,
        opts?._id ?? ffi.nullptr,
        string,
        usedLossyConversion);
  }

  /// These methods are no longer recommended since they do not work with property lists and strings files in binary plist format. Please use the APIs in NSPropertyList.h instead.
  NSObject propertyList() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_propertyList1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSDictionary? propertyListFromStringsFileFormat() {
    final _ret = _lib._objc_msgSend_178(
        _id, _lib._sel_propertyListFromStringsFileFormat1);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// The following methods are deprecated and will be removed from this header file in the near future. These methods use NSString.defaultCStringEncoding as the encoding to convert to, which means the results depend on the user's language and potentially other settings. This might be appropriate in some cases, but often these methods are misused, resulting in issues when running in languages other then English. UTF8String in general is a much better choice when converting arbitrary NSStrings into 8-bit representations. Additional potential replacement methods are being introduced in NSString as appropriate.
  ffi.Pointer<ffi.Char> cString() {
    return _lib._objc_msgSend_35(_id, _lib._sel_cString1);
  }

  ffi.Pointer<ffi.Char> lossyCString() {
    return _lib._objc_msgSend_35(_id, _lib._sel_lossyCString1);
  }

  int cStringLength() {
    return _lib._objc_msgSend_12(_id, _lib._sel_cStringLength1);
  }

  void getCString_(ffi.Pointer<ffi.Char> bytes) {
    _lib._objc_msgSend_179(_id, _lib._sel_getCString_1, bytes);
  }

  void getCString_maxLength_(ffi.Pointer<ffi.Char> bytes, int maxLength) {
    _lib._objc_msgSend_180(
        _id, _lib._sel_getCString_maxLength_1, bytes, maxLength);
  }

  void getCString_maxLength_range_remainingRange_(ffi.Pointer<ffi.Char> bytes,
      int maxLength, NSRange aRange, ffi.Pointer<NSRange> leftoverRange) {
    _lib._objc_msgSend_181(
        _id,
        _lib._sel_getCString_maxLength_range_remainingRange_1,
        bytes,
        maxLength,
        aRange,
        leftoverRange);
  }

  bool writeToFile_atomically_(NSString path, bool useAuxiliaryFile) {
    return _lib._objc_msgSend_182(
        _id, _lib._sel_writeToFile_atomically_1, path._id, useAuxiliaryFile);
  }

  bool writeToURL_atomically_(NSURL url, bool atomically) {
    return _lib._objc_msgSend_183(
        _id, _lib._sel_writeToURL_atomically_1, url._id, atomically);
  }

  NSObject? initWithContentsOfFile_(NSString path) {
    final _ret = _lib._objc_msgSend_25(
        _id, _lib._sel_initWithContentsOfFile_1, path._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSObject? initWithContentsOfURL_(NSURL url) {
    final _ret =
        _lib._objc_msgSend_184(_id, _lib._sel_initWithContentsOfURL_1, url._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithContentsOfFile_(Foundation _lib, NSString path) {
    final _ret = _lib._objc_msgSend_25(
        _lib._class_NSString1, _lib._sel_stringWithContentsOfFile_1, path._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithContentsOfURL_(Foundation _lib, NSURL url) {
    final _ret = _lib._objc_msgSend_184(
        _lib._class_NSString1, _lib._sel_stringWithContentsOfURL_1, url._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSObject? initWithCStringNoCopy_length_freeWhenDone_(
      ffi.Pointer<ffi.Char> bytes, int length, bool freeBuffer) {
    final _ret = _lib._objc_msgSend_185(
        _id,
        _lib._sel_initWithCStringNoCopy_length_freeWhenDone_1,
        bytes,
        length,
        freeBuffer);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: false, release: true);
  }

  NSObject? initWithCString_length_(ffi.Pointer<ffi.Char> bytes, int length) {
    final _ret = _lib._objc_msgSend_172(
        _id, _lib._sel_initWithCString_length_1, bytes, length);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSObject? initWithCString_(ffi.Pointer<ffi.Char> bytes) {
    final _ret =
        _lib._objc_msgSend_160(_id, _lib._sel_initWithCString_1, bytes);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithCString_length_(
      Foundation _lib, ffi.Pointer<ffi.Char> bytes, int length) {
    final _ret = _lib._objc_msgSend_172(_lib._class_NSString1,
        _lib._sel_stringWithCString_length_1, bytes, length);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithCString_(
      Foundation _lib, ffi.Pointer<ffi.Char> bytes) {
    final _ret = _lib._objc_msgSend_160(
        _lib._class_NSString1, _lib._sel_stringWithCString_1, bytes);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// This method is unsafe because it could potentially cause buffer overruns. You should use -getCharacters:range: instead.
  void getCharacters_(ffi.Pointer<ffi.UnsignedShort> buffer) {
    _lib._objc_msgSend_186(_id, _lib._sel_getCharacters_1, buffer);
  }

  /// Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters. UTF-8 encoding is used to determine the correct percent encoded characters. Entire URL strings cannot be percent-encoded. This method is intended to percent-encode a URL component or subcomponent string, NOT the entire URL string. Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.
  NSString? stringByAddingPercentEncodingWithAllowedCharacters_(
      NSCharacterSet allowedCharacters) {
    final _ret = _lib._objc_msgSend_187(
        _id,
        _lib._sel_stringByAddingPercentEncodingWithAllowedCharacters_1,
        allowedCharacters._id);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a new string made from the receiver by replacing all percent encoded sequences with the matching UTF-8 characters.
  NSString? get stringByRemovingPercentEncoding {
    final _ret =
        _lib._objc_msgSend_32(_id, _lib._sel_stringByRemovingPercentEncoding1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? stringByAddingPercentEscapesUsingEncoding_(int enc) {
    final _ret = _lib._objc_msgSend_188(
        _id, _lib._sel_stringByAddingPercentEscapesUsingEncoding_1, enc);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? stringByReplacingPercentEscapesUsingEncoding_(int enc) {
    final _ret = _lib._objc_msgSend_188(
        _id, _lib._sel_stringByReplacingPercentEscapesUsingEncoding_1, enc);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString new1(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSString1, _lib._sel_new1);
    return NSString._(_ret, _lib, retain: false, release: true);
  }

  static NSString allocWithZone_(Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSString1, _lib._sel_allocWithZone_1, zone);
    return NSString._(_ret, _lib, retain: false, release: true);
  }

  static NSString alloc(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSString1, _lib._sel_alloc1);
    return NSString._(_ret, _lib, retain: false, release: true);
  }
}

extension StringToNSString on String {
  NSString toNSString(Foundation lib) => NSString(lib, this);
}

final class ObjCSel extends ffi.Opaque {}

final class ObjCObject extends ffi.Opaque {}

class NSObject extends _ObjCWrapper {
  NSObject._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSObject] that points to the same underlying object as [other].
  static NSObject castFrom<T extends _ObjCWrapper>(T other) {
    return NSObject._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSObject] that wraps the given raw object pointer.
  static NSObject castFromPointer(Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSObject._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSObject].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSObject1);
  }

  static void load(Foundation _lib) {
    _lib._objc_msgSend_1(_lib._class_NSObject1, _lib._sel_load1);
  }

  static void initialize(Foundation _lib) {
    _lib._objc_msgSend_1(_lib._class_NSObject1, _lib._sel_initialize1);
  }

  NSObject init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject new1(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_new1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject allocWithZone_(Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_allocWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject alloc(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_alloc1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  void dealloc() {
    _lib._objc_msgSend_1(_id, _lib._sel_dealloc1);
  }

  void finalize() {
    _lib._objc_msgSend_1(_id, _lib._sel_finalize1);
  }

  NSObject copy() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_copy1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  NSObject mutableCopy() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_mutableCopy1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject copyWithZone_(Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_copyWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject mutableCopyWithZone_(
      Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_mutableCopyWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static bool instancesRespondToSelector_(
      Foundation _lib, ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_4(_lib._class_NSObject1,
        _lib._sel_instancesRespondToSelector_1, aSelector);
  }

  static bool conformsToProtocol_(Foundation _lib, Protocol protocol) {
    return _lib._objc_msgSend_5(
        _lib._class_NSObject1, _lib._sel_conformsToProtocol_1, protocol._id);
  }

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> methodForSelector_(
      ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_6(_id, _lib._sel_methodForSelector_1, aSelector);
  }

  static ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      instanceMethodForSelector_(
          Foundation _lib, ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_6(_lib._class_NSObject1,
        _lib._sel_instanceMethodForSelector_1, aSelector);
  }

  void doesNotRecognizeSelector_(ffi.Pointer<ObjCSel> aSelector) {
    _lib._objc_msgSend_7(_id, _lib._sel_doesNotRecognizeSelector_1, aSelector);
  }

  NSObject forwardingTargetForSelector_(ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_8(
        _id, _lib._sel_forwardingTargetForSelector_1, aSelector);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  void forwardInvocation_(NSInvocation anInvocation) {
    _lib._objc_msgSend_9(_id, _lib._sel_forwardInvocation_1, anInvocation._id);
  }

  NSMethodSignature methodSignatureForSelector_(
      ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_10(
        _id, _lib._sel_methodSignatureForSelector_1, aSelector);
    return NSMethodSignature._(_ret, _lib, retain: true, release: true);
  }

  static NSMethodSignature instanceMethodSignatureForSelector_(
      Foundation _lib, ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_10(_lib._class_NSObject1,
        _lib._sel_instanceMethodSignatureForSelector_1, aSelector);
    return NSMethodSignature._(_ret, _lib, retain: true, release: true);
  }

  bool allowsWeakReference() {
    return _lib._objc_msgSend_11(_id, _lib._sel_allowsWeakReference1);
  }

  bool retainWeakReference() {
    return _lib._objc_msgSend_11(_id, _lib._sel_retainWeakReference1);
  }

  static bool isSubclassOfClass_(Foundation _lib, NSObject aClass) {
    return _lib._objc_msgSend_0(
        _lib._class_NSObject1, _lib._sel_isSubclassOfClass_1, aClass._id);
  }

  static bool resolveClassMethod_(Foundation _lib, ffi.Pointer<ObjCSel> sel) {
    return _lib._objc_msgSend_4(
        _lib._class_NSObject1, _lib._sel_resolveClassMethod_1, sel);
  }

  static bool resolveInstanceMethod_(
      Foundation _lib, ffi.Pointer<ObjCSel> sel) {
    return _lib._objc_msgSend_4(
        _lib._class_NSObject1, _lib._sel_resolveInstanceMethod_1, sel);
  }

  static int hash(Foundation _lib) {
    return _lib._objc_msgSend_12(_lib._class_NSObject1, _lib._sel_hash1);
  }

  static NSObject superclass(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_superclass1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject class1(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_class1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSString description(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_13(_lib._class_NSObject1, _lib._sel_description1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString debugDescription(Foundation _lib) {
    final _ret = _lib._objc_msgSend_13(
        _lib._class_NSObject1, _lib._sel_debugDescription1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  void URL_resourceDataDidBecomeAvailable_(NSURL sender, NSData newBytes) {
    _lib._objc_msgSend_100(_id, _lib._sel_URL_resourceDataDidBecomeAvailable_1,
        sender._id, newBytes._id);
  }

  void URLResourceDidFinishLoading_(NSURL sender) {
    _lib._objc_msgSend_101(
        _id, _lib._sel_URLResourceDidFinishLoading_1, sender._id);
  }

  void URLResourceDidCancelLoading_(NSURL sender) {
    _lib._objc_msgSend_101(
        _id, _lib._sel_URLResourceDidCancelLoading_1, sender._id);
  }

  void URL_resourceDidFailLoadingWithReason_(NSURL sender, NSString reason) {
    _lib._objc_msgSend_102(
        _id,
        _lib._sel_URL_resourceDidFailLoadingWithReason_1,
        sender._id,
        reason._id);
  }

  /// Given that an error alert has been presented document-modally to the user, and the user has chosen one of the error's recovery options, attempt recovery from the error, and send the selected message to the specified delegate. The option index is an index into the error's array of localized recovery options. The method selected by didRecoverSelector must have the same signature as:
  ///
  /// - (void)didPresentErrorWithRecovery:(BOOL)didRecover contextInfo:(void *)contextInfo;
  ///
  /// The value passed for didRecover must be YES if error recovery was completely successful, NO otherwise.
  void
      attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo_(
          NSError error,
          int recoveryOptionIndex,
          NSObject? delegate,
          ffi.Pointer<ObjCSel> didRecoverSelector,
          ffi.Pointer<ffi.Void> contextInfo) {
    _lib._objc_msgSend_103(
        _id,
        _lib._sel_attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo_1,
        error._id,
        recoveryOptionIndex,
        delegate?._id ?? ffi.nullptr,
        didRecoverSelector,
        contextInfo);
  }

  /// Given that an error alert has been presented applicaton-modally to the user, and the user has chosen one of the error's recovery options, attempt recovery from the error, and return YES if error recovery was completely successful, NO otherwise. The recovery option index is an index into the error's array of localized recovery options.
  bool attemptRecoveryFromError_optionIndex_(
      NSError error, int recoveryOptionIndex) {
    return _lib._objc_msgSend_104(
        _id,
        _lib._sel_attemptRecoveryFromError_optionIndex_1,
        error._id,
        recoveryOptionIndex);
  }
}

typedef instancetype = ffi.Pointer<ObjCObject>;
typedef Dartinstancetype = NSObject;

final class NSZone extends ffi.Opaque {}

class Protocol extends _ObjCWrapper {
  Protocol._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [Protocol] that points to the same underlying object as [other].
  static Protocol castFrom<T extends _ObjCWrapper>(T other) {
    return Protocol._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [Protocol] that wraps the given raw object pointer.
  static Protocol castFromPointer(Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return Protocol._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [Protocol].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_Protocol1);
  }
}

class NSInvocation extends _ObjCWrapper {
  NSInvocation._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSInvocation] that points to the same underlying object as [other].
  static NSInvocation castFrom<T extends _ObjCWrapper>(T other) {
    return NSInvocation._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSInvocation] that wraps the given raw object pointer.
  static NSInvocation castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSInvocation._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSInvocation].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSInvocation1);
  }
}

class NSMethodSignature extends _ObjCWrapper {
  NSMethodSignature._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSMethodSignature] that points to the same underlying object as [other].
  static NSMethodSignature castFrom<T extends _ObjCWrapper>(T other) {
    return NSMethodSignature._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSMethodSignature] that wraps the given raw object pointer.
  static NSMethodSignature castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSMethodSignature._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSMethodSignature].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSMethodSignature1);
  }
}

class NSURL extends NSObject {
  NSURL._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURL] that points to the same underlying object as [other].
  static NSURL castFrom<T extends _ObjCWrapper>(T other) {
    return NSURL._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURL] that wraps the given raw object pointer.
  static NSURL castFromPointer(Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURL._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURL].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURL1);
  }

  /// this call percent-encodes both the host and path, so this cannot be used to set a username/password or port in the hostname part or with a IPv6 '[...]' type address. NSURLComponents handles IPv6 addresses correctly.
  NSURL? initWithScheme_host_path_(
      NSString scheme, NSString? host, NSString path) {
    final _ret = _lib._objc_msgSend_14(
        _id,
        _lib._sel_initWithScheme_host_path_1,
        scheme._id,
        host?._id ?? ffi.nullptr,
        path._id);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes a newly created file NSURL referencing the local file or directory at path, relative to a base URL.
  NSURL initFileURLWithPath_isDirectory_relativeToURL_(
      NSString path, bool isDir, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_15(
        _id,
        _lib._sel_initFileURLWithPath_isDirectory_relativeToURL_1,
        path._id,
        isDir,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Better to use initFileURLWithPath:isDirectory:relativeToURL: if you know if the path is a directory vs non-directory, as it saves an I/O.
  NSURL initFileURLWithPath_relativeToURL_(NSString path, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_16(
        _id,
        _lib._sel_initFileURLWithPath_relativeToURL_1,
        path._id,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL initFileURLWithPath_isDirectory_(NSString path, bool isDir) {
    final _ret = _lib._objc_msgSend_17(
        _id, _lib._sel_initFileURLWithPath_isDirectory_1, path._id, isDir);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Better to use initFileURLWithPath:isDirectory: if you know if the path is a directory vs non-directory, as it saves an i/o.
  NSURL initFileURLWithPath_(NSString path) {
    final _ret =
        _lib._objc_msgSend_18(_id, _lib._sel_initFileURLWithPath_1, path._id);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created file NSURL referencing the local file or directory at path, relative to a base URL.
  static NSURL fileURLWithPath_isDirectory_relativeToURL_(
      Foundation _lib, NSString path, bool isDir, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_19(
        _lib._class_NSURL1,
        _lib._sel_fileURLWithPath_isDirectory_relativeToURL_1,
        path._id,
        isDir,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Better to use fileURLWithPath:isDirectory:relativeToURL: if you know if the path is a directory vs non-directory, as it saves an I/O.
  static NSURL fileURLWithPath_relativeToURL_(
      Foundation _lib, NSString path, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_20(
        _lib._class_NSURL1,
        _lib._sel_fileURLWithPath_relativeToURL_1,
        path._id,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  static NSURL fileURLWithPath_isDirectory_(
      Foundation _lib, NSString path, bool isDir) {
    final _ret = _lib._objc_msgSend_21(_lib._class_NSURL1,
        _lib._sel_fileURLWithPath_isDirectory_1, path._id, isDir);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Better to use fileURLWithPath:isDirectory: if you know if the path is a directory vs non-directory, as it saves an i/o.
  static NSURL fileURLWithPath_(Foundation _lib, NSString path) {
    final _ret = _lib._objc_msgSend_22(
        _lib._class_NSURL1, _lib._sel_fileURLWithPath_1, path._id);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes a newly created URL referencing the local file or directory at the file system representation of the path. File system representation is a null-terminated C string with canonical UTF-8 encoding.
  NSURL initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL_(
      ffi.Pointer<ffi.Char> path, bool isDir, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_23(
        _id,
        _lib._sel_initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL_1,
        path,
        isDir,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created URL referencing the local file or directory at the file system representation of the path. File system representation is a null-terminated C string with canonical UTF-8 encoding.
  static NSURL fileURLWithFileSystemRepresentation_isDirectory_relativeToURL_(
      Foundation _lib, ffi.Pointer<ffi.Char> path, bool isDir, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_24(
        _lib._class_NSURL1,
        _lib._sel_fileURLWithFileSystemRepresentation_isDirectory_relativeToURL_1,
        path,
        isDir,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// These methods expect their string arguments to contain any percent escape codes that are necessary. It is an error for URLString to be nil.
  NSURL? initWithString_(NSString URLString) {
    final _ret =
        _lib._objc_msgSend_25(_id, _lib._sel_initWithString_1, URLString._id);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL? initWithString_relativeToURL_(NSString URLString, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_26(
        _id,
        _lib._sel_initWithString_relativeToURL_1,
        URLString._id,
        baseURL?._id ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  static NSURL? URLWithString_(Foundation _lib, NSString URLString) {
    final _ret = _lib._objc_msgSend_25(
        _lib._class_NSURL1, _lib._sel_URLWithString_1, URLString._id);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  static NSURL? URLWithString_relativeToURL_(
      Foundation _lib, NSString URLString, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_26(
        _lib._class_NSURL1,
        _lib._sel_URLWithString_relativeToURL_1,
        URLString._id,
        baseURL?._id ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes an `NSURL` with a URL string and the option to add (or skip) IDNA- and percent-encoding of invalid characters.
  /// If `encodingInvalidCharacters` is false, and the URL string is invalid according to RFC 3986, `nil` is returned.
  /// If `encodingInvalidCharacters` is true, `NSURL` will try to encode the string to create a valid URL.
  /// If the URL string is still invalid after encoding, `nil` is returned.
  ///
  /// - Parameter URLString: The URL string.
  /// - Parameter encodingInvalidCharacters: True if `NSURL` should try to encode an invalid URL string, false otherwise.
  /// - Returns: An `NSURL` instance for a valid URL, or `nil` if the URL is invalid.
  NSURL? initWithString_encodingInvalidCharacters_(
      NSString URLString, bool encodingInvalidCharacters) {
    final _ret = _lib._objc_msgSend_27(
        _id,
        _lib._sel_initWithString_encodingInvalidCharacters_1,
        URLString._id,
        encodingInvalidCharacters);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created `NSURL` with a URL string and the option to add (or skip) IDNA- and percent-encoding of invalid characters.
  /// If `encodingInvalidCharacters` is false, and the URL string is invalid according to RFC 3986, `nil` is returned.
  /// If `encodingInvalidCharacters` is true, `NSURL` will try to encode the string to create a valid URL.
  /// If the URL string is still invalid after encoding, `nil` is returned.
  ///
  /// - Parameter URLString: The URL string.
  /// - Parameter encodingInvalidCharacters: True if `NSURL` should try to encode an invalid URL string, false otherwise.
  /// - Returns: An `NSURL` instance for a valid URL, or `nil` if the URL is invalid.
  static NSURL? URLWithString_encodingInvalidCharacters_(
      Foundation _lib, NSString URLString, bool encodingInvalidCharacters) {
    final _ret = _lib._objc_msgSend_27(
        _lib._class_NSURL1,
        _lib._sel_URLWithString_encodingInvalidCharacters_1,
        URLString._id,
        encodingInvalidCharacters);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes a newly created NSURL using the contents of the given data, relative to a base URL. If the data representation is not a legal URL string as ASCII bytes, the URL object may not behave as expected.
  NSURL initWithDataRepresentation_relativeToURL_(NSData data, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_29(
        _id,
        _lib._sel_initWithDataRepresentation_relativeToURL_1,
        data._id,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created NSURL using the contents of the given data, relative to a base URL. If the data representation is not a legal URL string as ASCII bytes, the URL object may not behave as expected.
  static NSURL URLWithDataRepresentation_relativeToURL_(
      Foundation _lib, NSData data, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_30(
        _lib._class_NSURL1,
        _lib._sel_URLWithDataRepresentation_relativeToURL_1,
        data._id,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes a newly created absolute NSURL using the contents of the given data, relative to a base URL. If the data representation is not a legal URL string as ASCII bytes, the URL object may not behave as expected.
  NSURL initAbsoluteURLWithDataRepresentation_relativeToURL_(
      NSData data, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_29(
        _id,
        _lib._sel_initAbsoluteURLWithDataRepresentation_relativeToURL_1,
        data._id,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created absolute NSURL using the contents of the given data, relative to a base URL. If the data representation is not a legal URL string as ASCII bytes, the URL object may not behave as expected.
  static NSURL absoluteURLWithDataRepresentation_relativeToURL_(
      Foundation _lib, NSData data, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_30(
        _lib._class_NSURL1,
        _lib._sel_absoluteURLWithDataRepresentation_relativeToURL_1,
        data._id,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns the data representation of the URL's relativeString. If the URL was initialized with -initWithData:relativeToURL:, the data representation returned are the same bytes as those used at initialization; otherwise, the data representation returned are the bytes of the relativeString encoded with NSUTF8StringEncoding.
  NSData get dataRepresentation {
    final _ret = _lib._objc_msgSend_31(_id, _lib._sel_dataRepresentation1);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSString? get absoluteString {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_absoluteString1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// The relative portion of a URL.  If baseURL is nil, or if the receiver is itself absolute, this is the same as absoluteString
  NSString get relativeString {
    final _ret = _lib._objc_msgSend_13(_id, _lib._sel_relativeString1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// may be nil.
  NSURL? get baseURL {
    final _ret = _lib._objc_msgSend_33(_id, _lib._sel_baseURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// if the receiver is itself absolute, this will return self.
  NSURL? get absoluteURL {
    final _ret = _lib._objc_msgSend_33(_id, _lib._sel_absoluteURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Any URL is composed of these two basic pieces.  The full URL would be the concatenation of [myURL scheme], ':', [myURL resourceSpecifier]
  NSString? get scheme {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_scheme1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get resourceSpecifier {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_resourceSpecifier1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// If the URL conforms to rfc 1808 (the most common form of URL), the following accessors will return the various components; otherwise they return nil.  The litmus test for conformance is as recommended in RFC 1808 - whether the first two characters of resourceSpecifier is @"//".  In all cases, they return the component's value after resolving the receiver against its base URL.
  NSString? get host {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_host1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSNumber? get port {
    final _ret = _lib._objc_msgSend_65(_id, _lib._sel_port1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSString? get user {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_user1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get password {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_password1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get path {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_path1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get fragment {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_fragment1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get parameterString {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_parameterString1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get query {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_query1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// The same as path if baseURL is nil
  NSString? get relativePath {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_relativePath1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Determines if a given URL string's path represents a directory (i.e. the path component in the URL string ends with a '/' character). This does not check the resource the URL refers to.
  bool get hasDirectoryPath {
    return _lib._objc_msgSend_11(_id, _lib._sel_hasDirectoryPath1);
  }

  /// Returns the URL's path in file system representation. File system representation is a null-terminated C string with canonical UTF-8 encoding.
  bool getFileSystemRepresentation_maxLength_(
      ffi.Pointer<ffi.Char> buffer, int maxBufferLength) {
    return _lib._objc_msgSend_66(
        _id,
        _lib._sel_getFileSystemRepresentation_maxLength_1,
        buffer,
        maxBufferLength);
  }

  /// Returns the URL's path in file system representation. File system representation is a null-terminated C string with canonical UTF-8 encoding. The returned C string will be automatically freed just as a returned object would be released; your code should copy the representation or use getFileSystemRepresentation:maxLength: if it needs to store the representation outside of the autorelease context in which the representation is created.
  ffi.Pointer<ffi.Char> get fileSystemRepresentation {
    return _lib._objc_msgSend_35(_id, _lib._sel_fileSystemRepresentation1);
  }

  /// Whether the scheme is file:; if [myURL isFileURL] is YES, then [myURL path] is suitable for input into NSFileManager or NSPathUtilities.
  bool get fileURL {
    return _lib._objc_msgSend_11(_id, _lib._sel_isFileURL1);
  }

  NSURL? get standardizedURL {
    final _ret = _lib._objc_msgSend_33(_id, _lib._sel_standardizedURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns whether the URL is a file reference URL. Symbol is present in iOS 4, but performs no operation.
  bool isFileReferenceURL() {
    return _lib._objc_msgSend_11(_id, _lib._sel_isFileReferenceURL1);
  }

  /// Returns a file reference URL that refers to the same resource as a specified file URL. File reference URLs use a URL path syntax that identifies a file system object by reference, not by path. This form of file URL remains valid when the file system path of the URL’s underlying resource changes. An error will occur if the url parameter is not a file URL. File reference URLs cannot be created to file system objects which do not exist or are not reachable. In some areas of the file system hierarchy, file reference URLs cannot be generated to the leaf node of the URL path. A file reference URL's path should never be persistently stored because is not valid across system restarts, and across remounts of volumes -- if you want to create a persistent reference to a file system object, use a bookmark (see -bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error:). Symbol is present in iOS 4, but performs no operation.
  NSURL? fileReferenceURL() {
    final _ret = _lib._objc_msgSend_33(_id, _lib._sel_fileReferenceURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a file path URL that refers to the same resource as a specified URL. File path URLs use a file system style path. An error will occur if the url parameter is not a file URL. A file reference URL's resource must exist and be reachable to be converted to a file path URL. Symbol is present in iOS 4, but performs no operation.
  NSURL? get filePathURL {
    final _ret = _lib._objc_msgSend_33(_id, _lib._sel_filePathURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns the resource value identified by a given resource key. This method first checks if the URL object already caches the resource value. If so, it returns the cached resource value to the caller. If not, then this method synchronously obtains the resource value from the backing store, adds the resource value to the URL object's cache, and returns the resource value to the caller. The type of the resource value varies by resource property (see resource key definitions). If this method returns YES and value is populated with nil, it means the resource property is not available for the specified resource and no errors occurred when determining the resource property was not available. If this method returns NO, the optional error is populated. This method is currently applicable only to URLs for file system resources. Symbol is present in iOS 4, but performs no operation.
  bool getResourceValue_forKey_error_(
      ffi.Pointer<ffi.Pointer<ObjCObject>> value,
      NSString key,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_72(
        _id, _lib._sel_getResourceValue_forKey_error_1, value, key._id, error);
  }

  /// Returns the resource values identified by specified array of resource keys. This method first checks if the URL object already caches the resource values. If so, it returns the cached resource values to the caller. If not, then this method synchronously obtains the resource values from the backing store, adds the resource values to the URL object's cache, and returns the resource values to the caller. The type of the resource values vary by property (see resource key definitions). If the result dictionary does not contain a resource value for one or more of the requested resource keys, it means those resource properties are not available for the specified resource and no errors occurred when determining those resource properties were not available. If this method returns NULL, the optional error is populated. This method is currently applicable only to URLs for file system resources. Symbol is present in iOS 4, but performs no operation.
  NSDictionary? resourceValuesForKeys_error_(
      NSObject keys, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_73(
        _id, _lib._sel_resourceValuesForKeys_error_1, keys._id, error);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Sets the resource value identified by a given resource key. This method writes the new resource value out to the backing store. Attempts to set a read-only resource property or to set a resource property not supported by the resource are ignored and are not considered errors. If this method returns NO, the optional error is populated. This method is currently applicable only to URLs for file system resources. Symbol is present in iOS 4, but performs no operation.
  bool setResourceValue_forKey_error_(NSObject? value, NSString key,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_74(_id, _lib._sel_setResourceValue_forKey_error_1,
        value?._id ?? ffi.nullptr, key._id, error);
  }

  /// Sets any number of resource values of a URL's resource. This method writes the new resource values out to the backing store. Attempts to set read-only resource properties or to set resource properties not supported by the resource are ignored and are not considered errors. If an error occurs after some resource properties have been successfully changed, the userInfo dictionary in the returned error contains an array of resource keys that were not set with the key kCFURLKeysOfUnsetValuesKey. The order in which the resource values are set is not defined. If you need to guarantee the order resource values are set, you should make multiple requests to this method or to -setResourceValue:forKey:error: to guarantee the order. If this method returns NO, the optional error is populated. This method is currently applicable only to URLs for file system resources. Symbol is present in iOS 4, but performs no operation.
  bool setResourceValues_error_(
      NSDictionary keyedValues, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_75(
        _id, _lib._sel_setResourceValues_error_1, keyedValues._id, error);
  }

  /// Removes the cached resource value identified by a given resource value key from the URL object. Removing a cached resource value may remove other cached resource values because some resource values are cached as a set of values, and because some resource values depend on other resource values (temporary resource values have no dependencies). This method is currently applicable only to URLs for file system resources.
  void removeCachedResourceValueForKey_(NSString key) {
    _lib._objc_msgSend_76(
        _id, _lib._sel_removeCachedResourceValueForKey_1, key._id);
  }

  /// Removes all cached resource values and all temporary resource values from the URL object. This method is currently applicable only to URLs for file system resources.
  void removeAllCachedResourceValues() {
    _lib._objc_msgSend_1(_id, _lib._sel_removeAllCachedResourceValues1);
  }

  /// Sets a temporary resource value on the URL object. Temporary resource values are for client use. Temporary resource values exist only in memory and are never written to the resource's backing store. Once set, a temporary resource value can be copied from the URL object with -getResourceValue:forKey:error: or -resourceValuesForKeys:error:. To remove a temporary resource value from the URL object, use -removeCachedResourceValueForKey:. Care should be taken to ensure the key that identifies a temporary resource value is unique and does not conflict with system defined keys (using reverse domain name notation in your temporary resource value keys is recommended). This method is currently applicable only to URLs for file system resources.
  void setTemporaryResourceValue_forKey_(NSObject? value, NSString key) {
    _lib._objc_msgSend_77(_id, _lib._sel_setTemporaryResourceValue_forKey_1,
        value?._id ?? ffi.nullptr, key._id);
  }

  /// Returns bookmark data for the URL, created with specified options and resource values. If this method returns nil, the optional error is populated.
  NSData?
      bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error_(
          int options,
          NSObject? keys,
          NSURL? relativeURL,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_78(
        _id,
        _lib._sel_bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error_1,
        options,
        keys?._id ?? ffi.nullptr,
        relativeURL?._id ?? ffi.nullptr,
        error);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes a newly created NSURL that refers to a location specified by resolving bookmark data. If this method returns nil, the optional error is populated.
  NSURL?
      initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_(
          NSData bookmarkData,
          int options,
          NSURL? relativeURL,
          ffi.Pointer<ffi.Bool> isStale,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_79(
        _id,
        _lib._sel_initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_1,
        bookmarkData._id,
        options,
        relativeURL?._id ?? ffi.nullptr,
        isStale,
        error);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Creates and Initializes an NSURL that refers to a location specified by resolving bookmark data. If this method returns nil, the optional error is populated.
  static NSURL?
      URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_(
          Foundation _lib,
          NSData bookmarkData,
          int options,
          NSURL? relativeURL,
          ffi.Pointer<ffi.Bool> isStale,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_79(
        _lib._class_NSURL1,
        _lib._sel_URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_1,
        bookmarkData._id,
        options,
        relativeURL?._id ?? ffi.nullptr,
        isStale,
        error);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns the resource values for properties identified by a specified array of keys contained in specified bookmark data. If the result dictionary does not contain a resource value for one or more of the requested resource keys, it means those resource properties are not available in the bookmark data.
  static NSDictionary? resourceValuesForKeys_fromBookmarkData_(
      Foundation _lib, NSObject keys, NSData bookmarkData) {
    final _ret = _lib._objc_msgSend_80(
        _lib._class_NSURL1,
        _lib._sel_resourceValuesForKeys_fromBookmarkData_1,
        keys._id,
        bookmarkData._id);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Creates an alias file on disk at a specified location with specified bookmark data. bookmarkData must have been created with the NSURLBookmarkCreationSuitableForBookmarkFile option. bookmarkFileURL must either refer to an existing file (which will be overwritten), or to location in an existing directory. If this method returns NO, the optional error is populated.
  static bool writeBookmarkData_toURL_options_error_(
      Foundation _lib,
      NSData bookmarkData,
      NSURL bookmarkFileURL,
      int options,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_81(
        _lib._class_NSURL1,
        _lib._sel_writeBookmarkData_toURL_options_error_1,
        bookmarkData._id,
        bookmarkFileURL._id,
        options,
        error);
  }

  /// Initializes and returns bookmark data derived from an alias file pointed to by a specified URL. If bookmarkFileURL refers to an alias file created prior to OS X v10.6 that contains Alias Manager information but no bookmark data, this method synthesizes bookmark data for the file. If this method returns nil, the optional error is populated.
  static NSData? bookmarkDataWithContentsOfURL_error_(Foundation _lib,
      NSURL bookmarkFileURL, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_82(
        _lib._class_NSURL1,
        _lib._sel_bookmarkDataWithContentsOfURL_error_1,
        bookmarkFileURL._id,
        error);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  /// Creates and initializes a NSURL that refers to the location specified by resolving the alias file at url. If the url argument does not refer to an alias file as defined by the NSURLIsAliasFileKey property, the NSURL returned is the same as url argument. This method fails and returns nil if the url argument is unreachable, or if the original file or directory could not be located or is not reachable, or if the original file or directory is on a volume that could not be located or mounted. If this method fails, the optional error is populated. The NSURLBookmarkResolutionWithSecurityScope option is not supported by this method.
  static NSURL? URLByResolvingAliasFileAtURL_options_error_(Foundation _lib,
      NSURL url, int options, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_83(
        _lib._class_NSURL1,
        _lib._sel_URLByResolvingAliasFileAtURL_options_error_1,
        url._id,
        options,
        error);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Given a NSURL created by resolving a bookmark data created with security scope, make the resource referenced by the url accessible to the process. Each call to startAccessingSecurityScopedResource that returns YES must be balanced with a call to stopAccessingSecurityScopedResource when access to this resource is no longer needed by the client. Calls to start and stop accessing the resource are reference counted and may be nested, which allows the pair of calls to be logically scoped.
  bool startAccessingSecurityScopedResource() {
    return _lib._objc_msgSend_11(
        _id, _lib._sel_startAccessingSecurityScopedResource1);
  }

  /// Removes one "accessing" reference to the security scope. When all references are removed, it revokes the access granted to the url by the initial prior successful call to startAccessingSecurityScopedResource.
  void stopAccessingSecurityScopedResource() {
    _lib._objc_msgSend_1(_id, _lib._sel_stopAccessingSecurityScopedResource1);
  }

  /// Get resource values from URLs of 'promised' items. A promised item is not guaranteed to have its contents in the file system until you use NSFileCoordinator to perform a coordinated read on its URL, which causes the contents to be downloaded or otherwise generated. Promised item URLs are returned by various APIs, including currently:
  /// - NSMetadataQueryUbiquitousDataScope
  /// - NSMetadataQueryUbiquitousDocumentsScope
  /// - An NSFilePresenter presenting the contents of the directory located by -URLForUbiquitousContainerIdentifier: or a subdirectory thereof
  ///
  /// The following methods behave identically to their similarly named methods above (-getResourceValue:forKey:error:, etc.), except that they allow you to get resource values and check for presence regardless of whether the promised item's contents currently exist at the URL. You must use these APIs instead of the normal NSURL resource value APIs if and only if any of the following are true:
  /// - You are using a URL that you know came directly from one of the above APIs
  /// - You are inside the accessor block of a coordinated read or write that used NSFileCoordinatorReadingImmediatelyAvailableMetadataOnly, NSFileCoordinatorWritingForDeleting, NSFileCoordinatorWritingForMoving, or NSFileCoordinatorWritingContentIndependentMetadataOnly
  ///
  /// Most of the NSURL resource value keys will work with these APIs. However, there are some that are tied to the item's contents that will not work, such as NSURLContentAccessDateKey or NSURLGenerationIdentifierKey. If one of these keys is used, the method will return YES, but the value for the key will be nil.
  bool getPromisedItemResourceValue_forKey_error_(
      ffi.Pointer<ffi.Pointer<ObjCObject>> value,
      NSString key,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_72(
        _id,
        _lib._sel_getPromisedItemResourceValue_forKey_error_1,
        value,
        key._id,
        error);
  }

  NSDictionary? promisedItemResourceValuesForKeys_error_(
      NSObject keys, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_73(_id,
        _lib._sel_promisedItemResourceValuesForKeys_error_1, keys._id, error);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  bool checkPromisedItemIsReachableAndReturnError_(
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_84(
        _id, _lib._sel_checkPromisedItemIsReachableAndReturnError_1, error);
  }

  /// The following methods work on the path portion of a URL in the same manner that the NSPathUtilities methods on NSString do.
  static NSURL? fileURLWithPathComponents_(
      Foundation _lib, NSObject components) {
    final _ret = _lib._objc_msgSend_85(_lib._class_NSURL1,
        _lib._sel_fileURLWithPathComponents_1, components._id);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSObject? get pathComponents {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_pathComponents1);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSString? get lastPathComponent {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_lastPathComponent1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get pathExtension {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_pathExtension1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSURL? URLByAppendingPathComponent_(NSString pathComponent) {
    final _ret = _lib._objc_msgSend_86(
        _id, _lib._sel_URLByAppendingPathComponent_1, pathComponent._id);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL? URLByAppendingPathComponent_isDirectory_(
      NSString pathComponent, bool isDirectory) {
    final _ret = _lib._objc_msgSend_87(
        _id,
        _lib._sel_URLByAppendingPathComponent_isDirectory_1,
        pathComponent._id,
        isDirectory);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL? get URLByDeletingLastPathComponent {
    final _ret =
        _lib._objc_msgSend_33(_id, _lib._sel_URLByDeletingLastPathComponent1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL? URLByAppendingPathExtension_(NSString pathExtension) {
    final _ret = _lib._objc_msgSend_86(
        _id, _lib._sel_URLByAppendingPathExtension_1, pathExtension._id);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL? get URLByDeletingPathExtension {
    final _ret =
        _lib._objc_msgSend_33(_id, _lib._sel_URLByDeletingPathExtension1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns whether the URL's resource exists and is reachable. This method synchronously checks if the resource's backing store is reachable. Checking reachability is appropriate when making decisions that do not require other immediate operations on the resource, e.g. periodic maintenance of UI state that depends on the existence of a specific document. When performing operations such as opening a file or copying resource properties, it is more efficient to simply try the operation and handle failures. If this method returns NO, the optional error is populated. This method is currently applicable only to URLs for file system resources. For other URL types, NO is returned. Symbol is present in iOS 4, but performs no operation.
  bool checkResourceIsReachableAndReturnError_(
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_84(
        _id, _lib._sel_checkResourceIsReachableAndReturnError_1, error);
  }

  NSURL? get URLByStandardizingPath {
    final _ret = _lib._objc_msgSend_33(_id, _lib._sel_URLByStandardizingPath1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL? get URLByResolvingSymlinksInPath {
    final _ret =
        _lib._objc_msgSend_33(_id, _lib._sel_URLByResolvingSymlinksInPath1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Blocks to load the data if necessary.  If shouldUseCache is YES, then if an equivalent URL has already been loaded and cached, its resource data will be returned immediately.  If shouldUseCache is NO, a new load will be started
  NSData? resourceDataUsingCache_(bool shouldUseCache) {
    final _ret = _lib._objc_msgSend_88(
        _id, _lib._sel_resourceDataUsingCache_1, shouldUseCache);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  /// Starts an asynchronous load of the data, registering delegate to receive notification.  Only one such background load can proceed at a time.
  void loadResourceDataNotifyingClient_usingCache_(
      NSObject client, bool shouldUseCache) {
    _lib._objc_msgSend_89(
        _id,
        _lib._sel_loadResourceDataNotifyingClient_usingCache_1,
        client._id,
        shouldUseCache);
  }

  NSObject? propertyForKey_(NSString propertyKey) {
    final _ret =
        _lib._objc_msgSend_25(_id, _lib._sel_propertyForKey_1, propertyKey._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// These attempt to write the given arguments for the resource specified by the URL; they return success or failure
  bool setResourceData_(NSData data) {
    return _lib._objc_msgSend_90(_id, _lib._sel_setResourceData_1, data._id);
  }

  bool setProperty_forKey_(NSObject property, NSString propertyKey) {
    return _lib._objc_msgSend_91(
        _id, _lib._sel_setProperty_forKey_1, property._id, propertyKey._id);
  }

  /// Sophisticated clients will want to ask for this, then message the handle directly.  If shouldUseCache is NO, a newly instantiated handle is returned, even if an equivalent URL has been loaded
  NSURLHandle? URLHandleUsingCache_(bool shouldUseCache) {
    final _ret = _lib._objc_msgSend_99(
        _id, _lib._sel_URLHandleUsingCache_1, shouldUseCache);
    return _ret.address == 0
        ? null
        : NSURLHandle._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSURL init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  static NSURL new1(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSURL1, _lib._sel_new1);
    return NSURL._(_ret, _lib, retain: false, release: true);
  }

  static NSURL allocWithZone_(Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSURL1, _lib._sel_allocWithZone_1, zone);
    return NSURL._(_ret, _lib, retain: false, release: true);
  }

  static NSURL alloc(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSURL1, _lib._sel_alloc1);
    return NSURL._(_ret, _lib, retain: false, release: true);
  }
}

class NSData extends _ObjCWrapper {
  NSData._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSData] that points to the same underlying object as [other].
  static NSData castFrom<T extends _ObjCWrapper>(T other) {
    return NSData._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSData] that wraps the given raw object pointer.
  static NSData castFromPointer(Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSData._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSData].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSData1);
  }

  ffi.Pointer<ffi.Void> get bytes {
    return _lib._objc_msgSend_28(_id, _lib._sel_bytes1);
  }
}

class NSNumber extends NSValue {
  NSNumber._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSNumber] that points to the same underlying object as [other].
  static NSNumber castFrom<T extends _ObjCWrapper>(T other) {
    return NSNumber._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSNumber] that wraps the given raw object pointer.
  static NSNumber castFromPointer(Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSNumber._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSNumber].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSNumber1);
  }

  @override
  NSNumber? initWithCoder_(NSCoder coder) {
    final _ret =
        _lib._objc_msgSend_37(_id, _lib._sel_initWithCoder_1, coder._id);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithChar_(int value) {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_initWithChar_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedChar_(int value) {
    final _ret =
        _lib._objc_msgSend_39(_id, _lib._sel_initWithUnsignedChar_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithShort_(int value) {
    final _ret = _lib._objc_msgSend_40(_id, _lib._sel_initWithShort_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedShort_(int value) {
    final _ret =
        _lib._objc_msgSend_41(_id, _lib._sel_initWithUnsignedShort_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithInt_(int value) {
    final _ret = _lib._objc_msgSend_42(_id, _lib._sel_initWithInt_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedInt_(int value) {
    final _ret =
        _lib._objc_msgSend_43(_id, _lib._sel_initWithUnsignedInt_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithLong_(int value) {
    final _ret = _lib._objc_msgSend_44(_id, _lib._sel_initWithLong_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedLong_(int value) {
    final _ret =
        _lib._objc_msgSend_45(_id, _lib._sel_initWithUnsignedLong_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithLongLong_(int value) {
    final _ret =
        _lib._objc_msgSend_46(_id, _lib._sel_initWithLongLong_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedLongLong_(int value) {
    final _ret =
        _lib._objc_msgSend_47(_id, _lib._sel_initWithUnsignedLongLong_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithFloat_(double value) {
    final _ret = _lib._objc_msgSend_48(_id, _lib._sel_initWithFloat_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithDouble_(double value) {
    final _ret = _lib._objc_msgSend_49(_id, _lib._sel_initWithDouble_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithBool_(bool value) {
    final _ret = _lib._objc_msgSend_50(_id, _lib._sel_initWithBool_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithInteger_(int value) {
    final _ret = _lib._objc_msgSend_44(_id, _lib._sel_initWithInteger_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedInteger_(int value) {
    final _ret =
        _lib._objc_msgSend_45(_id, _lib._sel_initWithUnsignedInteger_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  int get charValue {
    return _lib._objc_msgSend_51(_id, _lib._sel_charValue1);
  }

  int get unsignedCharValue {
    return _lib._objc_msgSend_52(_id, _lib._sel_unsignedCharValue1);
  }

  int get shortValue {
    return _lib._objc_msgSend_53(_id, _lib._sel_shortValue1);
  }

  int get unsignedShortValue {
    return _lib._objc_msgSend_54(_id, _lib._sel_unsignedShortValue1);
  }

  int get intValue {
    return _lib._objc_msgSend_55(_id, _lib._sel_intValue1);
  }

  int get unsignedIntValue {
    return _lib._objc_msgSend_56(_id, _lib._sel_unsignedIntValue1);
  }

  int get longValue {
    return _lib._objc_msgSend_57(_id, _lib._sel_longValue1);
  }

  int get unsignedLongValue {
    return _lib._objc_msgSend_12(_id, _lib._sel_unsignedLongValue1);
  }

  int get longLongValue {
    return _lib._objc_msgSend_58(_id, _lib._sel_longLongValue1);
  }

  int get unsignedLongLongValue {
    return _lib._objc_msgSend_59(_id, _lib._sel_unsignedLongLongValue1);
  }

  double get floatValue {
    return _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_60_fpret(_id, _lib._sel_floatValue1)
        : _lib._objc_msgSend_60(_id, _lib._sel_floatValue1);
  }

  double get doubleValue {
    return _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_61_fpret(_id, _lib._sel_doubleValue1)
        : _lib._objc_msgSend_61(_id, _lib._sel_doubleValue1);
  }

  bool get boolValue {
    return _lib._objc_msgSend_11(_id, _lib._sel_boolValue1);
  }

  int get integerValue {
    return _lib._objc_msgSend_57(_id, _lib._sel_integerValue1);
  }

  int get unsignedIntegerValue {
    return _lib._objc_msgSend_12(_id, _lib._sel_unsignedIntegerValue1);
  }

  NSString get stringValue {
    final _ret = _lib._objc_msgSend_13(_id, _lib._sel_stringValue1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  int compare_(NSNumber otherNumber) {
    return _lib._objc_msgSend_62(_id, _lib._sel_compare_1, otherNumber._id);
  }

  bool isEqualToNumber_(NSNumber number) {
    return _lib._objc_msgSend_63(_id, _lib._sel_isEqualToNumber_1, number._id);
  }

  NSString descriptionWithLocale_(NSObject? locale) {
    final _ret = _lib._objc_msgSend_64(
        _id, _lib._sel_descriptionWithLocale_1, locale?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSNumber initWithBytes_objCType_(
      ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Char> type) {
    final _ret = _lib._objc_msgSend_36(
        _id, _lib._sel_initWithBytes_objCType_1, value, type);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSNumber init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  static NSNumber new1(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSNumber1, _lib._sel_new1);
    return NSNumber._(_ret, _lib, retain: false, release: true);
  }

  static NSNumber allocWithZone_(Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSNumber1, _lib._sel_allocWithZone_1, zone);
    return NSNumber._(_ret, _lib, retain: false, release: true);
  }

  static NSNumber alloc(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSNumber1, _lib._sel_alloc1);
    return NSNumber._(_ret, _lib, retain: false, release: true);
  }
}

class NSValue extends NSObject {
  NSValue._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSValue] that points to the same underlying object as [other].
  static NSValue castFrom<T extends _ObjCWrapper>(T other) {
    return NSValue._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSValue] that wraps the given raw object pointer.
  static NSValue castFromPointer(Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSValue._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSValue].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSValue1);
  }

  void getValue_size_(ffi.Pointer<ffi.Void> value, int size) {
    _lib._objc_msgSend_34(_id, _lib._sel_getValue_size_1, value, size);
  }

  ffi.Pointer<ffi.Char> get objCType {
    return _lib._objc_msgSend_35(_id, _lib._sel_objCType1);
  }

  NSValue initWithBytes_objCType_(
      ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Char> type) {
    final _ret = _lib._objc_msgSend_36(
        _id, _lib._sel_initWithBytes_objCType_1, value, type);
    return NSValue._(_ret, _lib, retain: true, release: true);
  }

  NSValue? initWithCoder_(NSCoder coder) {
    final _ret =
        _lib._objc_msgSend_37(_id, _lib._sel_initWithCoder_1, coder._id);
    return _ret.address == 0
        ? null
        : NSValue._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSValue init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSValue._(_ret, _lib, retain: true, release: true);
  }

  static NSValue new1(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSValue1, _lib._sel_new1);
    return NSValue._(_ret, _lib, retain: false, release: true);
  }

  static NSValue allocWithZone_(Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSValue1, _lib._sel_allocWithZone_1, zone);
    return NSValue._(_ret, _lib, retain: false, release: true);
  }

  static NSValue alloc(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSValue1, _lib._sel_alloc1);
    return NSValue._(_ret, _lib, retain: false, release: true);
  }
}

class NSCoder extends _ObjCWrapper {
  NSCoder._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSCoder] that points to the same underlying object as [other].
  static NSCoder castFrom<T extends _ObjCWrapper>(T other) {
    return NSCoder._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSCoder] that wraps the given raw object pointer.
  static NSCoder castFromPointer(Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSCoder._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSCoder].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSCoder1);
  }
}

abstract class NSComparisonResult {
  static const int NSOrderedAscending = -1;
  static const int NSOrderedSame = 0;
  static const int NSOrderedDescending = 1;
}

class NSError extends NSObject {
  NSError._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSError] that points to the same underlying object as [other].
  static NSError castFrom<T extends _ObjCWrapper>(T other) {
    return NSError._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSError] that wraps the given raw object pointer.
  static NSError castFromPointer(Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSError._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSError].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSError1);
  }

  /// Domain cannot be nil; dict may be nil if no userInfo desired.
  NSError initWithDomain_code_userInfo_(
      NSString domain, int code, NSDictionary? dict) {
    final _ret = _lib._objc_msgSend_67(
        _id,
        _lib._sel_initWithDomain_code_userInfo_1,
        domain._id,
        code,
        dict?._id ?? ffi.nullptr);
    return NSError._(_ret, _lib, retain: true, release: true);
  }

  static NSError errorWithDomain_code_userInfo_(
      Foundation _lib, NSString domain, int code, NSDictionary? dict) {
    final _ret = _lib._objc_msgSend_67(
        _lib._class_NSError1,
        _lib._sel_errorWithDomain_code_userInfo_1,
        domain._id,
        code,
        dict?._id ?? ffi.nullptr);
    return NSError._(_ret, _lib, retain: true, release: true);
  }

  /// These define the error. Domains are described by names that are arbitrary strings used to differentiate groups of codes; for custom domain using reverse-DNS naming will help avoid conflicts. Codes are domain-specific.
  NSString get domain {
    final _ret = _lib._objc_msgSend_13(_id, _lib._sel_domain1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  int get code {
    return _lib._objc_msgSend_57(_id, _lib._sel_code1);
  }

  /// Additional info which may be used to describe the error further. Examples of keys that might be included in here are "Line Number", "Failed URL", etc. Embedding other errors in here can also be used as a way to communicate underlying reasons for failures; for instance "File System Error" embedded in the userInfo of an NSError returned from a higher level document object. If the embedded error information is itself NSError, the standard key NSUnderlyingErrorKey can be used.
  NSDictionary get userInfo {
    final _ret = _lib._objc_msgSend_68(_id, _lib._sel_userInfo1);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// The primary user-presentable message for the error, for instance for NSFileReadNoPermissionError: "The file "File Name" couldn't be opened because you don't have permission to view it.". This message should ideally indicate what failed and why it failed. This value either comes from NSLocalizedDescriptionKey, or NSLocalizedFailureErrorKey+NSLocalizedFailureReasonErrorKey, or NSLocalizedFailureErrorKey. The steps this takes to construct the description include:
  /// 1. Look for NSLocalizedDescriptionKey in userInfo, use value as-is if present.
  /// 2. Look for NSLocalizedFailureErrorKey in userInfo. If present, use, combining with value for NSLocalizedFailureReasonErrorKey if available.
  /// 3. Fetch NSLocalizedDescriptionKey from userInfoValueProvider, use value as-is if present.
  /// 4. Fetch NSLocalizedFailureErrorKey from userInfoValueProvider. If present, use, combining with value for NSLocalizedFailureReasonErrorKey if available.
  /// 5. Look for NSLocalizedFailureReasonErrorKey in userInfo or from userInfoValueProvider; combine with generic "Operation failed" message.
  /// 6. Last resort localized but barely-presentable string manufactured from domain and code. The result is never nil.
  NSString get localizedDescription {
    final _ret = _lib._objc_msgSend_13(_id, _lib._sel_localizedDescription1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Return a complete sentence which describes why the operation failed. For instance, for NSFileReadNoPermissionError: "You don't have permission.". In many cases this will be just the "because" part of the error message (but as a complete sentence, which makes localization easier).  Default implementation of this picks up the value of NSLocalizedFailureReasonErrorKey from the userInfo dictionary. If not present, it consults the userInfoValueProvider for the domain, and if that returns nil, this also returns nil.
  NSString? get localizedFailureReason {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_localizedFailureReason1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Return the string that can be displayed as the "informative" (aka "secondary") message on an alert panel. For instance, for NSFileReadNoPermissionError: "To view or change permissions, select the item in the Finder and choose File > Get Info.". Default implementation of this picks up the value of NSLocalizedRecoverySuggestionErrorKey from the userInfo dictionary. If not present, it consults the userInfoValueProvider for the domain, and if that returns nil, this also returns nil.
  NSString? get localizedRecoverySuggestion {
    final _ret =
        _lib._objc_msgSend_32(_id, _lib._sel_localizedRecoverySuggestion1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Return titles of buttons that are appropriate for displaying in an alert. These should match the string provided as a part of localizedRecoverySuggestion.  The first string would be the title of the right-most and default button, the second one next to it, and so on. If used in an alert the corresponding default return values are NSAlertFirstButtonReturn + n. Default implementation of this picks up the value of NSLocalizedRecoveryOptionsErrorKey from the userInfo dictionary. If not present, it consults the userInfoValueProvider for the domain, and if that returns nil, this also returns nil. nil return usually implies no special suggestion, which would imply a single "OK" button.
  NSObject? get localizedRecoveryOptions {
    final _ret =
        _lib._objc_msgSend_69(_id, _lib._sel_localizedRecoveryOptions1);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// Return an object that conforms to the NSErrorRecoveryAttempting informal protocol. The recovery attempter must be an object that can correctly interpret an index into the array returned by localizedRecoveryOptions. The default implementation of this picks up the value of NSRecoveryAttempterErrorKey from the userInfo dictionary. If not present, it consults the userInfoValueProvider for the domain. If that returns nil, this also returns nil.
  NSObject? get recoveryAttempter {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_recoveryAttempter1);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// Return the help anchor that can be used to create a help button to accompany the error when it's displayed to the user.  This is done automatically by +[NSAlert alertWithError:], which the presentError: variants in NSApplication go through. The default implementation of this picks up the value of the NSHelpAnchorErrorKey from the userInfo dictionary. If not present, it consults the userInfoValueProvider for the domain.  If that returns nil, this also returns nil.
  NSString? get helpAnchor {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_helpAnchor1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Return a list of underlying errors, if any. It includes the values of both NSUnderlyingErrorKey and NSMultipleUnderlyingErrorsKey. If there are no underlying errors, returns an empty array.
  NSObject get underlyingErrors {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_underlyingErrors1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// Specify a block which will be called from the implementations of localizedDescription, localizedFailureReason, localizedRecoverySuggestion, localizedRecoveryOptions, recoveryAttempter, helpAnchor, and debugDescription when the underlying value for these is not present in the userInfo dictionary of NSError instances with the specified domain.  The provider will be called with the userInfo key corresponding to the queried property: For instance, NSLocalizedDescriptionKey for localizedDescription.  The provider should return nil for any keys it is not able to provide and, very importantly, any keys it does not recognize (since we may extend the list of keys in future releases).
  ///
  /// The specified block will be called synchronously at the time when the above properties are queried. The results are not cached.
  ///
  /// This provider is optional. It enables localization and formatting of error messages to be done lazily; rather than populating the userInfo at NSError creation time, these keys will be fetched on-demand when asked for.
  ///
  /// It is expected that only the “owner” of an NSError domain specifies the provider for the domain, and this is done once. This facility is not meant for consumers of errors to customize the userInfo entries.  This facility should not be used to customize the behaviors of error domains provided by the system.
  ///
  /// If an appropriate result for the requested key cannot be provided, return nil rather than choosing to manufacture a generic fallback response such as "Operation could not be completed, error 42." NSError will take care of the fallback cases.
  static void setUserInfoValueProviderForDomain_provider_(Foundation _lib,
      NSString errorDomain, ObjCBlock_ObjCObject_NSError_NSString? provider) {
    _lib._objc_msgSend_70(
        _lib._class_NSError1,
        _lib._sel_setUserInfoValueProviderForDomain_provider_1,
        errorDomain._id,
        provider?._id ?? ffi.nullptr);
  }

  static ObjCBlock_ObjCObject_NSError_NSString? userInfoValueProviderForDomain_(
      Foundation _lib,
      NSError err,
      NSString userInfoKey,
      NSString errorDomain) {
    final _ret = _lib._objc_msgSend_71(
        _lib._class_NSError1,
        _lib._sel_userInfoValueProviderForDomain_1,
        err._id,
        userInfoKey._id,
        errorDomain._id);
    return _ret.address == 0
        ? null
        : ObjCBlock_ObjCObject_NSError_NSString._(_ret, _lib,
            retain: true, release: true);
  }

  @override
  NSError init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSError._(_ret, _lib, retain: true, release: true);
  }

  static NSError new1(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSError1, _lib._sel_new1);
    return NSError._(_ret, _lib, retain: false, release: true);
  }

  static NSError allocWithZone_(Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSError1, _lib._sel_allocWithZone_1, zone);
    return NSError._(_ret, _lib, retain: false, release: true);
  }

  static NSError alloc(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSError1, _lib._sel_alloc1);
    return NSError._(_ret, _lib, retain: false, release: true);
  }
}

class NSDictionary extends _ObjCWrapper {
  NSDictionary._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSDictionary] that points to the same underlying object as [other].
  static NSDictionary castFrom<T extends _ObjCWrapper>(T other) {
    return NSDictionary._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSDictionary] that wraps the given raw object pointer.
  static NSDictionary castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSDictionary._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSDictionary].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSDictionary1);
  }
}

class _ObjCBlockBase implements ffi.Finalizable {
  final ffi.Pointer<_ObjCBlock> _id;
  final Foundation _lib;
  bool _pendingRelease;

  _ObjCBlockBase._(this._id, this._lib,
      {bool retain = false, bool release = false})
      : _pendingRelease = release {
    if (retain) {
      _lib._Block_copy(_id.cast());
    }
    if (release) {
      _lib._objc_releaseFinalizer11.attach(this, _id.cast(), detach: this);
    }
  }

  /// Releases the reference to the underlying ObjC block held by this wrapper.
  /// Throws a StateError if this wrapper doesn't currently hold a reference.
  void release() {
    if (_pendingRelease) {
      _pendingRelease = false;
      _lib._Block_release(_id.cast());
      _lib._objc_releaseFinalizer11.detach(this);
    } else {
      throw StateError(
          'Released an ObjC block that was unowned or already released.');
    }
  }

  @override
  bool operator ==(Object other) {
    return other is _ObjCBlockBase && _id == other._id;
  }

  @override
  int get hashCode => _id.hashCode;

  /// Return a pointer to this object.
  ffi.Pointer<_ObjCBlock> get pointer => _id;

  ffi.Pointer<_ObjCBlock> _retainAndReturnId() {
    _lib._Block_copy(_id.cast());
    return _id;
  }
}

ffi.Pointer<ObjCObject> _ObjCBlock_ObjCObject_NSError_NSString_fnPtrTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        ffi.Pointer<ObjCObject> arg0,
        ffi.Pointer<ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject> arg0,
                    ffi.Pointer<ObjCObject> arg1)>>()
        .asFunction<
            ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
                ffi.Pointer<ObjCObject>)>()(arg0, arg1);
final _ObjCBlock_ObjCObject_NSError_NSString_closureRegistry = <int,
    ffi.Pointer<ObjCObject> Function(
        ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>{};
int _ObjCBlock_ObjCObject_NSError_NSString_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock_ObjCObject_NSError_NSString_registerClosure(
    ffi.Pointer<ObjCObject> Function(
            ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)
        fn) {
  final id = ++_ObjCBlock_ObjCObject_NSError_NSString_closureRegistryIndex;
  _ObjCBlock_ObjCObject_NSError_NSString_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

ffi.Pointer<ObjCObject>
    _ObjCBlock_ObjCObject_NSError_NSString_closureTrampoline(
            ffi.Pointer<_ObjCBlock> block,
            ffi.Pointer<ObjCObject> arg0,
            ffi.Pointer<ObjCObject> arg1) =>
        _ObjCBlock_ObjCObject_NSError_NSString_closureRegistry[
            block.ref.target.address]!(arg0, arg1);

class ObjCBlock_ObjCObject_NSError_NSString extends _ObjCBlockBase {
  ObjCBlock_ObjCObject_NSError_NSString._(
      ffi.Pointer<_ObjCBlock> id, Foundation lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ObjCObject_NSError_NSString.fromFunctionPointer(
      Foundation lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject> arg0,
                      ffi.Pointer<ObjCObject> arg1)>>
          ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Pointer<ObjCObject> Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ObjCObject>,
                                ffi.Pointer<ObjCObject>)>(
                        _ObjCBlock_ObjCObject_NSError_NSString_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ObjCObject_NSError_NSString.fromFunction(
      Foundation lib, NSObject? Function(NSError, NSString) fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Pointer<ObjCObject> Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ObjCObject>,
                                ffi.Pointer<ObjCObject>)>(
                        _ObjCBlock_ObjCObject_NSError_NSString_closureTrampoline)
                    .cast(),
                _ObjCBlock_ObjCObject_NSError_NSString_registerClosure(
                    (ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1) =>
                        fn(NSError._(arg0, lib, retain: true, release: true), NSString._(arg1, lib, retain: true, release: true))
                            ?._retainAndReturnId() ??
                        ffi.nullptr)),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  NSObject? call(NSError arg0, NSString arg1) => _id.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<ObjCObject> Function(
                          ffi.Pointer<_ObjCBlock> block,
                          ffi.Pointer<ObjCObject> arg0,
                          ffi.Pointer<ObjCObject> arg1)>>()
              .asFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<_ObjCBlock>, ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>()
              (_id, arg0._id, arg1._id)
              .address ==
          0
      ? null
      : NSObject._(
          _id.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1)>>()
              .asFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<_ObjCBlock>, ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>()(_id, arg0._id, arg1._id),
          _lib,
          retain: false,
          release: true);
}

final class _ObjCBlockDesc extends ffi.Struct {
  @ffi.UnsignedLong()
  external int reserved;

  @ffi.UnsignedLong()
  external int size;

  external ffi.Pointer<ffi.Void> copy_helper;

  external ffi.Pointer<ffi.Void> dispose_helper;

  external ffi.Pointer<ffi.Char> signature;
}

final class _ObjCBlock extends ffi.Struct {
  external ffi.Pointer<ffi.Void> isa;

  @ffi.Int()
  external int flags;

  @ffi.Int()
  external int reserved;

  external ffi.Pointer<ffi.Void> invoke;

  external ffi.Pointer<_ObjCBlockDesc> descriptor;

  external ffi.Pointer<ffi.Void> target;
}

/// Working with Bookmarks and alias (bookmark) files
abstract class NSURLBookmarkCreationOptions {
  /// This option does nothing and has no effect on bookmark resolution
  static const int NSURLBookmarkCreationPreferFileIDResolution = 256;

  /// creates bookmark data with "less" information, which may be smaller but still be able to resolve in certain ways
  static const int NSURLBookmarkCreationMinimalBookmark = 512;

  /// include the properties required by writeBookmarkData:toURL:options: in the bookmark data created
  static const int NSURLBookmarkCreationSuitableForBookmarkFile = 1024;

  /// include information in the bookmark data which allows the same sandboxed process to access the resource after being relaunched
  static const int NSURLBookmarkCreationWithSecurityScope = 2048;

  /// if used with kCFURLBookmarkCreationWithSecurityScope, at resolution time only read access to the resource will be granted
  static const int NSURLBookmarkCreationSecurityScopeAllowOnlyReadAccess = 4096;

  /// Disable automatic embedding of an implicit security scope. The resolving process will not be able gain access to the resource by security scope, either implicitly or explicitly, through the returned URL. Not applicable to security-scoped bookmarks.
  static const int NSURLBookmarkCreationWithoutImplicitSecurityScope =
      536870912;
}

abstract class NSURLBookmarkResolutionOptions {
  /// don't perform any user interaction during bookmark resolution
  static const int NSURLBookmarkResolutionWithoutUI = 256;

  /// don't mount a volume during bookmark resolution
  static const int NSURLBookmarkResolutionWithoutMounting = 512;

  /// use the secure information included at creation time to provide the ability to access the resource in a sandboxed process
  static const int NSURLBookmarkResolutionWithSecurityScope = 1024;

  /// Disable implicitly starting access of the ephemeral security-scoped resource during resolution. Instead, call `-[NSURL startAccessingSecurityScopedResource]` on the returned URL when ready to use the resource. Not applicable to security-scoped bookmarks.
  static const int NSURLBookmarkResolutionWithoutImplicitStartAccessing = 32768;
}

class NSURLHandle extends NSObject {
  NSURLHandle._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLHandle] that points to the same underlying object as [other].
  static NSURLHandle castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLHandle._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLHandle] that wraps the given raw object pointer.
  static NSURLHandle castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLHandle._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLHandle].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURLHandle1);
  }

  static void registerURLHandleClass_(
      Foundation _lib, NSObject anURLHandleSubclass) {
    _lib._objc_msgSend_92(_lib._class_NSURLHandle1,
        _lib._sel_registerURLHandleClass_1, anURLHandleSubclass._id);
  }

  static NSObject URLHandleClassForURL_(Foundation _lib, NSURL anURL) {
    final _ret = _lib._objc_msgSend_93(
        _lib._class_NSURLHandle1, _lib._sel_URLHandleClassForURL_1, anURL._id);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  int status() {
    return _lib._objc_msgSend_94(_id, _lib._sel_status1);
  }

  NSString failureReason() {
    final _ret = _lib._objc_msgSend_13(_id, _lib._sel_failureReason1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  void addClient_(NSObject client) {
    _lib._objc_msgSend_92(_id, _lib._sel_addClient_1, client._id);
  }

  void removeClient_(NSObject client) {
    _lib._objc_msgSend_92(_id, _lib._sel_removeClient_1, client._id);
  }

  void loadInBackground() {
    _lib._objc_msgSend_1(_id, _lib._sel_loadInBackground1);
  }

  void cancelLoadInBackground() {
    _lib._objc_msgSend_1(_id, _lib._sel_cancelLoadInBackground1);
  }

  NSData resourceData() {
    final _ret = _lib._objc_msgSend_31(_id, _lib._sel_resourceData1);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSData availableResourceData() {
    final _ret = _lib._objc_msgSend_31(_id, _lib._sel_availableResourceData1);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  int expectedResourceDataSize() {
    return _lib._objc_msgSend_58(_id, _lib._sel_expectedResourceDataSize1);
  }

  void flushCachedData() {
    _lib._objc_msgSend_1(_id, _lib._sel_flushCachedData1);
  }

  void backgroundLoadDidFailWithReason_(NSString reason) {
    _lib._objc_msgSend_76(
        _id, _lib._sel_backgroundLoadDidFailWithReason_1, reason._id);
  }

  void didLoadBytes_loadComplete_(NSData newBytes, bool yorn) {
    _lib._objc_msgSend_95(
        _id, _lib._sel_didLoadBytes_loadComplete_1, newBytes._id, yorn);
  }

  static bool canInitWithURL_(Foundation _lib, NSURL anURL) {
    return _lib._objc_msgSend_96(
        _lib._class_NSURLHandle1, _lib._sel_canInitWithURL_1, anURL._id);
  }

  static NSURLHandle cachedHandleForURL_(Foundation _lib, NSURL anURL) {
    final _ret = _lib._objc_msgSend_97(
        _lib._class_NSURLHandle1, _lib._sel_cachedHandleForURL_1, anURL._id);
    return NSURLHandle._(_ret, _lib, retain: true, release: true);
  }

  NSObject initWithURL_cached_(NSURL anURL, bool willCache) {
    final _ret = _lib._objc_msgSend_98(
        _id, _lib._sel_initWithURL_cached_1, anURL._id, willCache);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSObject propertyForKey_(NSString propertyKey) {
    final _ret =
        _lib._objc_msgSend_18(_id, _lib._sel_propertyForKey_1, propertyKey._id);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSObject propertyForKeyIfAvailable_(NSString propertyKey) {
    final _ret = _lib._objc_msgSend_18(
        _id, _lib._sel_propertyForKeyIfAvailable_1, propertyKey._id);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  bool writeProperty_forKey_(NSObject propertyValue, NSString propertyKey) {
    return _lib._objc_msgSend_91(_id, _lib._sel_writeProperty_forKey_1,
        propertyValue._id, propertyKey._id);
  }

  bool writeData_(NSData data) {
    return _lib._objc_msgSend_90(_id, _lib._sel_writeData_1, data._id);
  }

  NSData loadInForeground() {
    final _ret = _lib._objc_msgSend_31(_id, _lib._sel_loadInForeground1);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  void beginLoadInBackground() {
    _lib._objc_msgSend_1(_id, _lib._sel_beginLoadInBackground1);
  }

  void endLoadInBackground() {
    _lib._objc_msgSend_1(_id, _lib._sel_endLoadInBackground1);
  }

  @override
  NSURLHandle init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLHandle._(_ret, _lib, retain: true, release: true);
  }

  static NSURLHandle new1(Foundation _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSURLHandle1, _lib._sel_new1);
    return NSURLHandle._(_ret, _lib, retain: false, release: true);
  }

  static NSURLHandle allocWithZone_(Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSURLHandle1, _lib._sel_allocWithZone_1, zone);
    return NSURLHandle._(_ret, _lib, retain: false, release: true);
  }

  static NSURLHandle alloc(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLHandle1, _lib._sel_alloc1);
    return NSURLHandle._(_ret, _lib, retain: false, release: true);
  }
}

abstract class NSURLHandleStatus {
  static const int NSURLHandleNotLoaded = 0;
  static const int NSURLHandleLoadSucceeded = 1;
  static const int NSURLHandleLoadInProgress = 2;
  static const int NSURLHandleLoadFailed = 3;
}

final class NSRange extends ffi.Struct {
  @ffi.UnsignedLong()
  external int location;

  @ffi.UnsignedLong()
  external int length;
}

/// These options apply to the various search/find and comparison methods (except where noted).
abstract class NSStringCompareOptions {
  static const int NSCaseInsensitiveSearch = 1;

  /// Exact character-by-character equivalence
  static const int NSLiteralSearch = 2;

  /// Search from end of source string
  static const int NSBackwardsSearch = 4;

  /// Search is limited to start (or end, if NSBackwardsSearch) of source string
  static const int NSAnchoredSearch = 8;

  /// Added in 10.2; Numbers within strings are compared using numeric value, that is, Foo2.txt < Foo7.txt < Foo25.txt; only applies to compare methods, not find
  static const int NSNumericSearch = 64;

  /// If specified, ignores diacritics (o-umlaut == o)
  static const int NSDiacriticInsensitiveSearch = 128;

  /// If specified, ignores width differences ('a' == UFF41)
  static const int NSWidthInsensitiveSearch = 256;

  /// If specified, comparisons are forced to return either NSOrderedAscending or NSOrderedDescending if the strings are equivalent but not strictly equal, for stability when sorting (e.g. "aaa" > "AAA" with NSCaseInsensitiveSearch specified)
  static const int NSForcedOrderingSearch = 512;

  /// Applies to rangeOfString:..., stringByReplacingOccurrencesOfString:..., and replaceOccurrencesOfString:... methods only; the search string is treated as an ICU-compatible regular expression; if set, no other options can apply except NSCaseInsensitiveSearch and NSAnchoredSearch
  static const int NSRegularExpressionSearch = 1024;
}

class NSLocale extends _ObjCWrapper {
  NSLocale._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSLocale] that points to the same underlying object as [other].
  static NSLocale castFrom<T extends _ObjCWrapper>(T other) {
    return NSLocale._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSLocale] that wraps the given raw object pointer.
  static NSLocale castFromPointer(Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSLocale._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSLocale].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSLocale1);
  }
}

class NSCharacterSet extends NSObject {
  NSCharacterSet._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSCharacterSet] that points to the same underlying object as [other].
  static NSCharacterSet castFrom<T extends _ObjCWrapper>(T other) {
    return NSCharacterSet._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSCharacterSet] that wraps the given raw object pointer.
  static NSCharacterSet castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSCharacterSet._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSCharacterSet].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSCharacterSet1);
  }

  static NSCharacterSet getControlCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_controlCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getWhitespaceCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_whitespaceCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getWhitespaceAndNewlineCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(_lib._class_NSCharacterSet1,
        _lib._sel_whitespaceAndNewlineCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getDecimalDigitCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_decimalDigitCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getLetterCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_letterCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getLowercaseLetterCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_lowercaseLetterCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getUppercaseLetterCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_uppercaseLetterCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getNonBaseCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_nonBaseCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getAlphanumericCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_alphanumericCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getDecomposableCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_decomposableCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getIllegalCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_illegalCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getPunctuationCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_punctuationCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getCapitalizedLetterCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_capitalizedLetterCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getSymbolCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_symbolCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet getNewlineCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_newlineCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: false, release: true);
  }

  static NSCharacterSet characterSetWithRange_(
      Foundation _lib, NSRange aRange) {
    final _ret = _lib._objc_msgSend_120(
        _lib._class_NSCharacterSet1, _lib._sel_characterSetWithRange_1, aRange);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet characterSetWithCharactersInString_(
      Foundation _lib, NSString aString) {
    final _ret = _lib._objc_msgSend_121(_lib._class_NSCharacterSet1,
        _lib._sel_characterSetWithCharactersInString_1, aString._id);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet characterSetWithBitmapRepresentation_(
      Foundation _lib, NSData data) {
    final _ret = _lib._objc_msgSend_122(_lib._class_NSCharacterSet1,
        _lib._sel_characterSetWithBitmapRepresentation_1, data._id);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? characterSetWithContentsOfFile_(
      Foundation _lib, NSString fName) {
    final _ret = _lib._objc_msgSend_123(_lib._class_NSCharacterSet1,
        _lib._sel_characterSetWithContentsOfFile_1, fName._id);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  NSCharacterSet initWithCoder_(NSCoder coder) {
    final _ret =
        _lib._objc_msgSend_124(_id, _lib._sel_initWithCoder_1, coder._id);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  bool characterIsMember_(int aCharacter) {
    return _lib._objc_msgSend_125(
        _id, _lib._sel_characterIsMember_1, aCharacter);
  }

  NSData get bitmapRepresentation {
    final _ret = _lib._objc_msgSend_31(_id, _lib._sel_bitmapRepresentation1);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSCharacterSet get invertedSet {
    final _ret = _lib._objc_msgSend_119(_id, _lib._sel_invertedSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  bool longCharacterIsMember_(int theLongChar) {
    return _lib._objc_msgSend_126(
        _id, _lib._sel_longCharacterIsMember_1, theLongChar);
  }

  bool isSupersetOfSet_(NSCharacterSet theOtherSet) {
    return _lib._objc_msgSend_127(
        _id, _lib._sel_isSupersetOfSet_1, theOtherSet._id);
  }

  bool hasMemberInPlane_(int thePlane) {
    return _lib._objc_msgSend_128(_id, _lib._sel_hasMemberInPlane_1, thePlane);
  }

  /// Returns a character set containing the characters allowed in a URL's user subcomponent.
  static NSCharacterSet getURLUserAllowedCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_URLUserAllowedCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in a URL's password subcomponent.
  static NSCharacterSet getURLPasswordAllowedCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_URLPasswordAllowedCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in a URL's host subcomponent.
  static NSCharacterSet getURLHostAllowedCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_URLHostAllowedCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in a URL's path component. ';' is a legal path character, but it is recommended that it be percent-encoded for best compatibility with NSURL (-stringByAddingPercentEncodingWithAllowedCharacters: will percent-encode any ';' characters if you pass the URLPathAllowedCharacterSet).
  static NSCharacterSet getURLPathAllowedCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_URLPathAllowedCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in a URL's query component.
  static NSCharacterSet getURLQueryAllowedCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_URLQueryAllowedCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in a URL's fragment component.
  static NSCharacterSet getURLFragmentAllowedCharacterSet(Foundation _lib) {
    final _ret = _lib._objc_msgSend_119(
        _lib._class_NSCharacterSet1, _lib._sel_URLFragmentAllowedCharacterSet1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSCharacterSet init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet new1(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSCharacterSet1, _lib._sel_new1);
    return NSCharacterSet._(_ret, _lib, retain: false, release: true);
  }

  static NSCharacterSet allocWithZone_(
      Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSCharacterSet1, _lib._sel_allocWithZone_1, zone);
    return NSCharacterSet._(_ret, _lib, retain: false, release: true);
  }

  static NSCharacterSet alloc(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSCharacterSet1, _lib._sel_alloc1);
    return NSCharacterSet._(_ret, _lib, retain: false, release: true);
  }
}

abstract class NSStringEnumerationOptions {
  /// Equivalent to lineRangeForRange:
  static const int NSStringEnumerationByLines = 0;

  /// Equivalent to paragraphRangeForRange:
  static const int NSStringEnumerationByParagraphs = 1;

  /// Equivalent to rangeOfComposedCharacterSequencesForRange:
  static const int NSStringEnumerationByComposedCharacterSequences = 2;
  static const int NSStringEnumerationByWords = 3;
  static const int NSStringEnumerationBySentences = 4;

  /// Enumerate text editing cursor positions. It could separate characters within a grapheme cluster.
  static const int NSStringEnumerationByCaretPositions = 5;

  /// Enumerate text editing positions for backwards deletion. It could separate characters within a grapheme cluster.
  static const int NSStringEnumerationByDeletionClusters = 6;

  /// ...and combine any of the desired additional options:
  static const int NSStringEnumerationReverse = 256;
  static const int NSStringEnumerationSubstringNotRequired = 512;

  /// User's default locale
  static const int NSStringEnumerationLocalized = 1024;
}

void _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_fnPtrTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        ffi.Pointer<ObjCObject> arg0,
        NSRange arg1,
        NSRange arg2,
        ffi.Pointer<ffi.Bool> arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ObjCObject> arg0, NSRange arg1,
                    NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>>()
        .asFunction<
            void Function(ffi.Pointer<ObjCObject>, NSRange, NSRange,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1, arg2, arg3);
final _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureRegistry = <int,
    void Function(
        ffi.Pointer<ObjCObject>, NSRange, NSRange, ffi.Pointer<ffi.Bool>)>{};
int _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_registerClosure(
        void Function(ffi.Pointer<ObjCObject>, NSRange, NSRange,
                ffi.Pointer<ffi.Bool>)
            fn) {
  final id =
      ++_ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureRegistryIndex;
  _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        ffi.Pointer<ObjCObject> arg0,
        NSRange arg1,
        NSRange arg2,
        ffi.Pointer<ffi.Bool> arg3) =>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureRegistry[
        block.ref.target.address]!(arg0, arg1, arg2, arg3);

class ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool extends _ObjCBlockBase {
  ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool._(
      ffi.Pointer<_ObjCBlock> id, Foundation lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool.fromFunctionPointer(
      Foundation lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ObjCObject> arg0, NSRange arg1,
                      NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>>
          ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ObjCObject>,
                                NSRange,
                                NSRange,
                                ffi.Pointer<ffi.Bool>)>(
                        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool.fromFunction(Foundation lib,
      void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>) fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ObjCObject>,
                                NSRange,
                                NSRange,
                                ffi.Pointer<ffi.Bool>)>(
                        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureTrampoline)
                    .cast(),
                _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_registerClosure(
                    (ffi.Pointer<ObjCObject> arg0, NSRange arg1, NSRange arg2,
                            ffi.Pointer<ffi.Bool> arg3) =>
                        fn(arg0.address == 0 ? null : NSString._(arg0, lib, retain: true, release: true), arg1, arg2, arg3))),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool.listener(Foundation lib,
      void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>) fn)
      : this._(
            lib._newBlock1(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ObjCObject>,
                                NSRange,
                                NSRange,
                                ffi.Pointer<ffi.Bool>)>.listener(
                        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_registerClosure(
                    (ffi.Pointer<ObjCObject> arg0, NSRange arg1, NSRange arg2,
                            ffi.Pointer<ffi.Bool> arg3) =>
                        fn(arg0.address == 0 ? null : NSString._(arg0, lib, retain: true, release: true), arg1, arg2, arg3))),
            lib);
  static ffi.NativeCallable<
      ffi.Void Function(
          ffi.Pointer<_ObjCBlock>,
          ffi.Pointer<ObjCObject>,
          NSRange,
          NSRange,
          ffi.Pointer<ffi.Bool>)>? _dartFuncListenerTrampoline;

  void call(NSString? arg0, NSRange arg1, NSRange arg2,
          ffi.Pointer<ffi.Bool> arg3) =>
      _id.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<_ObjCBlock> block,
                          ffi.Pointer<ObjCObject> arg0,
                          NSRange arg1,
                          NSRange arg2,
                          ffi.Pointer<ffi.Bool> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<_ObjCBlock>,
                      ffi.Pointer<ObjCObject>,
                      NSRange,
                      NSRange,
                      ffi.Pointer<ffi.Bool>)>()(
          _id, arg0?._id ?? ffi.nullptr, arg1, arg2, arg3);
}

void _ObjCBlock_ffiVoid_NSString_bool_fnPtrTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        ffi.Pointer<ObjCObject> arg0,
        ffi.Pointer<ffi.Bool> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ObjCObject> arg0,
                    ffi.Pointer<ffi.Bool> arg1)>>()
        .asFunction<
            void Function(
                ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Bool>)>()(arg0, arg1);
final _ObjCBlock_ffiVoid_NSString_bool_closureRegistry =
    <int, void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Bool>)>{};
int _ObjCBlock_ffiVoid_NSString_bool_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSString_bool_registerClosure(
    void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Bool>) fn) {
  final id = ++_ObjCBlock_ffiVoid_NSString_bool_closureRegistryIndex;
  _ObjCBlock_ffiVoid_NSString_bool_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock_ffiVoid_NSString_bool_closureTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        ffi.Pointer<ObjCObject> arg0,
        ffi.Pointer<ffi.Bool> arg1) =>
    _ObjCBlock_ffiVoid_NSString_bool_closureRegistry[block.ref.target.address]!(
        arg0, arg1);

class ObjCBlock_ffiVoid_NSString_bool extends _ObjCBlockBase {
  ObjCBlock_ffiVoid_NSString_bool._(ffi.Pointer<_ObjCBlock> id, Foundation lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSString_bool.fromFunctionPointer(
      Foundation lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ObjCObject> arg0,
                      ffi.Pointer<ffi.Bool> arg1)>>
          ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ObjCObject>,
                                ffi.Pointer<ffi.Bool>)>(
                        _ObjCBlock_ffiVoid_NSString_bool_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_NSString_bool.fromFunction(
      Foundation lib, void Function(NSString, ffi.Pointer<ffi.Bool>) fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ObjCObject>,
                                ffi.Pointer<ffi.Bool>)>(
                        _ObjCBlock_ffiVoid_NSString_bool_closureTrampoline)
                    .cast(),
                _ObjCBlock_ffiVoid_NSString_bool_registerClosure(
                    (ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
                        NSString._(arg0, lib, retain: true, release: true),
                        arg1))),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_NSString_bool.listener(
      Foundation lib, void Function(NSString, ffi.Pointer<ffi.Bool>) fn)
      : this._(
            lib._newBlock1(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ObjCObject>,
                                ffi.Pointer<ffi.Bool>)>.listener(
                        _ObjCBlock_ffiVoid_NSString_bool_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                _ObjCBlock_ffiVoid_NSString_bool_registerClosure(
                    (ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) =>
                        fn(NSString._(arg0, lib, retain: true, release: true),
                            arg1))),
            lib);
  static ffi.NativeCallable<
      ffi.Void Function(ffi.Pointer<_ObjCBlock>, ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Bool>)>? _dartFuncListenerTrampoline;

  void call(NSString arg0, ffi.Pointer<ffi.Bool> arg1) => _id.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                  ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<_ObjCBlock>, ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Bool>)>()(_id, arg0._id, arg1);
}

abstract class NSStringEncodingConversionOptions {
  static const int NSStringEncodingConversionAllowLossy = 1;
  static const int NSStringEncodingConversionExternalRepresentation = 2;
}

void _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_fnPtrTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        ffi.Pointer<ffi.UnsignedShort> arg0,
        int arg1) =>
    block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(ffi.Pointer<ffi.UnsignedShort> arg0,
                        ffi.UnsignedLong arg1)>>()
            .asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>, int)>()(
        arg0, arg1);
final _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_closureRegistry =
    <int, void Function(ffi.Pointer<ffi.UnsignedShort>, int)>{};
int _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_closureRegistryIndex =
    0;
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_registerClosure(
        void Function(ffi.Pointer<ffi.UnsignedShort>, int) fn) {
  final id =
      ++_ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_closureRegistryIndex;
  _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_closureTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        ffi.Pointer<ffi.UnsignedShort> arg0,
        int arg1) =>
    _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_closureRegistry[
        block.ref.target.address]!(arg0, arg1);

class ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong
    extends _ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong._(
      ffi.Pointer<_ObjCBlock> id, Foundation lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong.fromFunctionPointer(
      Foundation lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.UnsignedShort> arg0,
                      ffi.UnsignedLong arg1)>>
          ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ffi.UnsignedShort>,
                                ffi.UnsignedLong)>(
                        _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong.fromFunction(
      Foundation lib, void Function(ffi.Pointer<ffi.UnsignedShort>, int) fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ffi.UnsignedShort>,
                                ffi.UnsignedLong)>(
                        _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_closureTrampoline)
                    .cast(),
                _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_registerClosure(
                    (ffi.Pointer<ffi.UnsignedShort> arg0, int arg1) =>
                        fn(arg0, arg1))),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong.listener(
      Foundation lib, void Function(ffi.Pointer<ffi.UnsignedShort>, int) fn)
      : this._(
            lib._newBlock1(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ffi.UnsignedShort>,
                                ffi.UnsignedLong)>.listener(
                        _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                _ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong_registerClosure(
                    (ffi.Pointer<ffi.UnsignedShort> arg0, int arg1) =>
                        fn(arg0, arg1))),
            lib);
  static ffi.NativeCallable<
      ffi.Void Function(ffi.Pointer<_ObjCBlock>, ffi.Pointer<ffi.UnsignedShort>,
          ffi.UnsignedLong)>? _dartFuncListenerTrampoline;

  void call(ffi.Pointer<ffi.UnsignedShort> arg0, int arg1) => _id.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<_ObjCBlock> block,
                  ffi.Pointer<ffi.UnsignedShort> arg0,
                  ffi.UnsignedLong arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<_ObjCBlock>, ffi.Pointer<ffi.UnsignedShort>,
              int)>()(_id, arg0, arg1);
}

void _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_fnPtrTrampoline(
        ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ffi.Void> arg0, int arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
final _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_closureRegistry =
    <int, void Function(ffi.Pointer<ffi.Void>, int)>{};
int _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_registerClosure(
        void Function(ffi.Pointer<ffi.Void>, int) fn) {
  final id = ++_ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_closureRegistryIndex;
  _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_closureTrampoline(
        ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ffi.Void> arg0, int arg1) =>
    _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_closureRegistry[
        block.ref.target.address]!(arg0, arg1);

class ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong extends _ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong._(
      ffi.Pointer<_ObjCBlock> id, Foundation lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong.fromFunctionPointer(
      Foundation lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)>>
          ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(
                        _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong.fromFunction(
      Foundation lib, void Function(ffi.Pointer<ffi.Void>, int) fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(
                        _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_closureTrampoline)
                    .cast(),
                _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_registerClosure(
                    (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1))),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong.listener(
      Foundation lib, void Function(ffi.Pointer<ffi.Void>, int) fn)
      : this._(
            lib._newBlock1(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>,
                                ffi.Pointer<ffi.Void>,
                                ffi.UnsignedLong)>.listener(
                        _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                _ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong_registerClosure(
                    (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1))),
            lib);
  static ffi.NativeCallable<
      ffi.Void Function(ffi.Pointer<_ObjCBlock>, ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong)>? _dartFuncListenerTrampoline;

  void call(ffi.Pointer<ffi.Void> arg0, int arg1) => _id.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                  ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<_ObjCBlock>, ffi.Pointer<ffi.Void>,
              int)>()(_id, arg0, arg1);
}

class NSMutableString extends NSString {
  NSMutableString._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSMutableString] that points to the same underlying object as [other].
  static NSMutableString castFrom<T extends _ObjCWrapper>(T other) {
    return NSMutableString._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSMutableString] that wraps the given raw object pointer.
  static NSMutableString castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSMutableString._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSMutableString].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSMutableString1);
  }

  /// NSMutableString primitive (funnel) method. See below for the other mutation methods.
  void replaceCharactersInRange_withString_(NSRange range, NSString aString) {
    _lib._objc_msgSend_189(_id, _lib._sel_replaceCharactersInRange_withString_1,
        range, aString._id);
  }

  /// Additional mutation methods.  For subclassers these are all available implemented in terms of the primitive replaceCharactersInRange:range: method.
  void insertString_atIndex_(NSString aString, int loc) {
    _lib._objc_msgSend_190(
        _id, _lib._sel_insertString_atIndex_1, aString._id, loc);
  }

  void deleteCharactersInRange_(NSRange range) {
    _lib._objc_msgSend_191(_id, _lib._sel_deleteCharactersInRange_1, range);
  }

  void appendString_(NSString aString) {
    _lib._objc_msgSend_76(_id, _lib._sel_appendString_1, aString._id);
  }

  void appendFormat_(NSString format) {
    _lib._objc_msgSend_76(_id, _lib._sel_appendFormat_1, format._id);
  }

  void setString_(NSString aString) {
    _lib._objc_msgSend_76(_id, _lib._sel_setString_1, aString._id);
  }

  /// This method replaces all occurrences of the target string with the replacement string, in the specified range of the receiver string, and returns the number of replacements. NSBackwardsSearch means the search is done from the end of the range (the results could be different); NSAnchoredSearch means only anchored (but potentially multiple) instances will be replaced. NSLiteralSearch and NSCaseInsensitiveSearch also apply. NSNumericSearch is ignored. Use NSMakeRange(0, [receiver length]) to process whole string. If NSRegularExpressionSearch is specified, the replacement is treated as a template, as in the corresponding NSRegularExpression methods, and no other options can apply except NSCaseInsensitiveSearch and NSAnchoredSearch.
  int replaceOccurrencesOfString_withString_options_range_(
      NSString target, NSString replacement, int options, NSRange searchRange) {
    return _lib._objc_msgSend_192(
        _id,
        _lib._sel_replaceOccurrencesOfString_withString_options_range_1,
        target._id,
        replacement._id,
        options,
        searchRange);
  }

  /// Perform string transliteration.  The transformation represented by transform is applied to the given range of string in place. Only the specified range will be modified, but the transform may look at portions of the string outside that range for context. If supplied, resultingRange is modified to reflect the new range corresponding to the original range. reverse indicates that the inverse transform should be used instead, if it exists. Attempting to use an invalid transform identifier or reverse an irreversible transform will return NO; otherwise YES is returned, even if no characters are actually transformed. You can pass one of the predefined transforms listed above (NSStringTransformLatinToKatakana, etc), or any valid ICU transform ID as defined in the ICU User Guide. Arbitrary ICU transform rules are not supported.
  bool applyTransform_reverse_range_updatedRange_(NSString transform,
      bool reverse, NSRange range, ffi.Pointer<NSRange> resultingRange) {
    return _lib._objc_msgSend_193(
        _id,
        _lib._sel_applyTransform_reverse_range_updatedRange_1,
        transform._id,
        reverse,
        range,
        resultingRange);
  }

  /// In addition to these two, NSMutableString responds properly to all NSString creation methods.
  NSMutableString initWithCapacity_(int capacity) {
    final _ret =
        _lib._objc_msgSend_194(_id, _lib._sel_initWithCapacity_1, capacity);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString stringWithCapacity_(Foundation _lib, int capacity) {
    final _ret = _lib._objc_msgSend_194(
        _lib._class_NSMutableString1, _lib._sel_stringWithCapacity_1, capacity);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  /// The initializers available to subclasses. See further below for additional init methods.
  @override
  NSMutableString init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString? initWithCoder_(NSCoder coder) {
    final _ret =
        _lib._objc_msgSend_37(_id, _lib._sel_initWithCoder_1, coder._id);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static ffi.Pointer<ffi.UnsignedLong> getAvailableStringEncodings(
      Foundation _lib) {
    return _lib._objc_msgSend_146(
        _lib._class_NSMutableString1, _lib._sel_availableStringEncodings1);
  }

  static NSString localizedNameOfStringEncoding_(
      Foundation _lib, int encoding) {
    final _ret = _lib._objc_msgSend_106(_lib._class_NSMutableString1,
        _lib._sel_localizedNameOfStringEncoding_1, encoding);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Should be rarely used
  static int getDefaultCStringEncoding(Foundation _lib) {
    return _lib._objc_msgSend_12(
        _lib._class_NSMutableString1, _lib._sel_defaultCStringEncoding1);
  }

  /// "NoCopy" is a hint
  @override
  NSMutableString initWithCharactersNoCopy_length_freeWhenDone_(
      ffi.Pointer<ffi.UnsignedShort> characters, int length, bool freeBuffer) {
    final _ret = _lib._objc_msgSend_157(
        _id,
        _lib._sel_initWithCharactersNoCopy_length_freeWhenDone_1,
        characters,
        length,
        freeBuffer);
    return NSMutableString._(_ret, _lib, retain: false, release: true);
  }

  @override
  NSMutableString initWithCharactersNoCopy_length_deallocator_(
      ffi.Pointer<ffi.UnsignedShort> chars,
      int len,
      ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong? deallocator) {
    final _ret = _lib._objc_msgSend_158(
        _id,
        _lib._sel_initWithCharactersNoCopy_length_deallocator_1,
        chars,
        len,
        deallocator?._id ?? ffi.nullptr);
    return NSMutableString._(_ret, _lib, retain: false, release: true);
  }

  @override
  NSMutableString initWithCharacters_length_(
      ffi.Pointer<ffi.UnsignedShort> characters, int length) {
    final _ret = _lib._objc_msgSend_159(
        _id, _lib._sel_initWithCharacters_length_1, characters, length);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString? initWithUTF8String_(
      ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final _ret = _lib._objc_msgSend_160(
        _id, _lib._sel_initWithUTF8String_1, nullTerminatedCString);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString initWithString_(NSString aString) {
    final _ret =
        _lib._objc_msgSend_18(_id, _lib._sel_initWithString_1, aString._id);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString initWithFormat_(NSString format) {
    final _ret =
        _lib._objc_msgSend_18(_id, _lib._sel_initWithFormat_1, format._id);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString initWithFormat_arguments_(
      NSString format, ffi.Pointer<ffi.Char> argList) {
    final _ret = _lib._objc_msgSend_161(
        _id, _lib._sel_initWithFormat_arguments_1, format._id, argList);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString initWithFormat_locale_(NSString format, NSObject? locale) {
    final _ret = _lib._objc_msgSend_162(_id, _lib._sel_initWithFormat_locale_1,
        format._id, locale?._id ?? ffi.nullptr);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString initWithFormat_locale_arguments_(
      NSString format, NSObject? locale, ffi.Pointer<ffi.Char> argList) {
    final _ret = _lib._objc_msgSend_163(
        _id,
        _lib._sel_initWithFormat_locale_arguments_1,
        format._id,
        locale?._id ?? ffi.nullptr,
        argList);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString? initWithValidatedFormat_validFormatSpecifiers_error_(
      NSString format,
      NSString validFormatSpecifiers,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString? initWithValidatedFormat_validFormatSpecifiers_locale_error_(
      NSString format,
      NSString validFormatSpecifiers,
      NSObject? locale,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_165(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_locale_error_1,
        format._id,
        validFormatSpecifiers._id,
        locale?._id ?? ffi.nullptr,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString?
      initWithValidatedFormat_validFormatSpecifiers_arguments_error_(
          NSString format,
          NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Char> argList,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_166(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_arguments_error_1,
        format._id,
        validFormatSpecifiers._id,
        argList,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString?
      initWithValidatedFormat_validFormatSpecifiers_locale_arguments_error_(
          NSString format,
          NSString validFormatSpecifiers,
          NSObject? locale,
          ffi.Pointer<ffi.Char> argList,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_167(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_locale_arguments_error_1,
        format._id,
        validFormatSpecifiers._id,
        locale?._id ?? ffi.nullptr,
        argList,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString? initWithData_encoding_(NSData data, int encoding) {
    final _ret = _lib._objc_msgSend_168(
        _id, _lib._sel_initWithData_encoding_1, data._id, encoding);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString? initWithBytes_length_encoding_(
      ffi.Pointer<ffi.Void> bytes, int len, int encoding) {
    final _ret = _lib._objc_msgSend_169(
        _id, _lib._sel_initWithBytes_length_encoding_1, bytes, len, encoding);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  /// "NoCopy" is a hint
  @override
  NSMutableString? initWithBytesNoCopy_length_encoding_freeWhenDone_(
      ffi.Pointer<ffi.Void> bytes, int len, int encoding, bool freeBuffer) {
    final _ret = _lib._objc_msgSend_170(
        _id,
        _lib._sel_initWithBytesNoCopy_length_encoding_freeWhenDone_1,
        bytes,
        len,
        encoding,
        freeBuffer);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: false, release: true);
  }

  @override
  NSMutableString? initWithBytesNoCopy_length_encoding_deallocator_(
      ffi.Pointer<ffi.Void> bytes,
      int len,
      int encoding,
      ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong? deallocator) {
    final _ret = _lib._objc_msgSend_171(
        _id,
        _lib._sel_initWithBytesNoCopy_length_encoding_deallocator_1,
        bytes,
        len,
        encoding,
        deallocator?._id ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: false, release: true);
  }

  static NSMutableString string(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableString1, _lib._sel_string1);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString stringWithString_(Foundation _lib, NSString string) {
    final _ret = _lib._objc_msgSend_18(
        _lib._class_NSMutableString1, _lib._sel_stringWithString_1, string._id);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString stringWithCharacters_length_(
      Foundation _lib, ffi.Pointer<ffi.UnsignedShort> characters, int length) {
    final _ret = _lib._objc_msgSend_159(_lib._class_NSMutableString1,
        _lib._sel_stringWithCharacters_length_1, characters, length);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString? stringWithUTF8String_(
      Foundation _lib, ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final _ret = _lib._objc_msgSend_160(_lib._class_NSMutableString1,
        _lib._sel_stringWithUTF8String_1, nullTerminatedCString);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString stringWithFormat_(Foundation _lib, NSString format) {
    final _ret = _lib._objc_msgSend_18(
        _lib._class_NSMutableString1, _lib._sel_stringWithFormat_1, format._id);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString localizedStringWithFormat_(
      Foundation _lib, NSString format) {
    final _ret = _lib._objc_msgSend_18(_lib._class_NSMutableString1,
        _lib._sel_localizedStringWithFormat_1, format._id);
    return NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString?
      stringWithValidatedFormat_validFormatSpecifiers_error_(
          Foundation _lib,
          NSString format,
          NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _lib._class_NSMutableString1,
        _lib._sel_stringWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString?
      localizedStringWithValidatedFormat_validFormatSpecifiers_error_(
          Foundation _lib,
          NSString format,
          NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _lib._class_NSMutableString1,
        _lib._sel_localizedStringWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString? initWithCString_encoding_(
      ffi.Pointer<ffi.Char> nullTerminatedCString, int encoding) {
    final _ret = _lib._objc_msgSend_172(_id,
        _lib._sel_initWithCString_encoding_1, nullTerminatedCString, encoding);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString? stringWithCString_encoding_(
      Foundation _lib, ffi.Pointer<ffi.Char> cString, int enc) {
    final _ret = _lib._objc_msgSend_172(_lib._class_NSMutableString1,
        _lib._sel_stringWithCString_encoding_1, cString, enc);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  /// These use the specified encoding.  If nil is returned, the optional error return indicates problem that was encountered (for instance, file system or encoding errors).
  @override
  NSMutableString? initWithContentsOfURL_encoding_error_(
      NSURL url, int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_173(_id,
        _lib._sel_initWithContentsOfURL_encoding_error_1, url._id, enc, error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString? initWithContentsOfFile_encoding_error_(
      NSString path, int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_174(
        _id,
        _lib._sel_initWithContentsOfFile_encoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString? stringWithContentsOfURL_encoding_error_(
      Foundation _lib,
      NSURL url,
      int enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_173(
        _lib._class_NSMutableString1,
        _lib._sel_stringWithContentsOfURL_encoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString? stringWithContentsOfFile_encoding_error_(
      Foundation _lib,
      NSString path,
      int enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_174(
        _lib._class_NSMutableString1,
        _lib._sel_stringWithContentsOfFile_encoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  /// These try to determine the encoding, and return the encoding which was used.  Note that these methods might get "smarter" in subsequent releases of the system, and use additional techniques for recognizing encodings. If nil is returned, the optional error return indicates problem that was encountered (for instance, file system or encoding errors).
  @override
  NSMutableString? initWithContentsOfURL_usedEncoding_error_(
      NSURL url,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_175(
        _id,
        _lib._sel_initWithContentsOfURL_usedEncoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableString? initWithContentsOfFile_usedEncoding_error_(
      NSString path,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_176(
        _id,
        _lib._sel_initWithContentsOfFile_usedEncoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString? stringWithContentsOfURL_usedEncoding_error_(
      Foundation _lib,
      NSURL url,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_175(
        _lib._class_NSMutableString1,
        _lib._sel_stringWithContentsOfURL_usedEncoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString? stringWithContentsOfFile_usedEncoding_error_(
      Foundation _lib,
      NSString path,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_176(
        _lib._class_NSMutableString1,
        _lib._sel_stringWithContentsOfFile_usedEncoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSMutableString._(_ret, _lib, retain: true, release: true);
  }

  /// This API is used to detect the string encoding of a given raw data. It can also do lossy string conversion. It converts the data to a string in the detected string encoding. The data object contains the raw bytes, and the option dictionary contains the hints and parameters for the analysis. The opts dictionary can be nil. If the string parameter is not NULL, the string created by the detected string encoding is returned. The lossy substitution string is emitted in the output string for characters that could not be converted when lossy conversion is enabled. The usedLossyConversion indicates if there is any lossy conversion in the resulted string. If no encoding can be detected, 0 is returned.
  ///
  /// The possible items for the dictionary are:
  /// 1) an array of suggested string encodings (without specifying the 3rd option in this list, all string encodings are considered but the ones in the array will have a higher preference; moreover, the order of the encodings in the array is important: the first encoding has a higher preference than the second one in the array)
  /// 2) an array of string encodings not to use (the string encodings in this list will not be considered at all)
  /// 3) a boolean option indicating whether only the suggested string encodings are considered
  /// 4) a boolean option indicating whether lossy is allowed
  /// 5) an option that gives a specific string to substitude for mystery bytes
  /// 6) the current user's language
  /// 7) a boolean option indicating whether the data is generated by Windows
  ///
  /// If the values in the dictionary have wrong types (for example, the value of NSStringEncodingDetectionSuggestedEncodingsKey is not an array), an exception is thrown.
  /// If the values in the dictionary are unknown (for example, the value in the array of suggested string encodings is not a valid encoding), the values will be ignored.
  static int
      stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_(
          Foundation _lib,
          NSData data,
          NSObject? opts,
          ffi.Pointer<ffi.Pointer<ObjCObject>> string,
          ffi.Pointer<ffi.Bool> usedLossyConversion) {
    return _lib._objc_msgSend_177(
        _lib._class_NSMutableString1,
        _lib._sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_1,
        data._id,
        opts?._id ?? ffi.nullptr,
        string,
        usedLossyConversion);
  }

  static NSObject? stringWithContentsOfFile_(Foundation _lib, NSString path) {
    final _ret = _lib._objc_msgSend_25(_lib._class_NSMutableString1,
        _lib._sel_stringWithContentsOfFile_1, path._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithContentsOfURL_(Foundation _lib, NSURL url) {
    final _ret = _lib._objc_msgSend_184(_lib._class_NSMutableString1,
        _lib._sel_stringWithContentsOfURL_1, url._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithCString_length_(
      Foundation _lib, ffi.Pointer<ffi.Char> bytes, int length) {
    final _ret = _lib._objc_msgSend_172(_lib._class_NSMutableString1,
        _lib._sel_stringWithCString_length_1, bytes, length);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithCString_(
      Foundation _lib, ffi.Pointer<ffi.Char> bytes) {
    final _ret = _lib._objc_msgSend_160(
        _lib._class_NSMutableString1, _lib._sel_stringWithCString_1, bytes);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableString new1(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableString1, _lib._sel_new1);
    return NSMutableString._(_ret, _lib, retain: false, release: true);
  }

  static NSMutableString allocWithZone_(
      Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSMutableString1, _lib._sel_allocWithZone_1, zone);
    return NSMutableString._(_ret, _lib, retain: false, release: true);
  }

  static NSMutableString alloc(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableString1, _lib._sel_alloc1);
    return NSMutableString._(_ret, _lib, retain: false, release: true);
  }
}

class NSSimpleCString extends NSString {
  NSSimpleCString._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSSimpleCString] that points to the same underlying object as [other].
  static NSSimpleCString castFrom<T extends _ObjCWrapper>(T other) {
    return NSSimpleCString._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSSimpleCString] that wraps the given raw object pointer.
  static NSSimpleCString castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSSimpleCString._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSSimpleCString].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSSimpleCString1);
  }

  /// The initializers available to subclasses. See further below for additional init methods.
  @override
  NSSimpleCString init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString? initWithCoder_(NSCoder coder) {
    final _ret =
        _lib._objc_msgSend_37(_id, _lib._sel_initWithCoder_1, coder._id);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static ffi.Pointer<ffi.UnsignedLong> getAvailableStringEncodings(
      Foundation _lib) {
    return _lib._objc_msgSend_146(
        _lib._class_NSSimpleCString1, _lib._sel_availableStringEncodings1);
  }

  static NSString localizedNameOfStringEncoding_(
      Foundation _lib, int encoding) {
    final _ret = _lib._objc_msgSend_106(_lib._class_NSSimpleCString1,
        _lib._sel_localizedNameOfStringEncoding_1, encoding);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Should be rarely used
  static int getDefaultCStringEncoding(Foundation _lib) {
    return _lib._objc_msgSend_12(
        _lib._class_NSSimpleCString1, _lib._sel_defaultCStringEncoding1);
  }

  /// "NoCopy" is a hint
  @override
  NSSimpleCString initWithCharactersNoCopy_length_freeWhenDone_(
      ffi.Pointer<ffi.UnsignedShort> characters, int length, bool freeBuffer) {
    final _ret = _lib._objc_msgSend_157(
        _id,
        _lib._sel_initWithCharactersNoCopy_length_freeWhenDone_1,
        characters,
        length,
        freeBuffer);
    return NSSimpleCString._(_ret, _lib, retain: false, release: true);
  }

  @override
  NSSimpleCString initWithCharactersNoCopy_length_deallocator_(
      ffi.Pointer<ffi.UnsignedShort> chars,
      int len,
      ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong? deallocator) {
    final _ret = _lib._objc_msgSend_158(
        _id,
        _lib._sel_initWithCharactersNoCopy_length_deallocator_1,
        chars,
        len,
        deallocator?._id ?? ffi.nullptr);
    return NSSimpleCString._(_ret, _lib, retain: false, release: true);
  }

  @override
  NSSimpleCString initWithCharacters_length_(
      ffi.Pointer<ffi.UnsignedShort> characters, int length) {
    final _ret = _lib._objc_msgSend_159(
        _id, _lib._sel_initWithCharacters_length_1, characters, length);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString? initWithUTF8String_(
      ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final _ret = _lib._objc_msgSend_160(
        _id, _lib._sel_initWithUTF8String_1, nullTerminatedCString);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString initWithString_(NSString aString) {
    final _ret =
        _lib._objc_msgSend_18(_id, _lib._sel_initWithString_1, aString._id);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString initWithFormat_(NSString format) {
    final _ret =
        _lib._objc_msgSend_18(_id, _lib._sel_initWithFormat_1, format._id);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString initWithFormat_arguments_(
      NSString format, ffi.Pointer<ffi.Char> argList) {
    final _ret = _lib._objc_msgSend_161(
        _id, _lib._sel_initWithFormat_arguments_1, format._id, argList);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString initWithFormat_locale_(NSString format, NSObject? locale) {
    final _ret = _lib._objc_msgSend_162(_id, _lib._sel_initWithFormat_locale_1,
        format._id, locale?._id ?? ffi.nullptr);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString initWithFormat_locale_arguments_(
      NSString format, NSObject? locale, ffi.Pointer<ffi.Char> argList) {
    final _ret = _lib._objc_msgSend_163(
        _id,
        _lib._sel_initWithFormat_locale_arguments_1,
        format._id,
        locale?._id ?? ffi.nullptr,
        argList);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString? initWithValidatedFormat_validFormatSpecifiers_error_(
      NSString format,
      NSString validFormatSpecifiers,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString? initWithValidatedFormat_validFormatSpecifiers_locale_error_(
      NSString format,
      NSString validFormatSpecifiers,
      NSObject? locale,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_165(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_locale_error_1,
        format._id,
        validFormatSpecifiers._id,
        locale?._id ?? ffi.nullptr,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString?
      initWithValidatedFormat_validFormatSpecifiers_arguments_error_(
          NSString format,
          NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Char> argList,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_166(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_arguments_error_1,
        format._id,
        validFormatSpecifiers._id,
        argList,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString?
      initWithValidatedFormat_validFormatSpecifiers_locale_arguments_error_(
          NSString format,
          NSString validFormatSpecifiers,
          NSObject? locale,
          ffi.Pointer<ffi.Char> argList,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_167(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_locale_arguments_error_1,
        format._id,
        validFormatSpecifiers._id,
        locale?._id ?? ffi.nullptr,
        argList,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString? initWithData_encoding_(NSData data, int encoding) {
    final _ret = _lib._objc_msgSend_168(
        _id, _lib._sel_initWithData_encoding_1, data._id, encoding);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString? initWithBytes_length_encoding_(
      ffi.Pointer<ffi.Void> bytes, int len, int encoding) {
    final _ret = _lib._objc_msgSend_169(
        _id, _lib._sel_initWithBytes_length_encoding_1, bytes, len, encoding);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  /// "NoCopy" is a hint
  @override
  NSSimpleCString? initWithBytesNoCopy_length_encoding_freeWhenDone_(
      ffi.Pointer<ffi.Void> bytes, int len, int encoding, bool freeBuffer) {
    final _ret = _lib._objc_msgSend_170(
        _id,
        _lib._sel_initWithBytesNoCopy_length_encoding_freeWhenDone_1,
        bytes,
        len,
        encoding,
        freeBuffer);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: false, release: true);
  }

  @override
  NSSimpleCString? initWithBytesNoCopy_length_encoding_deallocator_(
      ffi.Pointer<ffi.Void> bytes,
      int len,
      int encoding,
      ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong? deallocator) {
    final _ret = _lib._objc_msgSend_171(
        _id,
        _lib._sel_initWithBytesNoCopy_length_encoding_deallocator_1,
        bytes,
        len,
        encoding,
        deallocator?._id ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: false, release: true);
  }

  static NSSimpleCString string(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSSimpleCString1, _lib._sel_string1);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString stringWithString_(Foundation _lib, NSString string) {
    final _ret = _lib._objc_msgSend_18(
        _lib._class_NSSimpleCString1, _lib._sel_stringWithString_1, string._id);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString stringWithCharacters_length_(
      Foundation _lib, ffi.Pointer<ffi.UnsignedShort> characters, int length) {
    final _ret = _lib._objc_msgSend_159(_lib._class_NSSimpleCString1,
        _lib._sel_stringWithCharacters_length_1, characters, length);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString? stringWithUTF8String_(
      Foundation _lib, ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final _ret = _lib._objc_msgSend_160(_lib._class_NSSimpleCString1,
        _lib._sel_stringWithUTF8String_1, nullTerminatedCString);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString stringWithFormat_(Foundation _lib, NSString format) {
    final _ret = _lib._objc_msgSend_18(
        _lib._class_NSSimpleCString1, _lib._sel_stringWithFormat_1, format._id);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString localizedStringWithFormat_(
      Foundation _lib, NSString format) {
    final _ret = _lib._objc_msgSend_18(_lib._class_NSSimpleCString1,
        _lib._sel_localizedStringWithFormat_1, format._id);
    return NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString?
      stringWithValidatedFormat_validFormatSpecifiers_error_(
          Foundation _lib,
          NSString format,
          NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _lib._class_NSSimpleCString1,
        _lib._sel_stringWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString?
      localizedStringWithValidatedFormat_validFormatSpecifiers_error_(
          Foundation _lib,
          NSString format,
          NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _lib._class_NSSimpleCString1,
        _lib._sel_localizedStringWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString? initWithCString_encoding_(
      ffi.Pointer<ffi.Char> nullTerminatedCString, int encoding) {
    final _ret = _lib._objc_msgSend_172(_id,
        _lib._sel_initWithCString_encoding_1, nullTerminatedCString, encoding);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString? stringWithCString_encoding_(
      Foundation _lib, ffi.Pointer<ffi.Char> cString, int enc) {
    final _ret = _lib._objc_msgSend_172(_lib._class_NSSimpleCString1,
        _lib._sel_stringWithCString_encoding_1, cString, enc);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  /// These use the specified encoding.  If nil is returned, the optional error return indicates problem that was encountered (for instance, file system or encoding errors).
  @override
  NSSimpleCString? initWithContentsOfURL_encoding_error_(
      NSURL url, int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_173(_id,
        _lib._sel_initWithContentsOfURL_encoding_error_1, url._id, enc, error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString? initWithContentsOfFile_encoding_error_(
      NSString path, int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_174(
        _id,
        _lib._sel_initWithContentsOfFile_encoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString? stringWithContentsOfURL_encoding_error_(
      Foundation _lib,
      NSURL url,
      int enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_173(
        _lib._class_NSSimpleCString1,
        _lib._sel_stringWithContentsOfURL_encoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString? stringWithContentsOfFile_encoding_error_(
      Foundation _lib,
      NSString path,
      int enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_174(
        _lib._class_NSSimpleCString1,
        _lib._sel_stringWithContentsOfFile_encoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  /// These try to determine the encoding, and return the encoding which was used.  Note that these methods might get "smarter" in subsequent releases of the system, and use additional techniques for recognizing encodings. If nil is returned, the optional error return indicates problem that was encountered (for instance, file system or encoding errors).
  @override
  NSSimpleCString? initWithContentsOfURL_usedEncoding_error_(
      NSURL url,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_175(
        _id,
        _lib._sel_initWithContentsOfURL_usedEncoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSSimpleCString? initWithContentsOfFile_usedEncoding_error_(
      NSString path,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_176(
        _id,
        _lib._sel_initWithContentsOfFile_usedEncoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString? stringWithContentsOfURL_usedEncoding_error_(
      Foundation _lib,
      NSURL url,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_175(
        _lib._class_NSSimpleCString1,
        _lib._sel_stringWithContentsOfURL_usedEncoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString? stringWithContentsOfFile_usedEncoding_error_(
      Foundation _lib,
      NSString path,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_176(
        _lib._class_NSSimpleCString1,
        _lib._sel_stringWithContentsOfFile_usedEncoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSSimpleCString._(_ret, _lib, retain: true, release: true);
  }

  /// This API is used to detect the string encoding of a given raw data. It can also do lossy string conversion. It converts the data to a string in the detected string encoding. The data object contains the raw bytes, and the option dictionary contains the hints and parameters for the analysis. The opts dictionary can be nil. If the string parameter is not NULL, the string created by the detected string encoding is returned. The lossy substitution string is emitted in the output string for characters that could not be converted when lossy conversion is enabled. The usedLossyConversion indicates if there is any lossy conversion in the resulted string. If no encoding can be detected, 0 is returned.
  ///
  /// The possible items for the dictionary are:
  /// 1) an array of suggested string encodings (without specifying the 3rd option in this list, all string encodings are considered but the ones in the array will have a higher preference; moreover, the order of the encodings in the array is important: the first encoding has a higher preference than the second one in the array)
  /// 2) an array of string encodings not to use (the string encodings in this list will not be considered at all)
  /// 3) a boolean option indicating whether only the suggested string encodings are considered
  /// 4) a boolean option indicating whether lossy is allowed
  /// 5) an option that gives a specific string to substitude for mystery bytes
  /// 6) the current user's language
  /// 7) a boolean option indicating whether the data is generated by Windows
  ///
  /// If the values in the dictionary have wrong types (for example, the value of NSStringEncodingDetectionSuggestedEncodingsKey is not an array), an exception is thrown.
  /// If the values in the dictionary are unknown (for example, the value in the array of suggested string encodings is not a valid encoding), the values will be ignored.
  static int
      stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_(
          Foundation _lib,
          NSData data,
          NSObject? opts,
          ffi.Pointer<ffi.Pointer<ObjCObject>> string,
          ffi.Pointer<ffi.Bool> usedLossyConversion) {
    return _lib._objc_msgSend_177(
        _lib._class_NSSimpleCString1,
        _lib._sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_1,
        data._id,
        opts?._id ?? ffi.nullptr,
        string,
        usedLossyConversion);
  }

  static NSObject? stringWithContentsOfFile_(Foundation _lib, NSString path) {
    final _ret = _lib._objc_msgSend_25(_lib._class_NSSimpleCString1,
        _lib._sel_stringWithContentsOfFile_1, path._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithContentsOfURL_(Foundation _lib, NSURL url) {
    final _ret = _lib._objc_msgSend_184(_lib._class_NSSimpleCString1,
        _lib._sel_stringWithContentsOfURL_1, url._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithCString_length_(
      Foundation _lib, ffi.Pointer<ffi.Char> bytes, int length) {
    final _ret = _lib._objc_msgSend_172(_lib._class_NSSimpleCString1,
        _lib._sel_stringWithCString_length_1, bytes, length);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithCString_(
      Foundation _lib, ffi.Pointer<ffi.Char> bytes) {
    final _ret = _lib._objc_msgSend_160(
        _lib._class_NSSimpleCString1, _lib._sel_stringWithCString_1, bytes);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSSimpleCString new1(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSSimpleCString1, _lib._sel_new1);
    return NSSimpleCString._(_ret, _lib, retain: false, release: true);
  }

  static NSSimpleCString allocWithZone_(
      Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSSimpleCString1, _lib._sel_allocWithZone_1, zone);
    return NSSimpleCString._(_ret, _lib, retain: false, release: true);
  }

  static NSSimpleCString alloc(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSSimpleCString1, _lib._sel_alloc1);
    return NSSimpleCString._(_ret, _lib, retain: false, release: true);
  }
}

class NSConstantString extends NSSimpleCString {
  NSConstantString._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSConstantString] that points to the same underlying object as [other].
  static NSConstantString castFrom<T extends _ObjCWrapper>(T other) {
    return NSConstantString._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSConstantString] that wraps the given raw object pointer.
  static NSConstantString castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSConstantString._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSConstantString].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSConstantString1);
  }

  /// The initializers available to subclasses. See further below for additional init methods.
  @override
  NSConstantString init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString? initWithCoder_(NSCoder coder) {
    final _ret =
        _lib._objc_msgSend_37(_id, _lib._sel_initWithCoder_1, coder._id);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static ffi.Pointer<ffi.UnsignedLong> getAvailableStringEncodings(
      Foundation _lib) {
    return _lib._objc_msgSend_146(
        _lib._class_NSConstantString1, _lib._sel_availableStringEncodings1);
  }

  static NSString localizedNameOfStringEncoding_(
      Foundation _lib, int encoding) {
    final _ret = _lib._objc_msgSend_106(_lib._class_NSConstantString1,
        _lib._sel_localizedNameOfStringEncoding_1, encoding);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Should be rarely used
  static int getDefaultCStringEncoding(Foundation _lib) {
    return _lib._objc_msgSend_12(
        _lib._class_NSConstantString1, _lib._sel_defaultCStringEncoding1);
  }

  /// "NoCopy" is a hint
  @override
  NSConstantString initWithCharactersNoCopy_length_freeWhenDone_(
      ffi.Pointer<ffi.UnsignedShort> characters, int length, bool freeBuffer) {
    final _ret = _lib._objc_msgSend_157(
        _id,
        _lib._sel_initWithCharactersNoCopy_length_freeWhenDone_1,
        characters,
        length,
        freeBuffer);
    return NSConstantString._(_ret, _lib, retain: false, release: true);
  }

  @override
  NSConstantString initWithCharactersNoCopy_length_deallocator_(
      ffi.Pointer<ffi.UnsignedShort> chars,
      int len,
      ObjCBlock_ffiVoid_ffiUnsignedShort_ffiUnsignedLong? deallocator) {
    final _ret = _lib._objc_msgSend_158(
        _id,
        _lib._sel_initWithCharactersNoCopy_length_deallocator_1,
        chars,
        len,
        deallocator?._id ?? ffi.nullptr);
    return NSConstantString._(_ret, _lib, retain: false, release: true);
  }

  @override
  NSConstantString initWithCharacters_length_(
      ffi.Pointer<ffi.UnsignedShort> characters, int length) {
    final _ret = _lib._objc_msgSend_159(
        _id, _lib._sel_initWithCharacters_length_1, characters, length);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString? initWithUTF8String_(
      ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final _ret = _lib._objc_msgSend_160(
        _id, _lib._sel_initWithUTF8String_1, nullTerminatedCString);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString initWithString_(NSString aString) {
    final _ret =
        _lib._objc_msgSend_18(_id, _lib._sel_initWithString_1, aString._id);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString initWithFormat_(NSString format) {
    final _ret =
        _lib._objc_msgSend_18(_id, _lib._sel_initWithFormat_1, format._id);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString initWithFormat_arguments_(
      NSString format, ffi.Pointer<ffi.Char> argList) {
    final _ret = _lib._objc_msgSend_161(
        _id, _lib._sel_initWithFormat_arguments_1, format._id, argList);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString initWithFormat_locale_(NSString format, NSObject? locale) {
    final _ret = _lib._objc_msgSend_162(_id, _lib._sel_initWithFormat_locale_1,
        format._id, locale?._id ?? ffi.nullptr);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString initWithFormat_locale_arguments_(
      NSString format, NSObject? locale, ffi.Pointer<ffi.Char> argList) {
    final _ret = _lib._objc_msgSend_163(
        _id,
        _lib._sel_initWithFormat_locale_arguments_1,
        format._id,
        locale?._id ?? ffi.nullptr,
        argList);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString? initWithValidatedFormat_validFormatSpecifiers_error_(
      NSString format,
      NSString validFormatSpecifiers,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString? initWithValidatedFormat_validFormatSpecifiers_locale_error_(
      NSString format,
      NSString validFormatSpecifiers,
      NSObject? locale,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_165(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_locale_error_1,
        format._id,
        validFormatSpecifiers._id,
        locale?._id ?? ffi.nullptr,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString?
      initWithValidatedFormat_validFormatSpecifiers_arguments_error_(
          NSString format,
          NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Char> argList,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_166(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_arguments_error_1,
        format._id,
        validFormatSpecifiers._id,
        argList,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString?
      initWithValidatedFormat_validFormatSpecifiers_locale_arguments_error_(
          NSString format,
          NSString validFormatSpecifiers,
          NSObject? locale,
          ffi.Pointer<ffi.Char> argList,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_167(
        _id,
        _lib._sel_initWithValidatedFormat_validFormatSpecifiers_locale_arguments_error_1,
        format._id,
        validFormatSpecifiers._id,
        locale?._id ?? ffi.nullptr,
        argList,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString? initWithData_encoding_(NSData data, int encoding) {
    final _ret = _lib._objc_msgSend_168(
        _id, _lib._sel_initWithData_encoding_1, data._id, encoding);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString? initWithBytes_length_encoding_(
      ffi.Pointer<ffi.Void> bytes, int len, int encoding) {
    final _ret = _lib._objc_msgSend_169(
        _id, _lib._sel_initWithBytes_length_encoding_1, bytes, len, encoding);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  /// "NoCopy" is a hint
  @override
  NSConstantString? initWithBytesNoCopy_length_encoding_freeWhenDone_(
      ffi.Pointer<ffi.Void> bytes, int len, int encoding, bool freeBuffer) {
    final _ret = _lib._objc_msgSend_170(
        _id,
        _lib._sel_initWithBytesNoCopy_length_encoding_freeWhenDone_1,
        bytes,
        len,
        encoding,
        freeBuffer);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: false, release: true);
  }

  @override
  NSConstantString? initWithBytesNoCopy_length_encoding_deallocator_(
      ffi.Pointer<ffi.Void> bytes,
      int len,
      int encoding,
      ObjCBlock_ffiVoid_ffiVoid_ffiUnsignedLong? deallocator) {
    final _ret = _lib._objc_msgSend_171(
        _id,
        _lib._sel_initWithBytesNoCopy_length_encoding_deallocator_1,
        bytes,
        len,
        encoding,
        deallocator?._id ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: false, release: true);
  }

  static NSConstantString string(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSConstantString1, _lib._sel_string1);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString stringWithString_(Foundation _lib, NSString string) {
    final _ret = _lib._objc_msgSend_18(_lib._class_NSConstantString1,
        _lib._sel_stringWithString_1, string._id);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString stringWithCharacters_length_(
      Foundation _lib, ffi.Pointer<ffi.UnsignedShort> characters, int length) {
    final _ret = _lib._objc_msgSend_159(_lib._class_NSConstantString1,
        _lib._sel_stringWithCharacters_length_1, characters, length);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString? stringWithUTF8String_(
      Foundation _lib, ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final _ret = _lib._objc_msgSend_160(_lib._class_NSConstantString1,
        _lib._sel_stringWithUTF8String_1, nullTerminatedCString);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString stringWithFormat_(Foundation _lib, NSString format) {
    final _ret = _lib._objc_msgSend_18(_lib._class_NSConstantString1,
        _lib._sel_stringWithFormat_1, format._id);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString localizedStringWithFormat_(
      Foundation _lib, NSString format) {
    final _ret = _lib._objc_msgSend_18(_lib._class_NSConstantString1,
        _lib._sel_localizedStringWithFormat_1, format._id);
    return NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString?
      stringWithValidatedFormat_validFormatSpecifiers_error_(
          Foundation _lib,
          NSString format,
          NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _lib._class_NSConstantString1,
        _lib._sel_stringWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString?
      localizedStringWithValidatedFormat_validFormatSpecifiers_error_(
          Foundation _lib,
          NSString format,
          NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_164(
        _lib._class_NSConstantString1,
        _lib._sel_localizedStringWithValidatedFormat_validFormatSpecifiers_error_1,
        format._id,
        validFormatSpecifiers._id,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString? initWithCString_encoding_(
      ffi.Pointer<ffi.Char> nullTerminatedCString, int encoding) {
    final _ret = _lib._objc_msgSend_172(_id,
        _lib._sel_initWithCString_encoding_1, nullTerminatedCString, encoding);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString? stringWithCString_encoding_(
      Foundation _lib, ffi.Pointer<ffi.Char> cString, int enc) {
    final _ret = _lib._objc_msgSend_172(_lib._class_NSConstantString1,
        _lib._sel_stringWithCString_encoding_1, cString, enc);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  /// These use the specified encoding.  If nil is returned, the optional error return indicates problem that was encountered (for instance, file system or encoding errors).
  @override
  NSConstantString? initWithContentsOfURL_encoding_error_(
      NSURL url, int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_173(_id,
        _lib._sel_initWithContentsOfURL_encoding_error_1, url._id, enc, error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString? initWithContentsOfFile_encoding_error_(
      NSString path, int enc, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_174(
        _id,
        _lib._sel_initWithContentsOfFile_encoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString? stringWithContentsOfURL_encoding_error_(
      Foundation _lib,
      NSURL url,
      int enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_173(
        _lib._class_NSConstantString1,
        _lib._sel_stringWithContentsOfURL_encoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString? stringWithContentsOfFile_encoding_error_(
      Foundation _lib,
      NSString path,
      int enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_174(
        _lib._class_NSConstantString1,
        _lib._sel_stringWithContentsOfFile_encoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  /// These try to determine the encoding, and return the encoding which was used.  Note that these methods might get "smarter" in subsequent releases of the system, and use additional techniques for recognizing encodings. If nil is returned, the optional error return indicates problem that was encountered (for instance, file system or encoding errors).
  @override
  NSConstantString? initWithContentsOfURL_usedEncoding_error_(
      NSURL url,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_175(
        _id,
        _lib._sel_initWithContentsOfURL_usedEncoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSConstantString? initWithContentsOfFile_usedEncoding_error_(
      NSString path,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_176(
        _id,
        _lib._sel_initWithContentsOfFile_usedEncoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString? stringWithContentsOfURL_usedEncoding_error_(
      Foundation _lib,
      NSURL url,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_175(
        _lib._class_NSConstantString1,
        _lib._sel_stringWithContentsOfURL_usedEncoding_error_1,
        url._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString? stringWithContentsOfFile_usedEncoding_error_(
      Foundation _lib,
      NSString path,
      ffi.Pointer<ffi.UnsignedLong> enc,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_176(
        _lib._class_NSConstantString1,
        _lib._sel_stringWithContentsOfFile_usedEncoding_error_1,
        path._id,
        enc,
        error);
    return _ret.address == 0
        ? null
        : NSConstantString._(_ret, _lib, retain: true, release: true);
  }

  /// This API is used to detect the string encoding of a given raw data. It can also do lossy string conversion. It converts the data to a string in the detected string encoding. The data object contains the raw bytes, and the option dictionary contains the hints and parameters for the analysis. The opts dictionary can be nil. If the string parameter is not NULL, the string created by the detected string encoding is returned. The lossy substitution string is emitted in the output string for characters that could not be converted when lossy conversion is enabled. The usedLossyConversion indicates if there is any lossy conversion in the resulted string. If no encoding can be detected, 0 is returned.
  ///
  /// The possible items for the dictionary are:
  /// 1) an array of suggested string encodings (without specifying the 3rd option in this list, all string encodings are considered but the ones in the array will have a higher preference; moreover, the order of the encodings in the array is important: the first encoding has a higher preference than the second one in the array)
  /// 2) an array of string encodings not to use (the string encodings in this list will not be considered at all)
  /// 3) a boolean option indicating whether only the suggested string encodings are considered
  /// 4) a boolean option indicating whether lossy is allowed
  /// 5) an option that gives a specific string to substitude for mystery bytes
  /// 6) the current user's language
  /// 7) a boolean option indicating whether the data is generated by Windows
  ///
  /// If the values in the dictionary have wrong types (for example, the value of NSStringEncodingDetectionSuggestedEncodingsKey is not an array), an exception is thrown.
  /// If the values in the dictionary are unknown (for example, the value in the array of suggested string encodings is not a valid encoding), the values will be ignored.
  static int
      stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_(
          Foundation _lib,
          NSData data,
          NSObject? opts,
          ffi.Pointer<ffi.Pointer<ObjCObject>> string,
          ffi.Pointer<ffi.Bool> usedLossyConversion) {
    return _lib._objc_msgSend_177(
        _lib._class_NSConstantString1,
        _lib._sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_1,
        data._id,
        opts?._id ?? ffi.nullptr,
        string,
        usedLossyConversion);
  }

  static NSObject? stringWithContentsOfFile_(Foundation _lib, NSString path) {
    final _ret = _lib._objc_msgSend_25(_lib._class_NSConstantString1,
        _lib._sel_stringWithContentsOfFile_1, path._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithContentsOfURL_(Foundation _lib, NSURL url) {
    final _ret = _lib._objc_msgSend_184(_lib._class_NSConstantString1,
        _lib._sel_stringWithContentsOfURL_1, url._id);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithCString_length_(
      Foundation _lib, ffi.Pointer<ffi.Char> bytes, int length) {
    final _ret = _lib._objc_msgSend_172(_lib._class_NSConstantString1,
        _lib._sel_stringWithCString_length_1, bytes, length);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject? stringWithCString_(
      Foundation _lib, ffi.Pointer<ffi.Char> bytes) {
    final _ret = _lib._objc_msgSend_160(
        _lib._class_NSConstantString1, _lib._sel_stringWithCString_1, bytes);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSConstantString new1(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSConstantString1, _lib._sel_new1);
    return NSConstantString._(_ret, _lib, retain: false, release: true);
  }

  static NSConstantString allocWithZone_(
      Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSConstantString1, _lib._sel_allocWithZone_1, zone);
    return NSConstantString._(_ret, _lib, retain: false, release: true);
  }

  static NSConstantString alloc(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSConstantString1, _lib._sel_alloc1);
    return NSConstantString._(_ret, _lib, retain: false, release: true);
  }
}

/// NSURLQueryItem encapsulates a single query name-value pair. The name and value strings of a query name-value pair are not percent encoded. For use with the NSURLComponents queryItems property.
class NSURLQueryItem extends NSObject {
  NSURLQueryItem._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLQueryItem] that points to the same underlying object as [other].
  static NSURLQueryItem castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLQueryItem._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLQueryItem] that wraps the given raw object pointer.
  static NSURLQueryItem castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLQueryItem._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLQueryItem].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLQueryItem1);
  }

  NSURLQueryItem initWithName_value_(NSString name, NSString? value) {
    final _ret = _lib._objc_msgSend_195(_id, _lib._sel_initWithName_value_1,
        name._id, value?._id ?? ffi.nullptr);
    return NSURLQueryItem._(_ret, _lib, retain: true, release: true);
  }

  static NSURLQueryItem queryItemWithName_value_(
      Foundation _lib, NSString name, NSString? value) {
    final _ret = _lib._objc_msgSend_195(
        _lib._class_NSURLQueryItem1,
        _lib._sel_queryItemWithName_value_1,
        name._id,
        value?._id ?? ffi.nullptr);
    return NSURLQueryItem._(_ret, _lib, retain: true, release: true);
  }

  NSString get name {
    final _ret = _lib._objc_msgSend_13(_id, _lib._sel_name1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get value {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_value1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSURLQueryItem init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLQueryItem._(_ret, _lib, retain: true, release: true);
  }

  static NSURLQueryItem new1(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLQueryItem1, _lib._sel_new1);
    return NSURLQueryItem._(_ret, _lib, retain: false, release: true);
  }

  static NSURLQueryItem allocWithZone_(
      Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSURLQueryItem1, _lib._sel_allocWithZone_1, zone);
    return NSURLQueryItem._(_ret, _lib, retain: false, release: true);
  }

  static NSURLQueryItem alloc(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLQueryItem1, _lib._sel_alloc1);
    return NSURLQueryItem._(_ret, _lib, retain: false, release: true);
  }
}

class NSURLComponents extends NSObject {
  NSURLComponents._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLComponents] that points to the same underlying object as [other].
  static NSURLComponents castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLComponents._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLComponents] that wraps the given raw object pointer.
  static NSURLComponents castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLComponents._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLComponents].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLComponents1);
  }

  /// Initialize a NSURLComponents with all components undefined. Designated initializer.
  @override
  NSURLComponents init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Initialize a NSURLComponents with the components of a URL. If resolvingAgainstBaseURL is YES and url is a relative URL, the components of [url absoluteURL] are used. If the url string from the NSURL is malformed, nil is returned.
  NSURLComponents? initWithURL_resolvingAgainstBaseURL_(
      NSURL url, bool resolve) {
    final _ret = _lib._objc_msgSend_196(
        _id, _lib._sel_initWithURL_resolvingAgainstBaseURL_1, url._id, resolve);
    return _ret.address == 0
        ? null
        : NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created NSURLComponents with the components of a URL. If resolvingAgainstBaseURL is YES and url is a relative URL, the components of [url absoluteURL] are used. If the url string from the NSURL is malformed, nil is returned.
  static NSURLComponents? componentsWithURL_resolvingAgainstBaseURL_(
      Foundation _lib, NSURL url, bool resolve) {
    final _ret = _lib._objc_msgSend_196(
        _lib._class_NSURLComponents1,
        _lib._sel_componentsWithURL_resolvingAgainstBaseURL_1,
        url._id,
        resolve);
    return _ret.address == 0
        ? null
        : NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Initialize a NSURLComponents with a URL string. If the URLString is malformed, nil is returned.
  NSURLComponents? initWithString_(NSString URLString) {
    final _ret =
        _lib._objc_msgSend_25(_id, _lib._sel_initWithString_1, URLString._id);
    return _ret.address == 0
        ? null
        : NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created NSURLComponents with a URL string. If the URLString is malformed, nil is returned.
  static NSURLComponents? componentsWithString_(
      Foundation _lib, NSString URLString) {
    final _ret = _lib._objc_msgSend_25(_lib._class_NSURLComponents1,
        _lib._sel_componentsWithString_1, URLString._id);
    return _ret.address == 0
        ? null
        : NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes an `NSURLComponents` with a URL string and the option to add (or skip) IDNA- and percent-encoding of invalid characters.
  /// If `encodingInvalidCharacters` is false, and the URL string is invalid according to RFC 3986, `nil` is returned.
  /// If `encodingInvalidCharacters` is true, `NSURLComponents` will try to encode the string to create a valid URL.
  /// If the URL string is still invalid after encoding, `nil` is returned.
  ///
  /// - Parameter URLString: The URL string.
  /// - Parameter encodingInvalidCharacters: True if `NSURLComponents` should try to encode an invalid URL string, false otherwise.
  /// - Returns: An `NSURLComponents` instance for a valid URL, or `nil` if the URL is invalid.
  NSURLComponents? initWithString_encodingInvalidCharacters_(
      NSString URLString, bool encodingInvalidCharacters) {
    final _ret = _lib._objc_msgSend_27(
        _id,
        _lib._sel_initWithString_encodingInvalidCharacters_1,
        URLString._id,
        encodingInvalidCharacters);
    return _ret.address == 0
        ? null
        : NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created `NSURLComponents` with a URL string and the option to add (or skip) IDNA- and percent-encoding of invalid characters.
  /// If `encodingInvalidCharacters` is false, and the URL string is invalid according to RFC 3986, `nil` is returned.
  /// If `encodingInvalidCharacters` is true, `NSURLComponents` will try to encode the string to create a valid URL.
  /// If the URL string is still invalid after encoding, nil is returned.
  ///
  /// - Parameter URLString: The URL string.
  /// - Parameter encodingInvalidCharacters: True if `NSURLComponents` should try to encode an invalid URL string, false otherwise.
  /// - Returns: An `NSURLComponents` instance for a valid URL, or `nil` if the URL is invalid.
  static NSURLComponents? componentsWithString_encodingInvalidCharacters_(
      Foundation _lib, NSString URLString, bool encodingInvalidCharacters) {
    final _ret = _lib._objc_msgSend_27(
        _lib._class_NSURLComponents1,
        _lib._sel_componentsWithString_encodingInvalidCharacters_1,
        URLString._id,
        encodingInvalidCharacters);
    return _ret.address == 0
        ? null
        : NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a URL created from the NSURLComponents. If the NSURLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
  NSURL? get URL {
    final _ret = _lib._objc_msgSend_33(_id, _lib._sel_URL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a URL created from the NSURLComponents relative to a base URL. If the NSURLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
  NSURL? URLRelativeToURL_(NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_197(
        _id, _lib._sel_URLRelativeToURL_1, baseURL?._id ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a URL string created from the NSURLComponents. If the NSURLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
  NSString? get string {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_string1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Attempting to set the scheme with an invalid scheme string will cause an exception.
  NSString? get scheme {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_scheme1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Attempting to set the scheme with an invalid scheme string will cause an exception.
  set scheme(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setScheme_1, value?._id ?? ffi.nullptr);
  }

  NSString? get user {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_user1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set user(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setUser_1, value?._id ?? ffi.nullptr);
  }

  NSString? get password {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_password1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set password(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setPassword_1, value?._id ?? ffi.nullptr);
  }

  NSString? get host {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_host1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set host(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setHost_1, value?._id ?? ffi.nullptr);
  }

  /// Attempting to set a negative port number will cause an exception.
  NSNumber? get port {
    final _ret = _lib._objc_msgSend_65(_id, _lib._sel_port1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  /// Attempting to set a negative port number will cause an exception.
  set port(NSNumber? value) {
    return _lib._objc_msgSend_199(
        _id, _lib._sel_setPort_1, value?._id ?? ffi.nullptr);
  }

  NSString? get path {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_path1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set path(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setPath_1, value?._id ?? ffi.nullptr);
  }

  NSString? get query {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_query1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set query(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setQuery_1, value?._id ?? ffi.nullptr);
  }

  NSString? get fragment {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_fragment1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set fragment(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setFragment_1, value?._id ?? ffi.nullptr);
  }

  /// Getting these properties retains any percent encoding these components may have. Setting these properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause an exception. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with NSURL (-stringByAddingPercentEncodingWithAllowedCharacters: will percent-encode any ';' characters if you pass the URLPathAllowedCharacterSet).
  NSString? get percentEncodedUser {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_percentEncodedUser1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Getting these properties retains any percent encoding these components may have. Setting these properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause an exception. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with NSURL (-stringByAddingPercentEncodingWithAllowedCharacters: will percent-encode any ';' characters if you pass the URLPathAllowedCharacterSet).
  set percentEncodedUser(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setPercentEncodedUser_1, value?._id ?? ffi.nullptr);
  }

  NSString? get percentEncodedPassword {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_percentEncodedPassword1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set percentEncodedPassword(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setPercentEncodedPassword_1, value?._id ?? ffi.nullptr);
  }

  NSString? get percentEncodedHost {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_percentEncodedHost1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set percentEncodedHost(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setPercentEncodedHost_1, value?._id ?? ffi.nullptr);
  }

  NSString? get percentEncodedPath {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_percentEncodedPath1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set percentEncodedPath(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setPercentEncodedPath_1, value?._id ?? ffi.nullptr);
  }

  NSString? get percentEncodedQuery {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_percentEncodedQuery1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set percentEncodedQuery(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setPercentEncodedQuery_1, value?._id ?? ffi.nullptr);
  }

  NSString? get percentEncodedFragment {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_percentEncodedFragment1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set percentEncodedFragment(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setPercentEncodedFragment_1, value?._id ?? ffi.nullptr);
  }

  NSString? get encodedHost {
    final _ret = _lib._objc_msgSend_32(_id, _lib._sel_encodedHost1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set encodedHost(NSString? value) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setEncodedHost_1, value?._id ?? ffi.nullptr);
  }

  /// These properties return the character range of a component in the URL string returned by -[NSURLComponents string]. If the component does not exist in the NSURLComponents object, {NSNotFound, 0} is returned. Note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
  void getRangeOfScheme(ffi.Pointer<NSRange> stret) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_200_stret(stret, _id, _lib._sel_rangeOfScheme1)
        : stret.ref = _lib._objc_msgSend_200(_id, _lib._sel_rangeOfScheme1);
  }

  void getRangeOfUser(ffi.Pointer<NSRange> stret) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_200_stret(stret, _id, _lib._sel_rangeOfUser1)
        : stret.ref = _lib._objc_msgSend_200(_id, _lib._sel_rangeOfUser1);
  }

  void getRangeOfPassword(ffi.Pointer<NSRange> stret) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_200_stret(stret, _id, _lib._sel_rangeOfPassword1)
        : stret.ref = _lib._objc_msgSend_200(_id, _lib._sel_rangeOfPassword1);
  }

  void getRangeOfHost(ffi.Pointer<NSRange> stret) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_200_stret(stret, _id, _lib._sel_rangeOfHost1)
        : stret.ref = _lib._objc_msgSend_200(_id, _lib._sel_rangeOfHost1);
  }

  void getRangeOfPort(ffi.Pointer<NSRange> stret) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_200_stret(stret, _id, _lib._sel_rangeOfPort1)
        : stret.ref = _lib._objc_msgSend_200(_id, _lib._sel_rangeOfPort1);
  }

  void getRangeOfPath(ffi.Pointer<NSRange> stret) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_200_stret(stret, _id, _lib._sel_rangeOfPath1)
        : stret.ref = _lib._objc_msgSend_200(_id, _lib._sel_rangeOfPath1);
  }

  void getRangeOfQuery(ffi.Pointer<NSRange> stret) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_200_stret(stret, _id, _lib._sel_rangeOfQuery1)
        : stret.ref = _lib._objc_msgSend_200(_id, _lib._sel_rangeOfQuery1);
  }

  void getRangeOfFragment(ffi.Pointer<NSRange> stret) {
    _lib._objc_msgSend_useVariants1
        ? _lib._objc_msgSend_200_stret(stret, _id, _lib._sel_rangeOfFragment1)
        : stret.ref = _lib._objc_msgSend_200(_id, _lib._sel_rangeOfFragment1);
  }

  /// The query component as an array of NSURLQueryItems for this NSURLComponents.
  ///
  /// Each NSURLQueryItem represents a single key-value pair,
  ///
  /// Note that a name may appear more than once in a single query string, so the name values are not guaranteed to be unique. If the NSURLComponents has an empty query component, returns an empty array. If the NSURLComponents has no query component, returns nil.
  ///
  /// The queryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is removed.
  ///
  /// The queryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. If the NSURLQueryItems name or value strings contain any characters not allowed in a URL's query component, those characters are percent-encoded. In addition, any '&' and '=' characters in a NSURLQueryItem name are percent-encoded. Passing an empty array sets the query component of the NSURLComponents to an empty string. Passing nil removes the query component of the NSURLComponents.
  ///
  /// - note: If a NSURLQueryItem name-value pair is empty (i.e. the query string starts with '&', ends with '&', or has "&&" within it), you get a NSURLQueryItem with a zero-length name and a nil value. If a NSURLQueryItem name-value pair has nothing before the equals sign, you get a zero-length name. If a NSURLQueryItem name-value pair has nothing after the equals sign, you get a zero-length value. If a NSURLQueryItem name-value pair has no equals sign, the NSURLQueryItem name-value pair string is the name and you get a nil value.
  NSObject? get queryItems {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_queryItems1);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// The query component as an array of NSURLQueryItems for this NSURLComponents.
  ///
  /// Each NSURLQueryItem represents a single key-value pair,
  ///
  /// Note that a name may appear more than once in a single query string, so the name values are not guaranteed to be unique. If the NSURLComponents has an empty query component, returns an empty array. If the NSURLComponents has no query component, returns nil.
  ///
  /// The queryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is removed.
  ///
  /// The queryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. If the NSURLQueryItems name or value strings contain any characters not allowed in a URL's query component, those characters are percent-encoded. In addition, any '&' and '=' characters in a NSURLQueryItem name are percent-encoded. Passing an empty array sets the query component of the NSURLComponents to an empty string. Passing nil removes the query component of the NSURLComponents.
  ///
  /// - note: If a NSURLQueryItem name-value pair is empty (i.e. the query string starts with '&', ends with '&', or has "&&" within it), you get a NSURLQueryItem with a zero-length name and a nil value. If a NSURLQueryItem name-value pair has nothing before the equals sign, you get a zero-length name. If a NSURLQueryItem name-value pair has nothing after the equals sign, you get a zero-length value. If a NSURLQueryItem name-value pair has no equals sign, the NSURLQueryItem name-value pair string is the name and you get a nil value.
  set queryItems(NSObject? value) {
    return _lib._objc_msgSend_201(
        _id, _lib._sel_setQueryItems_1, value?._id ?? ffi.nullptr);
  }

  /// The percentEncodedQueryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is retained.
  ///
  /// The percentEncodedQueryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. This property assumes the NSURLQueryItem names and values are already correctly percent-encoded, and that the NSURLQueryItem names do not contain the query item delimiter characters '&' and '='. Attempting to set an incorrectly percent-encoded NSURLQueryItem or a NSURLQueryItem name with the query item delimiter characters '&' and '=' will cause an exception.
  NSObject? get percentEncodedQueryItems {
    final _ret =
        _lib._objc_msgSend_69(_id, _lib._sel_percentEncodedQueryItems1);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// The percentEncodedQueryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is retained.
  ///
  /// The percentEncodedQueryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. This property assumes the NSURLQueryItem names and values are already correctly percent-encoded, and that the NSURLQueryItem names do not contain the query item delimiter characters '&' and '='. Attempting to set an incorrectly percent-encoded NSURLQueryItem or a NSURLQueryItem name with the query item delimiter characters '&' and '=' will cause an exception.
  set percentEncodedQueryItems(NSObject? value) {
    return _lib._objc_msgSend_201(_id, _lib._sel_setPercentEncodedQueryItems_1,
        value?._id ?? ffi.nullptr);
  }

  static NSURLComponents new1(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLComponents1, _lib._sel_new1);
    return NSURLComponents._(_ret, _lib, retain: false, release: true);
  }

  static NSURLComponents allocWithZone_(
      Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSURLComponents1, _lib._sel_allocWithZone_1, zone);
    return NSURLComponents._(_ret, _lib, retain: false, release: true);
  }

  static NSURLComponents alloc(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLComponents1, _lib._sel_alloc1);
    return NSURLComponents._(_ret, _lib, retain: false, release: true);
  }
}

/// NSFileSecurity encapsulates a file system object's security information. NSFileSecurity and CFFileSecurity are toll-free bridged. Use the CFFileSecurity API for access to the low-level file security properties encapsulated by NSFileSecurity.
class NSFileSecurity extends NSObject {
  NSFileSecurity._(ffi.Pointer<ObjCObject> id, Foundation lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSFileSecurity] that points to the same underlying object as [other].
  static NSFileSecurity castFrom<T extends _ObjCWrapper>(T other) {
    return NSFileSecurity._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSFileSecurity] that wraps the given raw object pointer.
  static NSFileSecurity castFromPointer(
      Foundation lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSFileSecurity._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSFileSecurity].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSFileSecurity1);
  }

  NSFileSecurity? initWithCoder_(NSCoder coder) {
    final _ret =
        _lib._objc_msgSend_37(_id, _lib._sel_initWithCoder_1, coder._id);
    return _ret.address == 0
        ? null
        : NSFileSecurity._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSFileSecurity init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSFileSecurity._(_ret, _lib, retain: true, release: true);
  }

  static NSFileSecurity new1(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSFileSecurity1, _lib._sel_new1);
    return NSFileSecurity._(_ret, _lib, retain: false, release: true);
  }

  static NSFileSecurity allocWithZone_(
      Foundation _lib, ffi.Pointer<NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSFileSecurity1, _lib._sel_allocWithZone_1, zone);
    return NSFileSecurity._(_ret, _lib, retain: false, release: true);
  }

  static NSFileSecurity alloc(Foundation _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSFileSecurity1, _lib._sel_alloc1);
    return NSFileSecurity._(_ret, _lib, retain: false, release: true);
  }
}
