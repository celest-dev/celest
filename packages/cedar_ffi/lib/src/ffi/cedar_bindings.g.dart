// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Parses a policy set from a Cedar policy string into JSON.
@ffi.Native<CCedarPolicySetResult Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'cedar_parse_policy_set', isLeaf: true)
external CCedarPolicySetResult cedar_parse_policy_set(
  ffi.Pointer<ffi.Char> policies,
);

/// Initializes the Cedar policy engine with the given configuration.
///
/// This must be called exactly once before any other Cedar functions are called.
@ffi.Native<CInitResult Function(ffi.Pointer<CCedarConfig>)>(
    symbol: 'cedar_init', isLeaf: true)
external CInitResult cedar_init(
  ffi.Pointer<CCedarConfig> config,
);

/// De-initializes the Cedar policy engine.
///
/// This must be called exactly once when the Cedar policy engine is no longer needed.
@ffi.Native<ffi.Void Function(ffi.Pointer<CedarStore>)>(
    symbol: 'cedar_deinit', isLeaf: true)
external void cedar_deinit(
  ffi.Pointer<CedarStore> store,
);

/// Performs a Cedar authorization check.
///
/// This must be called after [cedar_init] has been called.
@ffi.Native<
    CAuthorizationDecision Function(ffi.Pointer<CedarStore>,
        ffi.Pointer<CCedarQuery>)>(symbol: 'cedar_is_authorized', isLeaf: true)
external CAuthorizationDecision cedar_is_authorized(
  ffi.Pointer<CedarStore> store,
  ffi.Pointer<CCedarQuery> query,
);

/// The result of parsing policies from a Cedar policy string into JSON
/// via [cedar_parse_policies].
final class CCedarPolicySetResult extends ffi.Struct {
  /// The number of policies in the policy set.
  @ffi.UintPtr()
  external int policies_len;

  /// The policies in the policy set, in JSON format.
  ///
  /// This is only valid if `policies_len` is greater than 0 and `errors_len` is 0.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> policies;

  /// The IDs for the `policies` in the policy set.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> policy_ids;

  /// The number of errors encountered while parsing the policy set.
  @ffi.UintPtr()
  external int errors_len;

  /// The errors (as strings) encountered while parsing the policy set.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> errors;
}

final class CCedarConfig extends ffi.Struct {
  /// The Cedar schema, in JSON format.
  ///
  /// This is a required field.
  external ffi.Pointer<ffi.Char> schema_json;

  /// The Cedar entities, in JSON format.
  ///
  /// Can be `null` to indicate no entities. Entities can be added later with [cedar_add_entities]
  /// or [cedar_set_entities].
  external ffi.Pointer<ffi.Char> entities_json;

  /// The Cedar policies, in JSON format.
  ///
  /// Can be `null` to indicate no policies. Policies can be added later with [cedar_add_policies]
  /// or [cedar_set_policies].
  external ffi.Pointer<ffi.Char> policies_json;

  /// Whether to validate the Cedar policies.
  @ffi.Bool()
  external bool validate;

  /// The log level to use for the Cedar policy engine.
  ///
  /// Must be one of: `OFF`, `ERROR`, `WARN`, `INFO`, `DEBUG`, `TRACE`.
  external ffi.Pointer<ffi.Char> log_level;
}

final class CCedarQuery extends ffi.Struct {
  /// The principal to check authorization for, in entity UID format.
  ///
  /// Can be `null` to indicate an anonymous principal.
  external ffi.Pointer<ffi.Char> principal_str;

  /// The resource to check authorization for, in entity UID format.
  ///
  /// Can be `null` to indicate an anonymous resource.
  external ffi.Pointer<ffi.Char> resource_str;

  /// The action to check authorization for, in entity UID format.
  ///
  /// Can be `null` to indicate an anonymous action.
  external ffi.Pointer<ffi.Char> action_str;

  /// The check's context, if any, in JSON format.
  ///
  /// Can be `null` to indicate no context.
  external ffi.Pointer<ffi.Char> context_json;

  /// The Cedar entities, in JSON format.
  ///
  /// Can be `null` to use the existing entities.
  external ffi.Pointer<ffi.Char> entities_json;

  /// The Cedar policies, in JSON format.
  ///
  /// Can be `null` to use the existing policies.
  external ffi.Pointer<ffi.Char> policies_json;
}

/// The result of initializing the Cedar policy engine via [cedar_init].
final class CInitResult extends ffi.Struct {
  /// Whether the operation succeeded.
  external ffi.Pointer<CedarStore> store;

  /// The error message, if any.
  ///
  /// Can be `null` to indicate no error.
  external ffi.Pointer<ffi.Char> error;
}

final class CedarStore extends ffi.Opaque {}

final class CAuthorizationDecision extends ffi.Struct {
  /// Whether the request is authorized.
  @ffi.Bool()
  external bool is_authorized;

  /// The error message, if any.
  ///
  /// If set, the authorization decision could not be made and no other
  /// fields should be used.
  external ffi.Pointer<ffi.Char> completion_error;

  /// The array of reasons.
  ///
  /// Will be `null` if there are no reasons.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> reasons;

  /// The length of the array of reasons.
  ///
  /// Will be `0` if there are no reasons.
  @ffi.UintPtr()
  external int reasons_len;

  /// The array of errors.
  ///
  /// Will be `null` if there are no errors.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> errors;

  /// The length of the array of errors.
  ///
  /// Will be `0` if there are no errors.
  @ffi.UintPtr()
  external int errors_len;
}
