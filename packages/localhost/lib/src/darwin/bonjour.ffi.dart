// ignore_for_file: type=lint
// ignore_for_file: return_of_invalid_type, unnecessary_non_null_assertion

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// !
/// @function dispatch_time
///
/// @abstract
/// Create a dispatch_time_t relative to the current value of the default or
/// wall time clock, or modify an existing dispatch_time_t.
///
/// @discussion
/// On Apple platforms, the default clock is based on mach_absolute_time().
///
/// @param when
/// An optional dispatch_time_t to add nanoseconds to. If DISPATCH_TIME_NOW is
/// passed, then dispatch_time() will use the default clock (which is based on
/// mach_absolute_time() on Apple platforms). If DISPATCH_WALLTIME_NOW is used,
/// dispatch_time() will use the value returned by gettimeofday(3).
/// dispatch_time(DISPATCH_WALLTIME_NOW, delta) is equivalent to
/// dispatch_walltime(NULL, delta).
///
/// @param delta
/// Nanoseconds to add.
///
/// @result
/// A new dispatch_time_t.
@ffi.Native<dispatch_time_t Function(dispatch_time_t, ffi.Int64)>()
external int dispatch_time(
  int when,
  int delta,
);

/// !
/// @function dispatch_walltime
///
/// @abstract
/// Create a dispatch_time_t using the wall clock.
///
/// @discussion
/// On Mac OS X the wall clock is based on gettimeofday(3).
///
/// @param when
/// A struct timespec to add time to. If NULL is passed, then
/// dispatch_walltime() will use the result of gettimeofday(3).
/// dispatch_walltime(NULL, delta) returns the same value as
/// dispatch_time(DISPATCH_WALLTIME_NOW, delta).
///
/// @param delta
/// Nanoseconds to add.
///
/// @result
/// A new dispatch_time_t.
@ffi.Native<dispatch_time_t Function(ffi.Pointer<timespec>, ffi.Int64)>()
external int dispatch_walltime(
  ffi.Pointer<timespec> when,
  int delta,
);

/// !
/// @function dispatch_retain
///
/// @abstract
/// Increment the reference count of a dispatch object.
///
/// @discussion
/// Calls to dispatch_retain() must be balanced with calls to
/// dispatch_release().
///
/// @param object
/// The object to retain.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_object_t)>()
external void dispatch_retain(
  dispatch_object_t object,
);

/// !
/// @function dispatch_release
///
/// @abstract
/// Decrement the reference count of a dispatch object.
///
/// @discussion
/// A dispatch object is asynchronously deallocated once all references are
/// released (i.e. the reference count becomes zero). The system does not
/// guarantee that a given client is the last or only reference to a given
/// object.
///
/// @param object
/// The object to release.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_object_t)>()
external void dispatch_release(
  dispatch_object_t object,
);

/// !
/// @function dispatch_get_context
///
/// @abstract
/// Returns the application defined context of the object.
///
/// @param object
/// The result of passing NULL in this parameter is undefined.
///
/// @result
/// The context of the object; may be NULL.
@ffi.Native<ffi.Pointer<ffi.Void> Function(dispatch_object_t)>()
external ffi.Pointer<ffi.Void> dispatch_get_context(
  dispatch_object_t object,
);

/// !
/// @function dispatch_set_context
///
/// @abstract
/// Associates an application defined context with the object.
///
/// @param object
/// The result of passing NULL in this parameter is undefined.
///
/// @param context
/// The new client defined context for the object. This may be NULL.
@ffi.Native<ffi.Void Function(dispatch_object_t, ffi.Pointer<ffi.Void>)>()
external void dispatch_set_context(
  dispatch_object_t object,
  ffi.Pointer<ffi.Void> context,
);

/// !
/// @function dispatch_set_finalizer_f
///
/// @abstract
/// Set the finalizer function for a dispatch object.
///
/// @param object
/// The dispatch object to modify.
/// The result of passing NULL in this parameter is undefined.
///
/// @param finalizer
/// The finalizer function pointer.
///
/// @discussion
/// A dispatch object's finalizer will be invoked on the object's target queue
/// after all references to the object have been released. This finalizer may be
/// used by the application to release any resources associated with the object,
/// such as freeing the object's context.
/// The context parameter passed to the finalizer function is the current
/// context of the dispatch object at the time the finalizer call is made.
@ffi.Native<ffi.Void Function(dispatch_object_t, dispatch_function_t)>()
external void dispatch_set_finalizer_f(
  dispatch_object_t object,
  dispatch_function_t finalizer,
);

/// !
/// @function dispatch_activate
///
/// @abstract
/// Activates the specified dispatch object.
///
/// @discussion
/// Dispatch objects such as queues and sources may be created in an inactive
/// state. Objects in this state have to be activated before any blocks
/// associated with them will be invoked.
///
/// The target queue of inactive objects can be changed using
/// dispatch_set_target_queue(). Change of target queue is no longer permitted
/// once an initially inactive object has been activated.
///
/// Calling dispatch_activate() on an active object has no effect.
/// Releasing the last reference count on an inactive object is undefined.
///
/// @param object
/// The object to be activated.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_object_t)>()
external void dispatch_activate(
  dispatch_object_t object,
);

/// !
/// @function dispatch_suspend
///
/// @abstract
/// Suspends the invocation of blocks on a dispatch object.
///
/// @discussion
/// A suspended object will not invoke any blocks associated with it. The
/// suspension of an object will occur after any running block associated with
/// the object completes.
///
/// Calls to dispatch_suspend() must be balanced with calls
/// to dispatch_resume().
///
/// @param object
/// The object to be suspended.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_object_t)>()
external void dispatch_suspend(
  dispatch_object_t object,
);

/// !
/// @function dispatch_resume
///
/// @abstract
/// Resumes the invocation of blocks on a dispatch object.
///
/// @discussion
/// Dispatch objects can be suspended with dispatch_suspend(), which increments
/// an internal suspension count. dispatch_resume() is the inverse operation,
/// and consumes suspension counts. When the last suspension count is consumed,
/// blocks associated with the object will be invoked again.
///
/// For backward compatibility reasons, dispatch_resume() on an inactive and not
/// otherwise suspended dispatch source object has the same effect as calling
/// dispatch_activate(). For new code, using dispatch_activate() is preferred.
///
/// If the specified object has zero suspension count and is not an inactive
/// source, this function will result in an assertion and the process being
/// terminated.
///
/// @param object
/// The object to be resumed.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_object_t)>()
external void dispatch_resume(
  dispatch_object_t object,
);

/// !
/// @function dispatch_set_qos_class_floor
///
/// @abstract
/// Sets the QOS class floor on a dispatch queue, source or workloop.
///
/// @discussion
/// The QOS class of workitems submitted to this object asynchronously will be
/// elevated to at least the specified QOS class floor. The QOS of the workitem
/// will be used if higher than the floor even when the workitem has been created
/// without "ENFORCE" semantics.
///
/// Setting the QOS class floor is equivalent to the QOS effects of configuring
/// a queue whose target queue has a QoS class set to the same value.
///
/// @param object
/// A dispatch queue, workloop, or source to configure.
/// The object must be inactive.
///
/// Passing another object type or an object that has been activated is undefined
/// and will cause the process to be terminated.
///
/// @param qos_class
/// A QOS class value:
/// - QOS_CLASS_USER_INTERACTIVE
/// - QOS_CLASS_USER_INITIATED
/// - QOS_CLASS_DEFAULT
/// - QOS_CLASS_UTILITY
/// - QOS_CLASS_BACKGROUND
/// Passing any other value is undefined.
///
/// @param relative_priority
/// A relative priority within the QOS class. This value is a negative
/// offset from the maximum supported scheduler priority for the given class.
/// Passing a value greater than zero or less than QOS_MIN_RELATIVE_PRIORITY
/// is undefined.
@ffi.Native<
    ffi.Void Function(dispatch_object_t, dispatch_qos_class_t, ffi.Int)>()
external void dispatch_set_qos_class_floor(
  dispatch_object_t object,
  int qos_class,
  int relative_priority,
);

/// !
/// @function dispatch_wait
///
/// @abstract
/// Wait synchronously for an object or until the specified timeout has elapsed.
///
/// @discussion
/// Type-generic macro that maps to dispatch_block_wait, dispatch_group_wait or
/// dispatch_semaphore_wait, depending on the type of the first argument.
/// See documentation for these functions for more details.
/// This function is unavailable for any other object type.
///
/// @param object
/// The object to wait on.
/// The result of passing NULL in this parameter is undefined.
///
/// @param timeout
/// When to timeout (see dispatch_time). As a convenience, there are the
/// DISPATCH_TIME_NOW and DISPATCH_TIME_FOREVER constants.
///
/// @result
/// Returns zero on success or non-zero on error (i.e. timed out).
@ffi.Native<ffi.IntPtr Function(ffi.Pointer<ffi.Void>, dispatch_time_t)>()
external int dispatch_wait(
  ffi.Pointer<ffi.Void> object,
  int timeout,
);

/// !
/// @function dispatch_cancel
///
/// @abstract
/// Cancel the specified object.
///
/// @discussion
/// Type-generic macro that maps to dispatch_block_cancel or
/// dispatch_source_cancel, depending on the type of the first argument.
/// See documentation for these functions for more details.
/// This function is unavailable for any other object type.
///
/// @param object
/// The object to cancel.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void dispatch_cancel(
  ffi.Pointer<ffi.Void> object,
);

/// !
/// @function dispatch_testcancel
///
/// @abstract
/// Test whether the specified object has been canceled
///
/// @discussion
/// Type-generic macro that maps to dispatch_block_testcancel or
/// dispatch_source_testcancel, depending on the type of the first argument.
/// See documentation for these functions for more details.
/// This function is unavailable for any other object type.
///
/// @param object
/// The object to test.
/// The result of passing NULL in this parameter is undefined.
///
/// @result
/// Non-zero if canceled and zero if not canceled.
@ffi.Native<ffi.IntPtr Function(ffi.Pointer<ffi.Void>)>()
external int dispatch_testcancel(
  ffi.Pointer<ffi.Void> object,
);

/// !
/// @function dispatch_debug
///
/// @abstract
/// Programmatically log debug information about a dispatch object.
///
/// @discussion
/// Programmatically log debug information about a dispatch object. By default,
/// the log output is sent to syslog at notice level. In the debug version of
/// the library, the log output is sent to a file in /var/tmp.
/// The log output destination can be configured via the LIBDISPATCH_LOG
/// environment variable, valid values are: YES, NO, syslog, stderr, file.
///
/// This function is deprecated and will be removed in a future release.
/// Objective-C callers may use -debugDescription instead.
///
/// @param object
/// The object to introspect.
///
/// @param message
/// The message to log above and beyond the introspection.
@ffi.Native<ffi.Void Function(dispatch_object_t, ffi.Pointer<ffi.Char>)>()
external void dispatch_debug(
  dispatch_object_t object,
  ffi.Pointer<ffi.Char> message,
);

@ffi.Native<
    ffi.Void Function(
        dispatch_object_t, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external void dispatch_debugv(
  dispatch_object_t object,
  ffi.Pointer<ffi.Char> message,
  ffi.Pointer<ffi.Char> ap,
);

/// !
/// @function dispatch_async_f
///
/// @abstract
/// Submits a function for asynchronous execution on a dispatch queue.
///
/// @discussion
/// See dispatch_async() for details.
///
/// @param queue
/// The target dispatch queue to which the function is submitted.
/// The system will hold a reference on the target queue until the function
/// has returned.
/// The result of passing NULL in this parameter is undefined.
///
/// @param context
/// The application-defined context parameter to pass to the function.
///
/// @param work
/// The application-defined function to invoke on the target queue. The first
/// parameter passed to this function is the context provided to
/// dispatch_async_f().
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<
    ffi.Void Function(
        dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>()
external void dispatch_async_f(
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t work,
);

/// !
/// @function dispatch_sync_f
///
/// @abstract
/// Submits a function for synchronous execution on a dispatch queue.
///
/// @discussion
/// See dispatch_sync() for details.
///
/// @param queue
/// The target dispatch queue to which the function is submitted.
/// The result of passing NULL in this parameter is undefined.
///
/// @param context
/// The application-defined context parameter to pass to the function.
///
/// @param work
/// The application-defined function to invoke on the target queue. The first
/// parameter passed to this function is the context provided to
/// dispatch_sync_f().
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<
    ffi.Void Function(
        dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>()
external void dispatch_sync_f(
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t work,
);

/// !
/// @function dispatch_async_and_wait_f
///
/// @abstract
/// Submits a function for synchronous execution on a dispatch queue.
///
/// @discussion
/// See dispatch_async_and_wait() for details.
///
/// @param queue
/// The target dispatch queue to which the function is submitted.
/// The result of passing NULL in this parameter is undefined.
///
/// @param context
/// The application-defined context parameter to pass to the function.
///
/// @param work
/// The application-defined function to invoke on the target queue. The first
/// parameter passed to this function is the context provided to
/// dispatch_async_and_wait_f().
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<
    ffi.Void Function(
        dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>()
external void dispatch_async_and_wait_f(
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t work,
);

/// !
/// @function dispatch_apply_f
///
/// @abstract
/// Submits a function to a dispatch queue for parallel invocation.
///
/// @discussion
/// See dispatch_apply() for details.
///
/// @param iterations
/// The number of iterations to perform.
///
/// @param queue
/// The dispatch queue to which the function is submitted.
/// The preferred value to pass is DISPATCH_APPLY_AUTO to automatically use
/// a queue appropriate for the calling thread.
///
/// @param context
/// The application-defined context parameter to pass to the function.
///
/// @param work
/// The application-defined function to invoke on the specified queue. The first
/// parameter passed to this function is the context provided to
/// dispatch_apply_f(). The second parameter passed to this function is the
/// current index of iteration.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<
    ffi.Void Function(
        ffi.Size,
        dispatch_queue_t,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> context, ffi.Size iteration)>>)>()
external void dispatch_apply_f(
  int iterations,
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> context, ffi.Size iteration)>>
      work,
);

/// !
/// @function dispatch_get_current_queue
///
/// @abstract
/// Returns the queue on which the currently executing block is running.
///
/// @discussion
/// Returns the queue on which the currently executing block is running.
///
/// When dispatch_get_current_queue() is called outside of the context of a
/// submitted block, it will return the default concurrent queue.
///
/// Recommended for debugging and logging purposes only:
/// The code must not make any assumptions about the queue returned, unless it
/// is one of the global queues or a queue the code has itself created.
/// The code must not assume that synchronous execution onto a queue is safe
/// from deadlock if that queue is not the one returned by
/// dispatch_get_current_queue().
///
/// When dispatch_get_current_queue() is called on the main thread, it may
/// or may not return the same value as dispatch_get_main_queue(). Comparing
/// the two is not a valid way to test whether code is executing on the
/// main thread (see dispatch_assert_queue() and dispatch_assert_queue_not()).
///
/// This function is deprecated and will be removed in a future release.
///
/// @result
/// Returns the current queue.
@ffi.Native<dispatch_queue_t Function()>()
external dispatch_queue_t dispatch_get_current_queue();

/// !
/// @function dispatch_get_global_queue
///
/// @abstract
/// Returns a well-known global concurrent queue of a given quality of service
/// class.
///
/// @discussion
/// See dispatch_queue_global_t.
///
/// @param identifier
/// A quality of service class defined in qos_class_t or a priority defined in
/// dispatch_queue_priority_t.
///
/// It is recommended to use quality of service class values to identify the
/// well-known global concurrent queues:
/// - QOS_CLASS_USER_INTERACTIVE
/// - QOS_CLASS_USER_INITIATED
/// - QOS_CLASS_DEFAULT
/// - QOS_CLASS_UTILITY
/// - QOS_CLASS_BACKGROUND
///
/// The global concurrent queues may still be identified by their priority,
/// which map to the following QOS classes:
/// - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED
/// - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT
/// - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY
/// - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND
///
/// @param flags
/// Reserved for future use. Passing any value other than zero may result in
/// a NULL return value.
///
/// @result
/// Returns the requested global queue or NULL if the requested global queue
/// does not exist.
@ffi.Native<dispatch_queue_global_t Function(ffi.IntPtr, ffi.UintPtr)>()
external dispatch_queue_global_t dispatch_get_global_queue(
  int identifier,
  int flags,
);

/// !
/// @function dispatch_queue_attr_make_initially_inactive
///
/// @abstract
/// Returns an attribute value which may be provided to dispatch_queue_create()
/// or dispatch_queue_create_with_target(), in order to make the created queue
/// initially inactive.
///
/// @discussion
/// Dispatch queues may be created in an inactive state. Queues in this state
/// have to be activated before any blocks associated with them will be invoked.
///
/// A queue in inactive state cannot be deallocated, dispatch_activate() must be
/// called before the last reference to a queue created with this attribute is
/// released.
///
/// The target queue of a queue in inactive state can be changed using
/// dispatch_set_target_queue(). Change of target queue is no longer permitted
/// once an initially inactive queue has been activated.
///
/// @param attr
/// A queue attribute value to be combined with the initially inactive attribute.
///
/// @return
/// Returns an attribute value which may be provided to dispatch_queue_create()
/// and dispatch_queue_create_with_target().
/// The new value combines the attributes specified by the 'attr' parameter with
/// the initially inactive attribute.
@ffi.Native<dispatch_queue_attr_t Function(dispatch_queue_attr_t)>()
external dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(
  dispatch_queue_attr_t attr,
);

/// !
/// @function dispatch_queue_attr_make_with_autorelease_frequency
///
/// @abstract
/// Returns a dispatch queue attribute value with the autorelease frequency
/// set to the specified value.
///
/// @discussion
/// When a queue uses the per-workitem autorelease frequency (either directly
/// or inherited from its target queue), any block submitted asynchronously to
/// this queue (via dispatch_async(), dispatch_barrier_async(),
/// dispatch_group_notify(), etc...) is executed as if surrounded by a individual
/// Objective-C <code>@autoreleasepool</code> scope.
///
/// Autorelease frequency has no effect on blocks that are submitted
/// synchronously to a queue (via dispatch_sync(), dispatch_barrier_sync()).
///
/// The global concurrent queues have the DISPATCH_AUTORELEASE_FREQUENCY_NEVER
/// behavior. Manually created dispatch queues use
/// DISPATCH_AUTORELEASE_FREQUENCY_INHERIT by default.
///
/// Queues created with this attribute cannot change target queues after having
/// been activated. See dispatch_set_target_queue() and dispatch_activate().
///
/// @param attr
/// A queue attribute value to be combined with the specified autorelease
/// frequency or NULL.
///
/// @param frequency
/// The requested autorelease frequency.
///
/// @return
/// Returns an attribute value which may be provided to dispatch_queue_create()
/// or NULL if an invalid autorelease frequency was requested.
/// This new value combines the attributes specified by the 'attr' parameter and
/// the chosen autorelease frequency.
@ffi.Native<dispatch_queue_attr_t Function(dispatch_queue_attr_t, ffi.Int32)>()
external dispatch_queue_attr_t
    dispatch_queue_attr_make_with_autorelease_frequency(
  dispatch_queue_attr_t attr,
  int frequency,
);

/// !
/// @function dispatch_queue_attr_make_with_qos_class
///
/// @abstract
/// Returns an attribute value which may be provided to dispatch_queue_create()
/// or dispatch_queue_create_with_target(), in order to assign a QOS class and
/// relative priority to the queue.
///
/// @discussion
/// When specified in this manner, the QOS class and relative priority take
/// precedence over those inherited from the dispatch queue's target queue (if
/// any) as long that does not result in a lower QOS class and relative priority.
///
/// The global queue priorities map to the following QOS classes:
/// - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED
/// - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT
/// - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY
/// - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND
///
/// Example:
/// <code>
/// dispatch_queue_t queue;
/// dispatch_queue_attr_t attr;
/// attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL,
/// QOS_CLASS_UTILITY, 0);
/// queue = dispatch_queue_create("com.example.myqueue", attr);
/// </code>
///
/// The QOS class and relative priority set this way on a queue have no effect on
/// blocks that are submitted synchronously to a queue (via dispatch_sync(),
/// dispatch_barrier_sync()).
///
/// @param attr
/// A queue attribute value to be combined with the QOS class, or NULL.
///
/// @param qos_class
/// A QOS class value:
/// - QOS_CLASS_USER_INTERACTIVE
/// - QOS_CLASS_USER_INITIATED
/// - QOS_CLASS_DEFAULT
/// - QOS_CLASS_UTILITY
/// - QOS_CLASS_BACKGROUND
/// Passing any other value results in NULL being returned.
///
/// @param relative_priority
/// A relative priority within the QOS class. This value is a negative
/// offset from the maximum supported scheduler priority for the given class.
/// Passing a value greater than zero or less than QOS_MIN_RELATIVE_PRIORITY
/// results in NULL being returned.
///
/// @return
/// Returns an attribute value which may be provided to dispatch_queue_create()
/// and dispatch_queue_create_with_target(), or NULL if an invalid QOS class was
/// requested.
/// The new value combines the attributes specified by the 'attr' parameter and
/// the new QOS class and relative priority.
@ffi.Native<
    dispatch_queue_attr_t Function(
        dispatch_queue_attr_t, dispatch_qos_class_t, ffi.Int)>()
external dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(
  dispatch_queue_attr_t attr,
  int qos_class,
  int relative_priority,
);

/// !
/// @function dispatch_queue_create_with_target
///
/// @abstract
/// Creates a new dispatch queue with a specified target queue.
///
/// @discussion
/// Dispatch queues created with the DISPATCH_QUEUE_SERIAL or a NULL attribute
/// invoke blocks serially in FIFO order.
///
/// Dispatch queues created with the DISPATCH_QUEUE_CONCURRENT attribute may
/// invoke blocks concurrently (similarly to the global concurrent queues, but
/// potentially with more overhead), and support barrier blocks submitted with
/// the dispatch barrier API, which e.g. enables the implementation of efficient
/// reader-writer schemes.
///
/// When a dispatch queue is no longer needed, it should be released with
/// dispatch_release(). Note that any pending blocks submitted asynchronously to
/// a queue will hold a reference to that queue. Therefore a queue will not be
/// deallocated until all pending blocks have finished.
///
/// When using a dispatch queue attribute @a attr specifying a QoS class (derived
/// from the result of dispatch_queue_attr_make_with_qos_class()), passing the
/// result of dispatch_get_global_queue() in @a target will ignore the QoS class
/// of that global queue and will use the global queue with the QoS class
/// specified by attr instead.
///
/// Queues created with dispatch_queue_create_with_target() cannot have their
/// target queue changed, unless created inactive (See
/// dispatch_queue_attr_make_initially_inactive()), in which case the target
/// queue can be changed until the newly created queue is activated with
/// dispatch_activate().
///
/// @param label
/// A string label to attach to the queue.
/// This parameter is optional and may be NULL.
///
/// @param attr
/// A predefined attribute such as DISPATCH_QUEUE_SERIAL,
/// DISPATCH_QUEUE_CONCURRENT, or the result of a call to
/// a dispatch_queue_attr_make_with_* function.
///
/// @param target
/// The target queue for the newly created queue. The target queue is retained.
/// If this parameter is DISPATCH_TARGET_QUEUE_DEFAULT, sets the queue's target
/// queue to the default target queue for the given queue type.
///
/// @result
/// The newly created dispatch queue.
@ffi.Native<
    dispatch_queue_t Function(
        ffi.Pointer<ffi.Char>, dispatch_queue_attr_t, dispatch_queue_t)>()
external dispatch_queue_t dispatch_queue_create_with_target(
  ffi.Pointer<ffi.Char> label,
  dispatch_queue_attr_t attr,
  dispatch_queue_t target,
);

/// !
/// @function dispatch_queue_create
///
/// @abstract
/// Creates a new dispatch queue to which blocks may be submitted.
///
/// @discussion
/// Dispatch queues created with the DISPATCH_QUEUE_SERIAL or a NULL attribute
/// invoke blocks serially in FIFO order.
///
/// Dispatch queues created with the DISPATCH_QUEUE_CONCURRENT attribute may
/// invoke blocks concurrently (similarly to the global concurrent queues, but
/// potentially with more overhead), and support barrier blocks submitted with
/// the dispatch barrier API, which e.g. enables the implementation of efficient
/// reader-writer schemes.
///
/// When a dispatch queue is no longer needed, it should be released with
/// dispatch_release(). Note that any pending blocks submitted asynchronously to
/// a queue will hold a reference to that queue. Therefore a queue will not be
/// deallocated until all pending blocks have finished.
///
/// Passing the result of the dispatch_queue_attr_make_with_qos_class() function
/// to the attr parameter of this function allows a quality of service class and
/// relative priority to be specified for the newly created queue.
/// The quality of service class so specified takes precedence over the quality
/// of service class of the newly created dispatch queue's target queue (if any)
/// as long that does not result in a lower QOS class and relative priority.
///
/// When no quality of service class is specified, the target queue of a newly
/// created dispatch queue is the default priority global concurrent queue.
///
/// Unless explicitly specified via the attribute, queues are created active.
///
/// @param label
/// A string label to attach to the queue.
/// This parameter is optional and may be NULL.
///
/// @param attr
/// A predefined attribute such as DISPATCH_QUEUE_SERIAL,
/// DISPATCH_QUEUE_CONCURRENT, or the result of a call to
/// a dispatch_queue_attr_make_with_* function.
///
/// @result
/// The newly created dispatch queue.
@ffi.Native<
    dispatch_queue_t Function(ffi.Pointer<ffi.Char>, dispatch_queue_attr_t)>()
external dispatch_queue_t dispatch_queue_create(
  ffi.Pointer<ffi.Char> label,
  dispatch_queue_attr_t attr,
);

/// !
/// @function dispatch_queue_get_label
///
/// @abstract
/// Returns the label of the given queue, as specified when the queue was
/// created, or the empty string if a NULL label was specified.
///
/// Passing DISPATCH_CURRENT_QUEUE_LABEL will return the label of the current
/// queue.
///
/// @param queue
/// The queue to query, or DISPATCH_CURRENT_QUEUE_LABEL.
///
/// @result
/// The label of the queue.
@ffi.Native<ffi.Pointer<ffi.Char> Function(dispatch_queue_t)>()
external ffi.Pointer<ffi.Char> dispatch_queue_get_label(
  dispatch_queue_t queue,
);

/// !
/// @function dispatch_queue_get_qos_class
///
/// @abstract
/// Returns the QOS class and relative priority of the given queue.
///
/// @discussion
/// If the given queue was created with an attribute value returned from
/// dispatch_queue_attr_make_with_qos_class(), this function returns the QOS
/// class and relative priority specified at that time; for any other attribute
/// value it returns a QOS class of QOS_CLASS_UNSPECIFIED and a relative
/// priority of 0.
///
/// If the given queue is one of the global queues, this function returns its
/// assigned QOS class value as documented under dispatch_get_global_queue() and
/// a relative priority of 0; in the case of the main queue it returns the QOS
/// value provided by qos_class_main() and a relative priority of 0.
///
/// @param queue
/// The queue to query.
///
/// @param relative_priority_ptr
/// A pointer to an int variable to be filled with the relative priority offset
/// within the QOS class, or NULL.
///
/// @return
/// A QOS class value:
/// - QOS_CLASS_USER_INTERACTIVE
/// - QOS_CLASS_USER_INITIATED
/// - QOS_CLASS_DEFAULT
/// - QOS_CLASS_UTILITY
/// - QOS_CLASS_BACKGROUND
/// - QOS_CLASS_UNSPECIFIED
@ffi.Native<
    dispatch_qos_class_t Function(dispatch_queue_t, ffi.Pointer<ffi.Int>)>()
external int dispatch_queue_get_qos_class(
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Int> relative_priority_ptr,
);

/// !
/// @function dispatch_set_target_queue
///
/// @abstract
/// Sets the target queue for the given object.
///
/// @discussion
/// An object's target queue is responsible for processing the object.
///
/// When no quality of service class and relative priority is specified for a
/// dispatch queue at the time of creation, a dispatch queue's quality of service
/// class is inherited from its target queue. The dispatch_get_global_queue()
/// function may be used to obtain a target queue of a specific quality of
/// service class, however the use of dispatch_queue_attr_make_with_qos_class()
/// is recommended instead.
///
/// Blocks submitted to a serial queue whose target queue is another serial
/// queue will not be invoked concurrently with blocks submitted to the target
/// queue or to any other queue with that same target queue.
///
/// The result of introducing a cycle into the hierarchy of target queues is
/// undefined.
///
/// A dispatch source's target queue specifies where its event handler and
/// cancellation handler blocks will be submitted.
///
/// A dispatch I/O channel's target queue specifies where where its I/O
/// operations are executed. If the channel's target queue's priority is set to
/// DISPATCH_QUEUE_PRIORITY_BACKGROUND, then the I/O operations performed by
/// dispatch_io_read() or dispatch_io_write() on that queue will be
/// throttled when there is I/O contention.
///
/// For all other dispatch object types, the only function of the target queue
/// is to determine where an object's finalizer function is invoked.
///
/// In general, changing the target queue of an object is an asynchronous
/// operation that doesn't take effect immediately, and doesn't affect blocks
/// already associated with the specified object.
///
/// However, if an object is inactive at the time dispatch_set_target_queue() is
/// called, then the target queue change takes effect immediately, and will
/// affect blocks already associated with the specified object. After an
/// initially inactive object has been activated, calling
/// dispatch_set_target_queue() results in an assertion and the process being
/// terminated.
///
/// If a dispatch queue is active and targeted by other dispatch objects,
/// changing its target queue results in undefined behavior.  Instead, it is
/// recommended to create dispatch objects in an inactive state, set up the
/// relevant target queues and then activate them.
///
/// @param object
/// The object to modify.
/// The result of passing NULL in this parameter is undefined.
///
/// @param queue
/// The new target queue for the object. The queue is retained, and the
/// previous target queue, if any, is released.
/// If queue is DISPATCH_TARGET_QUEUE_DEFAULT, set the object's target queue
/// to the default target queue for the given object type.
@ffi.Native<ffi.Void Function(dispatch_object_t, dispatch_queue_t)>()
external void dispatch_set_target_queue(
  dispatch_object_t object,
  dispatch_queue_t queue,
);

/// !
/// @function dispatch_main
///
/// @abstract
/// Execute blocks submitted to the main queue.
///
/// @discussion
/// This function "parks" the main thread and waits for blocks to be submitted
/// to the main queue. This function never returns.
///
/// Applications that call NSApplicationMain() or CFRunLoopRun() on the
/// main thread do not need to call dispatch_main().
@ffi.Native<ffi.Void Function()>()
external void dispatch_main();

/// !
/// @function dispatch_after_f
///
/// @abstract
/// Schedule a function for execution on a given queue at a specified time.
///
/// @discussion
/// See dispatch_after() for details.
///
/// @param when
/// A temporal milestone returned by dispatch_time() or dispatch_walltime().
///
/// @param queue
/// A queue to which the given function will be submitted at the specified time.
/// The result of passing NULL in this parameter is undefined.
///
/// @param context
/// The application-defined context parameter to pass to the function.
///
/// @param work
/// The application-defined function to invoke on the target queue. The first
/// parameter passed to this function is the context provided to
/// dispatch_after_f().
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<
    ffi.Void Function(dispatch_time_t, dispatch_queue_t, ffi.Pointer<ffi.Void>,
        dispatch_function_t)>()
external void dispatch_after_f(
  int when,
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t work,
);

/// !
/// @function dispatch_barrier_async_f
///
/// @abstract
/// Submits a barrier function for asynchronous execution on a dispatch queue.
///
/// @discussion
/// Submits a function to a dispatch queue like dispatch_async_f(), but marks
/// that function as a barrier (relevant only on DISPATCH_QUEUE_CONCURRENT
/// queues).
///
/// See dispatch_async_f() for details and "Dispatch Barrier API" for a
/// description of the barrier semantics.
///
/// @param queue
/// The target dispatch queue to which the function is submitted.
/// The system will hold a reference on the target queue until the function
/// has returned.
/// The result of passing NULL in this parameter is undefined.
///
/// @param context
/// The application-defined context parameter to pass to the function.
///
/// @param work
/// The application-defined function to invoke on the target queue. The first
/// parameter passed to this function is the context provided to
/// dispatch_barrier_async_f().
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<
    ffi.Void Function(
        dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>()
external void dispatch_barrier_async_f(
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t work,
);

/// !
/// @function dispatch_barrier_sync_f
///
/// @abstract
/// Submits a barrier function for synchronous execution on a dispatch queue.
///
/// @discussion
/// Submits a function to a dispatch queue like dispatch_sync_f(), but marks that
/// fuction as a barrier (relevant only on DISPATCH_QUEUE_CONCURRENT queues).
///
/// See dispatch_sync_f() for details.
///
/// @param queue
/// The target dispatch queue to which the function is submitted.
/// The result of passing NULL in this parameter is undefined.
///
/// @param context
/// The application-defined context parameter to pass to the function.
///
/// @param work
/// The application-defined function to invoke on the target queue. The first
/// parameter passed to this function is the context provided to
/// dispatch_barrier_sync_f().
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<
    ffi.Void Function(
        dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>()
external void dispatch_barrier_sync_f(
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t work,
);

/// !
/// @function dispatch_barrier_async_and_wait_f
///
/// @abstract
/// Submits a function for synchronous execution on a dispatch queue.
///
/// @discussion
/// Submits a function to a dispatch queue like dispatch_async_and_wait_f(), but
/// marks that function as a barrier (relevant only on DISPATCH_QUEUE_CONCURRENT
/// queues).
///
/// See "Dispatch Barrier API" for a description of the barrier semantics.
///
/// @param queue
/// The target dispatch queue to which the function is submitted.
/// The result of passing NULL in this parameter is undefined.
///
/// @param context
/// The application-defined context parameter to pass to the function.
///
/// @param work
/// The application-defined function to invoke on the target queue. The first
/// parameter passed to this function is the context provided to
/// dispatch_barrier_async_and_wait_f().
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<
    ffi.Void Function(
        dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>()
external void dispatch_barrier_async_and_wait_f(
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t work,
);

/// !
/// @function dispatch_queue_set_specific
///
/// @abstract
/// Associates a subsystem-specific context with a dispatch queue, for a key
/// unique to the subsystem.
///
/// @discussion
/// The specified destructor will be invoked with the context on the default
/// priority global concurrent queue when a new context is set for the same key,
/// or after all references to the queue have been released.
///
/// @param queue
/// The dispatch queue to modify.
/// The result of passing NULL in this parameter is undefined.
///
/// @param key
/// The key to set the context for, typically a pointer to a static variable
/// specific to the subsystem. Keys are only compared as pointers and never
/// dereferenced. Passing a string constant directly is not recommended.
/// The NULL key is reserved and attempts to set a context for it are ignored.
///
/// @param context
/// The new subsystem-specific context for the object. This may be NULL.
///
/// @param destructor
/// The destructor function pointer. This may be NULL and is ignored if context
/// is NULL.
@ffi.Native<
    ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Void>, dispatch_function_t)>()
external void dispatch_queue_set_specific(
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t destructor,
);

/// !
/// @function dispatch_queue_get_specific
///
/// @abstract
/// Returns the subsystem-specific context associated with a dispatch queue, for
/// a key unique to the subsystem.
///
/// @discussion
/// Returns the context for the specified key if it has been set on the specified
/// queue.
///
/// @param queue
/// The dispatch queue to query.
/// The result of passing NULL in this parameter is undefined.
///
/// @param key
/// The key to get the context for, typically a pointer to a static variable
/// specific to the subsystem. Keys are only compared as pointers and never
/// dereferenced. Passing a string constant directly is not recommended.
///
/// @result
/// The context for the specified key or NULL if no context was found.
@ffi.Native<
    ffi.Pointer<ffi.Void> Function(dispatch_queue_t, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<ffi.Void> dispatch_queue_get_specific(
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> key,
);

/// !
/// @function dispatch_get_specific
///
/// @abstract
/// Returns the current subsystem-specific context for a key unique to the
/// subsystem.
///
/// @discussion
/// When called from a block executing on a queue, returns the context for the
/// specified key if it has been set on the queue, otherwise returns the result
/// of dispatch_get_specific() executed on the queue's target queue or NULL
/// if the current queue is a global concurrent queue.
///
/// @param key
/// The key to get the context for, typically a pointer to a static variable
/// specific to the subsystem. Keys are only compared as pointers and never
/// dereferenced. Passing a string constant directly is not recommended.
///
/// @result
/// The context for the specified key or NULL if no context was found.
@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<ffi.Void> dispatch_get_specific(
  ffi.Pointer<ffi.Void> key,
);

/// !
/// @function dispatch_assert_queue
///
/// @abstract
/// Verifies that the current block is executing on a given dispatch queue.
///
/// @discussion
/// Some code expects to be run on a specific dispatch queue. This function
/// verifies that that expectation is true.
///
/// If the currently executing block was submitted to the specified queue or to
/// any queue targeting it (see dispatch_set_target_queue()), this function
/// returns.
///
/// If the currently executing block was submitted with a synchronous API
/// (dispatch_sync(), dispatch_barrier_sync(), ...), the context of the
/// submitting block is also evaluated (recursively).
/// If a synchronously submitting block is found that was itself submitted to
/// the specified queue or to any queue targeting it, this function returns.
///
/// Otherwise this function asserts: it logs an explanation to the system log and
/// terminates the application.
///
/// Passing the result of dispatch_get_main_queue() to this function verifies
/// that the current block was submitted to the main queue, or to a queue
/// targeting it, or is running on the main thread (in any context).
///
/// When dispatch_assert_queue() is called outside of the context of a
/// submitted block (for example from the context of a thread created manually
/// with pthread_create()) then this function will also assert and terminate
/// the application.
///
/// The variant dispatch_assert_queue_debug() is compiled out when the
/// preprocessor macro NDEBUG is defined. (See also assert(3)).
///
/// @param queue
/// The dispatch queue that the current block is expected to run on.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_queue_t)>()
external void dispatch_assert_queue(
  dispatch_queue_t queue,
);

/// !
/// @function dispatch_assert_queue_barrier
///
/// @abstract
/// Verifies that the current block is executing on a given dispatch queue,
/// and that the block acts as a barrier on that queue.
///
/// @discussion
/// This behaves exactly like dispatch_assert_queue(), with the additional check
/// that the current block acts as a barrier on the specified queue, which is
/// always true if the specified queue is serial (see DISPATCH_BLOCK_BARRIER or
/// dispatch_barrier_async() for details).
///
/// The variant dispatch_assert_queue_barrier_debug() is compiled out when the
/// preprocessor macro NDEBUG is defined. (See also assert()).
///
/// @param queue
/// The dispatch queue that the current block is expected to run as a barrier on.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_queue_t)>()
external void dispatch_assert_queue_barrier(
  dispatch_queue_t queue,
);

/// !
/// @function dispatch_assert_queue_not
///
/// @abstract
/// Verifies that the current block is not executing on a given dispatch queue.
///
/// @discussion
/// This function is the equivalent of dispatch_assert_queue() with the test for
/// equality inverted. That means that it will terminate the application when
/// dispatch_assert_queue() would return, and vice-versa. See discussion there.
///
/// The variant dispatch_assert_queue_not_debug() is compiled out when the
/// preprocessor macro NDEBUG is defined. (See also assert(3)).
///
/// @param queue
/// The dispatch queue that the current block is expected not to run on.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_queue_t)>()
external void dispatch_assert_queue_not(
  dispatch_queue_t queue,
);

/// @function dispatch_allow_send_signals
///
/// @discussion
/// This function provides the calling process an ability to send signals to
/// it's pthread worker threads created to service incoming work to dispatch,
/// including those which were already created prior to this function call
/// and those who may be created in the future. After a call to this function
/// returns successfully, this ability is retained for the lifetime of the
/// calling process.
/// Regular UNIX calls still need to be used to manipulate signal mask of
/// each individual pthread worker thread to allow delivery of a specific
/// signal to that thread.
///
/// @param preserve_signum
/// Dispatch and its kernel runtime subsystem manages a pool of pthread
/// worker threads which are reused for handling incoming work to dispatch.
/// The signal number specified here is used internally by this subsystem to
/// preserve sigmask of the pthread worker threads across their reuse.
///
/// In other words, if a pthread worker thread unblocks delivery of
/// @preserve_signum using regular UNIX calls after a call to this
/// function using the same @preserve_signum returns successfully,
/// that @preserve_signum remains unblocked across that thread's
/// reuse until it is further modified by regular UNIX calls.
/// Therefore, it avoids the need to call regular UNIX calls to
/// unblock delivery of @preserve_signum every time that thread
/// is reused. The specific signal @preserve_signum can be sent
/// to that specific pthread worker thread using pthread_kill().
///
/// The following code illustrates an expected usage of this API.
///
/// <code>
///
/// // Enable sending signals to dispatch pthread worker threads.
/// int ret = dispatch_allow_send_signals(sig);
/// // Validate ret.
///
/// dispatch_async(q, ^{
/// // Unblock sig for this worker thread if not already done.
/// // Such a state could be saved in TSD or globally.
/// mask = sigmask(sig);
/// pthread_sigmask(SIG_UNBLOCK, &mask, NULL);
/// // busy with some work. Can receive signal sig.
/// // If this worker thread is re-used later, it does not
/// // not need to call pthread_sigmask again to unblock delivery
/// // of signal sig.
/// }
///
/// This function returns 0 upon success and -1 with an errno otherwise.
/// Possible error codes are as below :
///
/// EINVAL     : @preserve_signum is prohibited and is not allowed to be preserved
/// across the thread's reuse.
/// ENOTSUP    : The underlying kernel does not support this functionality.
///
/// </code>
@ffi.Native<ffi.Int Function(ffi.Int)>()
external int dispatch_allow_send_signals(
  int preserve_signum,
);

/// !
/// @function dispatch_source_create
///
/// @abstract
/// Creates a new dispatch source to monitor low-level system objects and auto-
/// matically submit a handler block to a dispatch queue in response to events.
///
/// @discussion
/// Dispatch sources are not reentrant. Any events received while the dispatch
/// source is suspended or while the event handler block is currently executing
/// will be coalesced and delivered after the dispatch source is resumed or the
/// event handler block has returned.
///
/// Dispatch sources are created in an inactive state. After creating the
/// source and setting any desired attributes (i.e. the handler, context, etc.),
/// a call must be made to dispatch_activate() in order to begin event delivery.
///
/// A source must have been activated before being disposed.
///
/// Calling dispatch_set_target_queue() on a source once it has been activated
/// is not allowed (see dispatch_activate() and dispatch_set_target_queue()).
///
/// For backward compatibility reasons, dispatch_resume() on an inactive,
/// and not otherwise suspended source has the same effect as calling
/// dispatch_activate(). For new code, using dispatch_activate() is preferred.
///
/// @param type
/// Declares the type of the dispatch source. Must be one of the defined
/// dispatch_source_type_t constants.
///
/// @param handle
/// The underlying system handle to monitor. The interpretation of this argument
/// is determined by the constant provided in the type parameter.
///
/// @param mask
/// A mask of flags specifying which events are desired. The interpretation of
/// this argument is determined by the constant provided in the type parameter.
///
/// @param queue
/// The dispatch queue to which the event handler block will be submitted.
/// If queue is DISPATCH_TARGET_QUEUE_DEFAULT, the source will submit the event
/// handler block to the default priority global queue.
///
/// @result
/// The newly created dispatch source. Or NULL if invalid arguments are passed.
@ffi.Native<
    dispatch_source_t Function(
        dispatch_source_type_t, ffi.UintPtr, ffi.UintPtr, dispatch_queue_t)>()
external dispatch_source_t dispatch_source_create(
  dispatch_source_type_t type,
  int handle,
  int mask,
  dispatch_queue_t queue,
);

/// !
/// @function dispatch_source_set_event_handler_f
///
/// @abstract
/// Sets the event handler function for the given dispatch source.
///
/// @param source
/// The dispatch source to modify.
/// The result of passing NULL in this parameter is undefined.
///
/// @param handler
/// The event handler function to submit to the source's target queue.
/// The context parameter passed to the event handler function is the context of
/// the dispatch source current at the time the event handler was set.
@ffi.Native<ffi.Void Function(dispatch_source_t, dispatch_function_t)>()
external void dispatch_source_set_event_handler_f(
  dispatch_source_t source,
  dispatch_function_t handler,
);

/// !
/// @function dispatch_source_set_cancel_handler_f
///
/// @abstract
/// Sets the cancellation handler function for the given dispatch source.
///
/// @discussion
/// See dispatch_source_set_cancel_handler() for more details.
///
/// @param source
/// The dispatch source to modify.
/// The result of passing NULL in this parameter is undefined.
///
/// @param handler
/// The cancellation handler function to submit to the source's target queue.
/// The context parameter passed to the event handler function is the current
/// context of the dispatch source at the time the handler call is made.
@ffi.Native<ffi.Void Function(dispatch_source_t, dispatch_function_t)>()
external void dispatch_source_set_cancel_handler_f(
  dispatch_source_t source,
  dispatch_function_t handler,
);

/// !
/// @function dispatch_source_cancel
///
/// @abstract
/// Asynchronously cancel the dispatch source, preventing any further invocation
/// of its event handler block.
///
/// @discussion
/// Cancellation prevents any further invocation of the event handler block for
/// the specified dispatch source, but does not interrupt an event handler
/// block that is already in progress.
///
/// The cancellation handler is submitted to the source's target queue once the
/// the source's event handler has finished, indicating it is now safe to close
/// the source's handle (i.e. file descriptor or mach port).
///
/// See dispatch_source_set_cancel_handler() for more information.
///
/// @param source
/// The dispatch source to be canceled.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_source_t)>()
external void dispatch_source_cancel(
  dispatch_source_t source,
);

/// !
/// @function dispatch_source_testcancel
///
/// @abstract
/// Tests whether the given dispatch source has been canceled.
///
/// @param source
/// The dispatch source to be tested.
/// The result of passing NULL in this parameter is undefined.
///
/// @result
/// Non-zero if canceled and zero if not canceled.
@ffi.Native<ffi.IntPtr Function(dispatch_source_t)>()
external int dispatch_source_testcancel(
  dispatch_source_t source,
);

/// !
/// @function dispatch_source_get_handle
///
/// @abstract
/// Returns the underlying system handle associated with this dispatch source.
///
/// @param source
/// The result of passing NULL in this parameter is undefined.
///
/// @result
/// The return value should be interpreted according to the type of the dispatch
/// source, and may be one of the following handles:
///
/// DISPATCH_SOURCE_TYPE_DATA_ADD:        n/a
/// DISPATCH_SOURCE_TYPE_DATA_OR:         n/a
/// DISPATCH_SOURCE_TYPE_DATA_REPLACE:    n/a
/// DISPATCH_SOURCE_TYPE_MACH_SEND:       mach port (mach_port_t)
/// DISPATCH_SOURCE_TYPE_MACH_RECV:       mach port (mach_port_t)
/// DISPATCH_SOURCE_TYPE_MEMORYPRESSURE   n/a
/// DISPATCH_SOURCE_TYPE_PROC:            process identifier (pid_t)
/// DISPATCH_SOURCE_TYPE_READ:            file descriptor (int)
/// DISPATCH_SOURCE_TYPE_SIGNAL:          signal number (int)
/// DISPATCH_SOURCE_TYPE_TIMER:           n/a
/// DISPATCH_SOURCE_TYPE_VNODE:           file descriptor (int)
/// DISPATCH_SOURCE_TYPE_WRITE:           file descriptor (int)
@ffi.Native<ffi.UintPtr Function(dispatch_source_t)>()
external int dispatch_source_get_handle(
  dispatch_source_t source,
);

/// !
/// @function dispatch_source_get_mask
///
/// @abstract
/// Returns the mask of events monitored by the dispatch source.
///
/// @param source
/// The result of passing NULL in this parameter is undefined.
///
/// @result
/// The return value should be interpreted according to the type of the dispatch
/// source, and may be one of the following flag sets:
///
/// DISPATCH_SOURCE_TYPE_DATA_ADD:        n/a
/// DISPATCH_SOURCE_TYPE_DATA_OR:         n/a
/// DISPATCH_SOURCE_TYPE_DATA_REPLACE:    n/a
/// DISPATCH_SOURCE_TYPE_MACH_SEND:       dispatch_source_mach_send_flags_t
/// DISPATCH_SOURCE_TYPE_MACH_RECV:       dispatch_source_mach_recv_flags_t
/// DISPATCH_SOURCE_TYPE_MEMORYPRESSURE   dispatch_source_memorypressure_flags_t
/// DISPATCH_SOURCE_TYPE_PROC:            dispatch_source_proc_flags_t
/// DISPATCH_SOURCE_TYPE_READ:            n/a
/// DISPATCH_SOURCE_TYPE_SIGNAL:          n/a
/// DISPATCH_SOURCE_TYPE_TIMER:           dispatch_source_timer_flags_t
/// DISPATCH_SOURCE_TYPE_VNODE:           dispatch_source_vnode_flags_t
/// DISPATCH_SOURCE_TYPE_WRITE:           n/a
@ffi.Native<ffi.UintPtr Function(dispatch_source_t)>()
external int dispatch_source_get_mask(
  dispatch_source_t source,
);

/// !
/// @function dispatch_source_get_data
///
/// @abstract
/// Returns pending data for the dispatch source.
///
/// @discussion
/// This function is intended to be called from within the event handler block.
/// The result of calling this function outside of the event handler callback is
/// undefined.
///
/// @param source
/// The result of passing NULL in this parameter is undefined.
///
/// @result
/// The return value should be interpreted according to the type of the dispatch
/// source, and may be one of the following:
///
/// DISPATCH_SOURCE_TYPE_DATA_ADD:        application defined data
/// DISPATCH_SOURCE_TYPE_DATA_OR:         application defined data
/// DISPATCH_SOURCE_TYPE_DATA_REPLACE:    application defined data
/// DISPATCH_SOURCE_TYPE_MACH_SEND:       dispatch_source_mach_send_flags_t
/// DISPATCH_SOURCE_TYPE_MACH_RECV:       dispatch_source_mach_recv_flags_t
/// DISPATCH_SOURCE_TYPE_MEMORYPRESSURE   dispatch_source_memorypressure_flags_t
/// DISPATCH_SOURCE_TYPE_PROC:            dispatch_source_proc_flags_t
/// DISPATCH_SOURCE_TYPE_READ:            estimated bytes available to read
/// DISPATCH_SOURCE_TYPE_SIGNAL:          number of signals delivered since
/// the last handler invocation
/// DISPATCH_SOURCE_TYPE_TIMER:           number of times the timer has fired
/// since the last handler invocation
/// DISPATCH_SOURCE_TYPE_VNODE:           dispatch_source_vnode_flags_t
/// DISPATCH_SOURCE_TYPE_WRITE:           estimated buffer space available
@ffi.Native<ffi.UintPtr Function(dispatch_source_t)>()
external int dispatch_source_get_data(
  dispatch_source_t source,
);

/// !
/// @function dispatch_source_merge_data
///
/// @abstract
/// Merges data into a dispatch source of type DISPATCH_SOURCE_TYPE_DATA_ADD,
/// DISPATCH_SOURCE_TYPE_DATA_OR or DISPATCH_SOURCE_TYPE_DATA_REPLACE,
/// and submits its event handler block to its target queue.
///
/// @param source
/// The result of passing NULL in this parameter is undefined.
///
/// @param value
/// The value to coalesce with the pending data using a logical OR or an ADD
/// as specified by the dispatch source type. A value of zero has no effect
/// and will not result in the submission of the event handler block.
@ffi.Native<ffi.Void Function(dispatch_source_t, ffi.UintPtr)>()
external void dispatch_source_merge_data(
  dispatch_source_t source,
  int value,
);

/// !
/// @function dispatch_source_set_timer
///
/// @abstract
/// Sets a start time, interval, and leeway value for a timer source.
///
/// @discussion
/// Once this function returns, any pending source data accumulated for the
/// previous timer values has been cleared; the next fire of the timer will
/// occur at 'start', and every 'interval' nanoseconds thereafter until the
/// timer source is canceled.
///
/// Any fire of the timer may be delayed by the system in order to improve power
/// consumption and system performance. The upper limit to the allowable delay
/// may be configured with the 'leeway' argument, the lower limit is under the
/// control of the system.
///
/// For the initial timer fire at 'start', the upper limit to the allowable
/// delay is set to 'leeway' nanoseconds. For the subsequent timer fires at
/// 'start' + N * 'interval', the upper limit is MIN('leeway','interval'/2).
///
/// The lower limit to the allowable delay may vary with process state such as
/// visibility of application UI. If the specified timer source was created with
/// a mask of DISPATCH_TIMER_STRICT, the system will make a best effort to
/// strictly observe the provided 'leeway' value even if it is smaller than the
/// current lower limit. Note that a minimal amount of delay is to be expected
/// even if this flag is specified.
///
/// The 'start' argument also determines which clock will be used for the timer:
/// If 'start' is DISPATCH_TIME_NOW or was created with dispatch_time(3), the
/// timer is based on up time (which is obtained from mach_absolute_time() on
/// Apple platforms). If 'start' was created with dispatch_walltime(3), the
/// timer is based on gettimeofday(3).
///
/// Calling this function has no effect if the timer source has already been
/// canceled.
///
/// @param start
/// The start time of the timer. See dispatch_time() and dispatch_walltime()
/// for more information.
///
/// @param interval
/// The nanosecond interval for the timer. Use DISPATCH_TIME_FOREVER for a
/// one-shot timer.
///
/// @param leeway
/// The nanosecond leeway for the timer.
@ffi.Native<
    ffi.Void Function(
        dispatch_source_t, dispatch_time_t, ffi.Uint64, ffi.Uint64)>()
external void dispatch_source_set_timer(
  dispatch_source_t source,
  int start,
  int interval,
  int leeway,
);

/// !
/// @function dispatch_source_set_registration_handler_f
///
/// @abstract
/// Sets the registration handler function for the given dispatch source.
///
/// @discussion
/// See dispatch_source_set_registration_handler() for more details.
///
/// @param source
/// The dispatch source to modify.
/// The result of passing NULL in this parameter is undefined.
///
/// @param handler
/// The registration handler function to submit to the source's target queue.
/// The context parameter passed to the registration handler function is the
/// current context of the dispatch source at the time the handler call is made.
@ffi.Native<ffi.Void Function(dispatch_source_t, dispatch_function_t)>()
external void dispatch_source_set_registration_handler_f(
  dispatch_source_t source,
  dispatch_function_t handler,
);

/// !
/// @function dispatch_group_create
///
/// @abstract
/// Creates new group with which blocks may be associated.
///
/// @discussion
/// This function creates a new group with which blocks may be associated.
/// The dispatch group may be used to wait for the completion of the blocks it
/// references. The group object memory is freed with dispatch_release().
///
/// @result
/// The newly created group, or NULL on failure.
@ffi.Native<dispatch_group_t Function()>()
external dispatch_group_t dispatch_group_create();

/// !
/// @function dispatch_group_async_f
///
/// @abstract
/// Submits a function to a dispatch queue and associates the block with the
/// given dispatch group.
///
/// @discussion
/// See dispatch_group_async() for details.
///
/// @param group
/// A dispatch group to associate with the submitted function.
/// The result of passing NULL in this parameter is undefined.
///
/// @param queue
/// The dispatch queue to which the function will be submitted for asynchronous
/// invocation.
///
/// @param context
/// The application-defined context parameter to pass to the function.
///
/// @param work
/// The application-defined function to invoke on the target queue. The first
/// parameter passed to this function is the context provided to
/// dispatch_group_async_f().
@ffi.Native<
    ffi.Void Function(dispatch_group_t, dispatch_queue_t, ffi.Pointer<ffi.Void>,
        dispatch_function_t)>()
external void dispatch_group_async_f(
  dispatch_group_t group,
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t work,
);

/// !
/// @function dispatch_group_wait
///
/// @abstract
/// Wait synchronously until all the blocks associated with a group have
/// completed or until the specified timeout has elapsed.
///
/// @discussion
/// This function waits for the completion of the blocks associated with the
/// given dispatch group, and returns after all blocks have completed or when
/// the specified timeout has elapsed.
///
/// This function will return immediately if there are no blocks associated
/// with the dispatch group (i.e. the group is empty).
///
/// The result of calling this function from multiple threads simultaneously
/// with the same dispatch group is undefined.
///
/// After the successful return of this function, the dispatch group is empty.
/// It may either be released with dispatch_release() or re-used for additional
/// blocks. See dispatch_group_async() for more information.
///
/// @param group
/// The dispatch group to wait on.
/// The result of passing NULL in this parameter is undefined.
///
/// @param timeout
/// When to timeout (see dispatch_time). As a convenience, there are the
/// DISPATCH_TIME_NOW and DISPATCH_TIME_FOREVER constants.
///
/// @result
/// Returns zero on success (all blocks associated with the group completed
/// within the specified timeout) or non-zero on error (i.e. timed out).
@ffi.Native<ffi.IntPtr Function(dispatch_group_t, dispatch_time_t)>()
external int dispatch_group_wait(
  dispatch_group_t group,
  int timeout,
);

/// !
/// @function dispatch_group_notify_f
///
/// @abstract
/// Schedule a function to be submitted to a queue when all the blocks
/// associated with a group have completed.
///
/// @discussion
/// See dispatch_group_notify() for details.
///
/// @param group
/// The dispatch group to observe.
/// The result of passing NULL in this parameter is undefined.
///
/// @param context
/// The application-defined context parameter to pass to the function.
///
/// @param work
/// The application-defined function to invoke on the target queue. The first
/// parameter passed to this function is the context provided to
/// dispatch_group_notify_f().
@ffi.Native<
    ffi.Void Function(dispatch_group_t, dispatch_queue_t, ffi.Pointer<ffi.Void>,
        dispatch_function_t)>()
external void dispatch_group_notify_f(
  dispatch_group_t group,
  dispatch_queue_t queue,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t work,
);

/// !
/// @function dispatch_group_enter
///
/// @abstract
/// Manually indicate a block has entered the group
///
/// @discussion
/// Calling this function indicates another block has joined the group through
/// a means other than dispatch_group_async(). Calls to this function must be
/// balanced with dispatch_group_leave().
///
/// @param group
/// The dispatch group to update.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_group_t)>()
external void dispatch_group_enter(
  dispatch_group_t group,
);

/// !
/// @function dispatch_group_leave
///
/// @abstract
/// Manually indicate a block in the group has completed
///
/// @discussion
/// Calling this function indicates block has completed and left the dispatch
/// group by a means other than dispatch_group_async().
///
/// @param group
/// The dispatch group to update.
/// The result of passing NULL in this parameter is undefined.
@ffi.Native<ffi.Void Function(dispatch_group_t)>()
external void dispatch_group_leave(
  dispatch_group_t group,
);

/// !
/// @function dispatch_semaphore_create
///
/// @abstract
/// Creates new counting semaphore with an initial value.
///
/// @discussion
/// Passing zero for the value is useful for when two threads need to reconcile
/// the completion of a particular event. Passing a value greater than zero is
/// useful for managing a finite pool of resources, where the pool size is equal
/// to the value.
///
/// @param value
/// The starting value for the semaphore. Passing a value less than zero will
/// cause NULL to be returned.
///
/// @result
/// The newly created semaphore, or NULL on failure.
@ffi.Native<dispatch_semaphore_t Function(ffi.IntPtr)>()
external dispatch_semaphore_t dispatch_semaphore_create(
  int value,
);

/// !
/// @function dispatch_semaphore_wait
///
/// @abstract
/// Wait (decrement) for a semaphore.
///
/// @discussion
/// Decrement the counting semaphore. If the resulting value is less than zero,
/// this function waits for a signal to occur before returning. If the timeout is
/// reached without a signal being received, the semaphore is re-incremented
/// before the function returns.
///
/// @param dsema
/// The semaphore. The result of passing NULL in this parameter is undefined.
///
/// @param timeout
/// When to timeout (see dispatch_time). As a convenience, there are the
/// DISPATCH_TIME_NOW and DISPATCH_TIME_FOREVER constants.
///
/// @result
/// Returns zero on success, or non-zero if the timeout occurred.
@ffi.Native<ffi.IntPtr Function(dispatch_semaphore_t, dispatch_time_t)>()
external int dispatch_semaphore_wait(
  dispatch_semaphore_t dsema,
  int timeout,
);

/// !
/// @function dispatch_semaphore_signal
///
/// @abstract
/// Signal (increment) a semaphore.
///
/// @discussion
/// Increment the counting semaphore. If the previous value was less than zero,
/// this function wakes a waiting thread before returning.
///
/// @param dsema The counting semaphore.
/// The result of passing NULL in this parameter is undefined.
///
/// @result
/// This function returns non-zero if a thread is woken. Otherwise, zero is
/// returned.
@ffi.Native<ffi.IntPtr Function(dispatch_semaphore_t)>()
external int dispatch_semaphore_signal(
  dispatch_semaphore_t dsema,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<dispatch_once_t>, ffi.Pointer<ffi.Void>,
        dispatch_function_t)>()
external void dispatch_once_f(
  ffi.Pointer<dispatch_once_t> predicate,
  ffi.Pointer<ffi.Void> context,
  dispatch_function_t function,
);

/// !
/// @function dispatch_data_get_size
/// Returns the logical size of the memory region(s) represented by the specified
/// dispatch data object.
///
/// @param data	The dispatch data object to query.
/// @result	The number of bytes represented by the data object.
@ffi.Native<ffi.Size Function(dispatch_data_t)>()
external int dispatch_data_get_size(
  dispatch_data_t data,
);

/// !
/// @function dispatch_data_create_map
/// Maps the memory represented by the specified dispatch data object as a single
/// contiguous memory region and returns a new data object representing it.
/// If non-NULL references to a pointer and a size variable are provided, they
/// are filled with the location and extent of that region. These allow direct
/// read access to the represented memory, but are only valid until the returned
/// object is released. Under ARC, if that object is held in a variable with
/// automatic storage, care needs to be taken to ensure that it is not released
/// by the compiler before memory access via the pointer has been completed.
///
/// @param data		The dispatch data object to map.
/// @param buffer_ptr	A pointer to a pointer variable to be filled with the
/// location of the mapped contiguous memory region, or
/// NULL.
/// @param size_ptr	A pointer to a size_t variable to be filled with the
/// size of the mapped contiguous memory region, or NULL.
/// @result		A newly created dispatch data object.
@ffi.Native<
    dispatch_data_t Function(dispatch_data_t,
        ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Size>)>()
external dispatch_data_t dispatch_data_create_map(
  dispatch_data_t data,
  ffi.Pointer<ffi.Pointer<ffi.Void>> buffer_ptr,
  ffi.Pointer<ffi.Size> size_ptr,
);

/// !
/// @function dispatch_data_create_concat
/// Returns a new dispatch data object representing the concatenation of the
/// specified data objects. Those objects may be released by the application
/// after the call returns (however, the system might not deallocate the memory
/// region(s) described by them until the newly created object has also been
/// released).
///
/// @param data1	The data object representing the region(s) of memory to place
/// at the beginning of the newly created object.
/// @param data2	The data object representing the region(s) of memory to place
/// at the end of the newly created object.
/// @result	A newly created object representing the concatenation of the
/// data1 and data2 objects.
@ffi.Native<dispatch_data_t Function(dispatch_data_t, dispatch_data_t)>()
external dispatch_data_t dispatch_data_create_concat(
  dispatch_data_t data1,
  dispatch_data_t data2,
);

/// !
/// @function dispatch_data_create_subrange
/// Returns a new dispatch data object representing a subrange of the specified
/// data object, which may be released by the application after the call returns
/// (however, the system might not deallocate the memory region(s) described by
/// that object until the newly created object has also been released).
///
/// @param data		The data object representing the region(s) of memory to
/// create a subrange of.
/// @param offset	The offset into the data object where the subrange
/// starts.
/// @param length	The length of the range.
/// @result		A newly created object representing the specified
/// subrange of the data object.
@ffi.Native<dispatch_data_t Function(dispatch_data_t, ffi.Size, ffi.Size)>()
external dispatch_data_t dispatch_data_create_subrange(
  dispatch_data_t data,
  int offset,
  int length,
);

/// !
/// @function dispatch_data_copy_region
/// Finds the contiguous memory region containing the specified location among
/// the regions represented by the specified object and returns a copy of the
/// internal dispatch data object representing that region along with its logical
/// offset in the specified object.
///
/// @param data		The dispatch data object to query.
/// @param location	The logical position in the data object to query.
/// @param offset_ptr	A pointer to a size_t variable to be filled with the
/// logical offset of the returned region object to the
/// start of the queried data object.
/// @result		A newly created dispatch data object.
@ffi.Native<
    dispatch_data_t Function(
        dispatch_data_t, ffi.Size, ffi.Pointer<ffi.Size>)>()
external dispatch_data_t dispatch_data_copy_region(
  dispatch_data_t data,
  int location,
  ffi.Pointer<ffi.Size> offset_ptr,
);

/// !
/// @function dispatch_io_close
/// Close the specified I/O channel to new read or write operations; scheduling
/// operations on a closed channel results in their handler returning an error.
///
/// If the DISPATCH_IO_STOP flag is provided, the system will make a best effort
/// to interrupt any outstanding read and write operations on the I/O channel,
/// otherwise those operations will run to completion normally.
/// Partial results of read and write operations may be returned even after a
/// channel is closed with the DISPATCH_IO_STOP flag.
/// The final invocation of an I/O handler of an interrupted operation will be
/// passed an ECANCELED error code, as will the I/O handler of an operation
/// scheduled on a closed channel.
///
/// @param channel	The dispatch I/O channel to close.
/// @param flags		The flags for the close operation.
@ffi.Native<ffi.Void Function(dispatch_io_t, dispatch_io_close_flags_t)>()
external void dispatch_io_close(
  dispatch_io_t channel,
  int flags,
);

/// !
/// @function dispatch_io_get_descriptor
/// Returns the file descriptor underlying a dispatch I/O channel.
///
/// Will return -1 for a channel closed with dispatch_io_close() and for a
/// channel associated with a path name that has not yet been open(2)ed.
///
/// If called from a barrier block scheduled on a channel associated with a path
/// name that has not yet been open(2)ed, this will trigger the channel open(2)
/// operation and return the resulting file descriptor.
///
/// @param channel	The dispatch I/O channel to query.
/// @result		The file descriptor underlying the channel, or -1.
@ffi.Native<dispatch_fd_t Function(dispatch_io_t)>()
external int dispatch_io_get_descriptor(
  dispatch_io_t channel,
);

/// !
/// @function dispatch_io_set_high_water
/// Set a high water mark on the I/O channel for all operations.
///
/// The system will make a best effort to enqueue I/O handlers with partial
/// results as soon the number of bytes processed by an operation (i.e. read or
/// written) reaches the high water mark.
///
/// The size of data objects passed to I/O handlers for this channel will never
/// exceed the specified high water mark.
///
/// The default value for the high water mark is unlimited (i.e. SIZE_MAX).
///
/// @param channel	The dispatch I/O channel on which to set the policy.
/// @param high_water	The number of bytes to use as a high water mark.
@ffi.Native<ffi.Void Function(dispatch_io_t, ffi.Size)>()
external void dispatch_io_set_high_water(
  dispatch_io_t channel,
  int high_water,
);

/// !
/// @function dispatch_io_set_low_water
/// Set a low water mark on the I/O channel for all operations.
///
/// The system will process (i.e. read or write) at least the low water mark
/// number of bytes for an operation before enqueueing I/O handlers with partial
/// results.
///
/// The size of data objects passed to intermediate I/O handler invocations for
/// this channel (i.e. excluding the final invocation) will never be smaller than
/// the specified low water mark, except if the channel has an interval with the
/// DISPATCH_IO_STRICT_INTERVAL flag set or if EOF or an error was encountered.
///
/// I/O handlers should be prepared to receive amounts of data significantly
/// larger than the low water mark in general. If an I/O handler requires
/// intermediate results of fixed size, set both the low and and the high water
/// mark to that size.
///
/// The default value for the low water mark is unspecified, but must be assumed
/// to be such that intermediate handler invocations may occur.
/// If I/O handler invocations with partial results are not desired, set the
/// low water mark to SIZE_MAX.
///
/// @param channel	The dispatch I/O channel on which to set the policy.
/// @param low_water	The number of bytes to use as a low water mark.
@ffi.Native<ffi.Void Function(dispatch_io_t, ffi.Size)>()
external void dispatch_io_set_low_water(
  dispatch_io_t channel,
  int low_water,
);

/// !
/// @function dispatch_io_set_interval
/// Set a nanosecond interval at which I/O handlers are to be enqueued on the
/// I/O channel for all operations.
///
/// This allows an application to receive periodic feedback on the progress of
/// read and write operations, e.g. for the purposes of displaying progress bars.
///
/// If the amount of data ready to be delivered to an I/O handler at the interval
/// is inferior to the channel low water mark, the handler will only be enqueued
/// if the DISPATCH_IO_STRICT_INTERVAL flag is set.
///
/// Note that the system may defer enqueueing interval I/O handlers by a small
/// unspecified amount of leeway in order to align with other system activity for
/// improved system performance or power consumption.
///
/// @param channel	The dispatch I/O channel on which to set the policy.
/// @param interval	The interval in nanoseconds at which delivery of the I/O
/// handler is desired.
/// @param flags		Flags indicating desired data delivery behavior at
/// interval time.
@ffi.Native<
    ffi.Void Function(
        dispatch_io_t, ffi.Uint64, dispatch_io_interval_flags_t)>()
external void dispatch_io_set_interval(
  dispatch_io_t channel,
  int interval,
  int flags,
);

/// !
/// @function dispatch_workloop_create
///
/// @abstract
/// Creates a new dispatch workloop to which workitems may be submitted.
///
/// @param label
/// A string label to attach to the workloop.
///
/// @result
/// The newly created dispatch workloop.
@ffi.Native<dispatch_workloop_t Function(ffi.Pointer<ffi.Char>)>()
external dispatch_workloop_t dispatch_workloop_create(
  ffi.Pointer<ffi.Char> label,
);

/// !
/// @function dispatch_workloop_create_inactive
///
/// @abstract
/// Creates a new inactive dispatch workloop that can be setup and then
/// activated.
///
/// @discussion
/// Creating an inactive workloop allows for it to receive further configuration
/// before it is activated, and workitems can be submitted to it.
///
/// Submitting workitems to an inactive workloop is undefined and will cause the
/// process to be terminated.
///
/// @param label
/// A string label to attach to the workloop.
///
/// @result
/// The newly created dispatch workloop.
@ffi.Native<dispatch_workloop_t Function(ffi.Pointer<ffi.Char>)>()
external dispatch_workloop_t dispatch_workloop_create_inactive(
  ffi.Pointer<ffi.Char> label,
);

/// !
/// @function dispatch_workloop_set_autorelease_frequency
///
/// @abstract
/// Sets the autorelease frequency of the workloop.
///
/// @discussion
/// See dispatch_queue_attr_make_with_autorelease_frequency().
/// The default policy for a workloop is
/// DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM.
///
/// @param workloop
/// The dispatch workloop to modify.
///
/// This workloop must be inactive, passing an activated object is undefined
/// and will cause the process to be terminated.
///
/// @param frequency
/// The requested autorelease frequency.
@ffi.Native<ffi.Void Function(dispatch_workloop_t, ffi.Int32)>()
external void dispatch_workloop_set_autorelease_frequency(
  dispatch_workloop_t workloop,
  int frequency,
);

/// !
/// @function dispatch_workloop_set_os_workgroup
///
/// @abstract
/// Associates an os_workgroup_t with the specified dispatch workloop.
///
/// The worker thread will be a member of the specified os_workgroup_t while executing
/// work items submitted to the workloop.
///
/// Using both dispatch_workloop_set_scheduler_priority() and
/// dispatch_workloop_set_os_workgroup() will prefer scheduling policies
/// from the workgroup, if they exist.
///
/// @param workloop
/// The dispatch workloop to modify.
///
/// This workloop must be inactive, passing an activated object is undefined
/// and will cause the process to be terminated.
///
/// @param workgroup
/// The workgroup to associate with this workloop.
///
/// The workgroup specified is retained and the previously associated workgroup
/// (if any) is released.
@ffi.Native<
    ffi.Void Function(dispatch_workloop_t, ffi.Pointer<os_workgroup_s>)>()
external void dispatch_workloop_set_os_workgroup(
  dispatch_workloop_t workloop,
  ffi.Pointer<os_workgroup_s> workgroup,
);

/// !
/// @brief
/// Get value of service property.
///
/// @param property
/// The requested property.
/// Currently the only property defined is kDNSServiceProperty_DaemonVersion.
///
/// @param result
/// Place to store result.
/// For retrieving DaemonVersion, this should be the address of a uint32_t.
///
/// @param size
/// Pointer to uint32_t containing size of the result location.
/// For retrieving DaemonVersion, this should be sizeof(uint32_t).
/// On return the uint32_t is updated to the size of the data returned.
/// For DaemonVersion, the returned size is always sizeof(uint32_t), but
/// future properties could be defined which return variable-sized results.
///
/// @result
/// Returns kDNSServiceErr_NoError on success, or kDNSServiceErr_ServiceNotRunning
/// if the daemon (or "system service" on Windows) is not running.
@ffi.Native<
    DNSServiceErrorType Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Uint32>)>()
external int DNSServiceGetProperty(
  ffi.Pointer<ffi.Char> property,
  ffi.Pointer<ffi.Void> result,
  ffi.Pointer<ffi.Uint32> size,
);

/// !
/// @brief
/// Access underlying Unix domain socket for an initialized DNSServiceRef.
///
/// @param sdRef
/// A DNSServiceRef initialized by any of the DNSService calls.
///
/// @result
/// The DNSServiceRef's underlying socket descriptor, or -1 on error.
///
/// @discussion
/// The DNS Service Discovery implementation uses this socket to communicate between the client and
/// the daemon. The application MUST NOT directly read from or write to this socket.
/// Access to the socket is provided so that it can be used as a kqueue event source, a CFRunLoop
/// event source, in a select() loop, etc. When the underlying event management subsystem (kqueue/
/// select/CFRunLoop etc.) indicates to the client that data is available for reading on the
/// socket, the client should call DNSServiceProcessResult(), which will extract the daemon's
/// reply from the socket, and pass it to the appropriate application callback. By using a run
/// loop or select(), results from the daemon can be processed asynchronously. Alternatively,
/// a client can choose to fork a thread and have it loop calling "DNSServiceProcessResult(ref);"
/// If DNSServiceProcessResult() is called when no data is available for reading on the socket, it
/// will block until data does become available, and then process the data and return to the caller.
/// The application is responsible for checking the return value of DNSServiceProcessResult()
/// to determine if the socket is valid and if it should continue to process data on the socket.
/// When data arrives on the socket, the client is responsible for calling DNSServiceProcessResult(ref)
/// in a timely fashion -- if the client allows a large backlog of data to build up the daemon
/// may terminate the connection.
@ffi.Native<ffi.Int Function(DNSServiceRef)>()
external int DNSServiceRefSockFD(
  DNSServiceRef sdRef,
);

/// !
/// @brief
/// Read a reply from the daemon, calling the appropriate application callback.
///
/// @param sdRef
/// A DNSServiceRef initialized by any of the DNSService calls
/// that take a callback parameter.
///
/// @result
/// Returns kDNSServiceErr_NoError on success, otherwise returns
/// an error code indicating the specific failure that occurred.
///
/// @discussion
/// This call will block until the daemon's response is received. Use DNSServiceRefSockFD() in
/// conjunction with a run loop or select() to determine the presence of a response from the
/// server before calling this function to process the reply without blocking. Call this function
/// at any point if it is acceptable to block until the daemon's response arrives. Note that the
/// client is responsible for ensuring that DNSServiceProcessResult() is called whenever there is
/// a reply from the daemon - the daemon may terminate its connection with a client that does not
/// process the daemon's responses.
@ffi.Native<DNSServiceErrorType Function(DNSServiceRef)>()
external int DNSServiceProcessResult(
  DNSServiceRef sdRef,
);

/// !
/// @brief
/// Terminate a connection with the daemon and free memory associated with the DNSServiceRef.
///
/// @param sdRef
/// A DNSServiceRef initialized by any of the DNSService calls.
///
/// @discussion
/// Any services or records registered with this DNSServiceRef will be deregistered. Any
/// Browse, Resolve, or Query operations called with this reference will be terminated.
///
/// Note: If the reference's underlying socket is used in a run loop or select() call, it should
/// be removed BEFORE DNSServiceRefDeallocate() is called, as this function closes the reference's
/// socket.
///
/// Note: If the reference was initialized with DNSServiceCreateConnection(), any DNSRecordRefs
/// created via this reference will be invalidated by this call - the resource records are
/// deregistered, and their DNSRecordRefs may not be used in subsequent functions. Similarly,
/// if the reference was initialized with DNSServiceRegister, and an extra resource record was
/// added to the service via DNSServiceAddRecord(), the DNSRecordRef created by the Add() call
/// is invalidated when this function is called - the DNSRecordRef may not be used in subsequent
/// functions.
///
/// If the reference was passed to DNSServiceSetDispatchQueue(), DNSServiceRefDeallocate() must
/// be called on the same queue originally passed as an argument to DNSServiceSetDispatchQueue().
///
/// Note: This call is to be used only with the DNSServiceRef defined by this API.
@ffi.Native<ffi.Void Function(DNSServiceRef)>()
external void DNSServiceRefDeallocate(
  DNSServiceRef sdRef,
);

/// !
/// @brief
/// Asynchronously enumerate domains available for browsing and registration.
///
/// @param sdRef
/// A pointer to an uninitialized DNSServiceRef
/// (or, if the kDNSServiceFlagsShareConnection flag is used,
/// a copy of the shared connection reference that is to be used).
/// If the call succeeds then it initializes (or updates) the DNSServiceRef,
/// returns kDNSServiceErr_NoError, and the enumeration operation
/// will remain active indefinitely until the client terminates it
/// by passing this DNSServiceRef to DNSServiceRefDeallocate()
/// (or by closing the underlying shared connection, if used).
///
/// @param flags
/// Possible values are:
/// kDNSServiceFlagsShareConnection to use a shared connection.
/// kDNSServiceFlagsBrowseDomains to enumerate domains recommended for browsing.
/// kDNSServiceFlagsRegistrationDomains to enumerate domains recommended
/// for registration.
///
/// @param interfaceIndex
/// If non-zero, specifies the interface on which to look for domains.
/// (the index for a given interface is determined via the if_nametoindex()
/// family of calls.) Most applications will pass 0 to enumerate domains on
/// all interfaces. See "Constants for specifying an interface index" for more details.
///
/// @param callBack
/// The function to be called when a domain is found or the call asynchronously
/// fails.
///
/// @param context
/// An application context pointer which is passed to the callback function
/// (may be NULL).
///
/// @result
/// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
/// errors are delivered to the callback), otherwise returns an error code indicating
/// the error that occurred (the callback is not invoked and the DNSServiceRef
/// is not initialized).
/// @discussion
/// The enumeration MUST be cancelled via DNSServiceRefDeallocate() when no more domains
/// are to be found.
///
/// Note that the names returned are (like all of DNS-SD) UTF-8 strings,
/// and are escaped using standard DNS escaping rules.
/// (See "Notes on DNS Name Escaping" earlier in this file for more details.)
/// A graphical browser displaying a hierarchical tree-structured view should cut
/// the names at the bare dots to yield individual labels, then de-escape each
/// label according to the escaping rules, and then display the resulting UTF-8 text.
@ffi.Native<
    DNSServiceErrorType Function(ffi.Pointer<DNSServiceRef>, DNSServiceFlags,
        ffi.Uint32, DNSServiceDomainEnumReply, ffi.Pointer<ffi.Void>)>()
external int DNSServiceEnumerateDomains(
  ffi.Pointer<DNSServiceRef> sdRef,
  int flags,
  int interfaceIndex,
  DNSServiceDomainEnumReply callBack,
  ffi.Pointer<ffi.Void> context,
);

/// !
/// @brief
/// Register a service that is discovered via Browse() and Resolve() calls.
///
/// @param sdRef
/// A pointer to an uninitialized DNSServiceRef
/// (or, if the kDNSServiceFlagsShareConnection flag is used,
/// a copy of the shared connection reference that is to be used).
/// If the call succeeds then it initializes (or updates) the DNSServiceRef,
/// returns kDNSServiceErr_NoError, and the service registration
/// will remain active indefinitely until the client terminates it
/// by passing this DNSServiceRef to DNSServiceRefDeallocate()
/// (or by closing the underlying shared connection, if used).
///
/// @param flags
/// Possible values are:
/// kDNSServiceFlagsShareConnection to use a shared connection.
/// Other flags indicate the renaming behavior on name conflict
/// (not required for most applications).
/// See flag definitions above for details.
///
/// @param interfaceIndex
/// If non-zero, specifies the interface on which to register the service
/// (the index for a given interface is determined via the if_nametoindex()
/// family of calls.) Most applications will pass 0 to register on all
/// available interfaces. See "Constants for specifying an interface index" for more details.
///
/// @param name
/// If non-NULL, specifies the service name to be registered.
/// Most applications will not specify a name, in which case the computer
/// name is used (this name is communicated to the client via the callback).
/// If a name is specified, it must be 1-63 bytes of UTF-8 text.
/// If the name is longer than 63 bytes it will be automatically truncated
/// to a legal length, unless the NoAutoRename flag is set,
/// in which case kDNSServiceErr_BadParam will be returned.
///
/// @param regtype
/// The service type followed by the protocol, separated by a dot
/// (e.g. "_ftp._tcp"). The service type must be an underscore, followed
/// by 1-15 characters, which may be letters, digits, or hyphens.
/// The transport protocol must be "_tcp" or "_udp". New service types
/// should be registered at <http://www.dns-sd.org/ServiceTypes.html>.
///
/// Additional subtypes of the primary service type (where a service
/// type has defined subtypes) follow the primary service type in a
/// comma-separated list, with no additional spaces, e.g.
/// "_primarytype._tcp,_subtype1,_subtype2,_subtype3"
/// Subtypes provide a mechanism for filtered browsing: A client browsing
/// for "_primarytype._tcp" will discover all instances of this type;
/// a client browsing for "_primarytype._tcp,_subtype2" will discover only
/// those instances that were registered with "_subtype2" in their list of
/// registered subtypes.
///
/// The subtype mechanism can be illustrated with some examples using the
/// dns-sd command-line tool:
///
/// % dns-sd -R Simple _test._tcp "" 1001 &
/// % dns-sd -R Better _test._tcp,HasFeatureA "" 1002 &
/// % dns-sd -R Best   _test._tcp,HasFeatureA,HasFeatureB "" 1003 &
///
/// Now:
/// % dns-sd -B _test._tcp             # will find all three services
/// % dns-sd -B _test._tcp,HasFeatureA # finds "Better" and "Best"
/// % dns-sd -B _test._tcp,HasFeatureB # finds only "Best"
///
/// Subtype labels may be up to 63 bytes long, and may contain any eight-
/// bit byte values, including zero bytes. However, due to the nature of
/// using a C-string-based API, conventional DNS escaping must be used for
/// dots ('.'), commas (','), backslashes ('\') and zero bytes, as shown below:
///
/// % dns-sd -R Test '_test._tcp,s\.one,s\,two,s\\three,s\000four' local 123
///
/// @param domain
/// If non-NULL, specifies the domain on which to advertise the service.
/// Most applications will not specify a domain, instead automatically
/// registering in the default domain(s).
///
/// @param host
/// If non-NULL, specifies the SRV target host name. Most applications
/// will not specify a host, instead automatically using the machine's
/// default host name(s). Note that specifying a non-NULL host does NOT
/// create an address record for that host - the application is responsible
/// for ensuring that the appropriate address record exists, or creating it
/// via DNSServiceRegisterRecord().
///
/// @param port
/// The port, in network byte order, on which the service accepts connections.
/// Pass 0 for a "placeholder" service (i.e. a service that will not be discovered
/// by browsing, but will cause a name conflict if another client tries to
/// register that same name). Most clients will not use placeholder services.
///
/// @param txtLen
/// The length of the txtRecord, in bytes. Must be zero if the txtRecord is NULL.
///
/// @param txtRecord
/// The TXT record rdata. A non-NULL txtRecord MUST be a properly formatted DNS
/// TXT record, i.e. <length byte> <data> <length byte> <data> ...
/// Passing NULL for the txtRecord is allowed as a synonym for txtLen=1, txtRecord="",
/// i.e. it creates a TXT record of length one containing a single empty string.
/// RFC 1035 doesn't allow a TXT record to contain *zero* strings, so a single empty
/// string is the smallest legal DNS TXT record.
/// As with the other parameters, the DNSServiceRegister call copies the txtRecord
/// data; e.g. if you allocated the storage for the txtRecord parameter with malloc()
/// then you can safely free that memory right after the DNSServiceRegister call returns.
///
/// @param callBack
/// The function to be called when the registration completes or asynchronously
/// fails. The client MAY pass NULL for the callback -  The client will NOT be notified
/// of the default values picked on its behalf, and the client will NOT be notified of any
/// asynchronous errors (e.g. out of memory errors, etc.) that may prevent the registration
/// of the service. The client may NOT pass the NoAutoRename flag if the callback is NULL.
/// The client may still deregister the service at any time via DNSServiceRefDeallocate().
///
/// @param context
/// An application context pointer which is passed to the callback function
/// (may be NULL).
///
/// @result
/// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
/// errors are delivered to the callback), otherwise returns an error code indicating
/// the error that occurred (the callback is never invoked and the DNSServiceRef
/// is not initialized).
@ffi.Native<
    DNSServiceErrorType Function(
        ffi.Pointer<DNSServiceRef>,
        DNSServiceFlags,
        ffi.Uint32,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Pointer<ffi.Void>,
        DNSServiceRegisterReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceRegister(
  ffi.Pointer<DNSServiceRef> sdRef,
  int flags,
  int interfaceIndex,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Char> regtype,
  ffi.Pointer<ffi.Char> domain,
  ffi.Pointer<ffi.Char> host,
  int port,
  int txtLen,
  ffi.Pointer<ffi.Void> txtRecord,
  DNSServiceRegisterReply callBack,
  ffi.Pointer<ffi.Void> context,
);

/// !
/// @brief
/// Add a record to a registered service.
///
/// @param sdRef
/// A DNSServiceRef initialized by DNSServiceRegister().
///
/// @param RecordRef
/// A pointer to an uninitialized DNSRecordRef. Upon succesfull completion of this
/// call, this ref may be passed to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().
/// If the above DNSServiceRef is passed to DNSServiceRefDeallocate(), RecordRef is also
/// invalidated and may not be used further.
///
/// @param flags
/// Currently ignored, reserved for future use.
///
/// @param rrtype
/// The type of the record (e.g. kDNSServiceType_TXT, kDNSServiceType_SRV, etc)
///
/// @param rdlen
/// The length, in bytes, of the rdata.
///
/// @param rdata
/// The raw rdata to be contained in the added resource record.
///
/// @param ttl
/// The time to live of the resource record, in seconds.
/// Most clients should pass 0 to indicate that the system should
/// select a sensible default value.
///
/// @result
/// Returns kDNSServiceErr_NoError on success, otherwise returns an
/// error code indicating the error that occurred (the RecordRef is not initialized).
///
/// @discussion
/// The name of the record will be the same as the
/// registered service's name.
/// The record can later be updated or deregistered by passing the RecordRef initialized
/// by this function to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().
///
/// Note that the DNSServiceAddRecord/UpdateRecord/RemoveRecord are *NOT* thread-safe
/// with respect to a single DNSServiceRef. If you plan to have multiple threads
/// in your program simultaneously add, update, or remove records from the same
/// DNSServiceRef, then it's the caller's responsibility to use a mutex lock
/// or take similar appropriate precautions to serialize those calls.
@ffi.Native<
    DNSServiceErrorType Function(
        DNSServiceRef,
        ffi.Pointer<DNSRecordRef>,
        DNSServiceFlags,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Pointer<ffi.Void>,
        ffi.Uint32)>()
external int DNSServiceAddRecord(
  DNSServiceRef sdRef,
  ffi.Pointer<DNSRecordRef> RecordRef,
  int flags,
  int rrtype,
  int rdlen,
  ffi.Pointer<ffi.Void> rdata,
  int ttl,
);

/// !
/// @brief
/// Update a registered resource record. This function can update three types of records:
/// 1. The primary txt record for a service that was previously registered.
/// 2. Some other record that was added to the service using DNSServiceAddRecord().
/// 3. A record registered using DNSServiceRegisterRecord().
///
/// @param sdRef
/// For updates of records associated with a registered service (cases 1 and 2), this is the
/// DNSServiceRef returned by DNSServiceRegister(). For updates of records registered with
/// DNSServiceRegisterRecord() (case 3), this is the DNSServiceRef that was passed to
/// DNSServiceRegisterRecord().
///
/// @param recordRef
/// For case 1, this is NULL. For case 2, it's a DNSRecordRef returned by DNSServiceAddRecord(). For
/// case 3, it's a DNSRecordRef returned by DNSServiceRegisterRecord().
///
/// @param flags
/// Currently ignored, reserved for future use.
///
/// @param rdlen
/// The length, in bytes, of the new rdata.
///
/// @param rdata
/// The new rdata to be contained in the updated resource record.
///
/// @param ttl
/// The time to live of the updated resource record, in seconds.
/// Most clients should pass 0 to indicate that the system should
/// select a sensible default value.
///
/// @result
/// Returns kDNSServiceErr_NoError on success, otherwise returns an
/// error code indicating the error that occurred.
@ffi.Native<
    DNSServiceErrorType Function(DNSServiceRef, DNSRecordRef, DNSServiceFlags,
        ffi.Uint16, ffi.Pointer<ffi.Void>, ffi.Uint32)>()
external int DNSServiceUpdateRecord(
  DNSServiceRef sdRef,
  DNSRecordRef recordRef,
  int flags,
  int rdlen,
  ffi.Pointer<ffi.Void> rdata,
  int ttl,
);

@ffi.Native<
    DNSServiceErrorType Function(
        DNSServiceRef,
        DNSRecordRef,
        DNSServiceFlags,
        ffi.Uint16,
        ffi.Pointer<ffi.Void>,
        ffi.Uint32,
        DNSServiceAttributeRef)>()
external int DNSServiceUpdateRecordWithAttribute(
  DNSServiceRef sdRef,
  DNSRecordRef recordRef,
  int flags,
  int rdlen,
  ffi.Pointer<ffi.Void> rdata,
  int ttl,
  DNSServiceAttributeRef attr,
);

/// !
/// @brief
/// Remove a record previously added to a service record set via DNSServiceAddRecord(), or deregister
/// a record registered individually via DNSServiceRegisterRecord().
///
/// @param sdRef
/// A DNSServiceRef initialized by DNSServiceRegister() (if the
/// record being removed was registered via DNSServiceAddRecord()) or by
/// DNSServiceCreateConnection() (if the record being removed was registered via
/// DNSServiceRegisterRecord()).
///
/// @param RecordRef
/// A DNSRecordRef initialized by a successful call to DNSServiceAddRecord()
/// or DNSServiceRegisterRecord().
///
/// @param flags
/// Currently ignored, reserved for future use.
///
/// @result
/// Returns kDNSServiceErr_NoError on success, otherwise returns an
/// error code indicating the error that occurred.
@ffi.Native<
    DNSServiceErrorType Function(
        DNSServiceRef, DNSRecordRef, DNSServiceFlags)>()
external int DNSServiceRemoveRecord(
  DNSServiceRef sdRef,
  DNSRecordRef RecordRef,
  int flags,
);

/// !
/// @brief
/// Browse for instances of a service.
///
/// @param sdRef
/// A pointer to an uninitialized DNSServiceRef
/// (or, if the kDNSServiceFlagsShareConnection flag is used,
/// a copy of the shared connection reference that is to be used).
/// If the call succeeds then it initializes (or updates) the DNSServiceRef,
/// returns kDNSServiceErr_NoError, and the browse operation
/// will remain active indefinitely until the client terminates it
/// by passing this DNSServiceRef to DNSServiceRefDeallocate()
/// (or by closing the underlying shared connection, if used).
///
/// @param flags
/// Possible values are:
/// kDNSServiceFlagsShareConnection to use a shared connection.
///
/// @param interfaceIndex
/// If non-zero, specifies the interface on which to browse for services
/// (the index for a given interface is determined via the if_nametoindex()
/// family of calls.) Most applications will pass 0 to browse on all available
/// interfaces. See "Constants for specifying an interface index" for more details.
///
/// @param regtype
/// The service type being browsed for followed by the protocol, separated by a
/// dot (e.g. "_ftp._tcp"). The transport protocol must be "_tcp" or "_udp".
/// A client may optionally specify a single subtype to perform filtered browsing:
/// e.g. browsing for "_primarytype._tcp,_subtype" will discover only those
/// instances of "_primarytype._tcp" that were registered specifying "_subtype"
/// in their list of registered subtypes.
///
/// @param domain
/// If non-NULL, specifies the domain on which to browse for services.
/// Most applications will not specify a domain, instead browsing on the
/// default domain(s).
///
/// @param callBack
/// The function to be called when an instance of the service being browsed for
/// is found, or if the call asynchronously fails.
///
/// @param context
/// An application context pointer which is passed to the callback function
/// (may be NULL).
///
/// @result
/// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
/// errors are delivered to the callback), otherwise returns an error code indicating
/// the error that occurred (the callback is not invoked and the DNSServiceRef
/// is not initialized).
@ffi.Native<
    DNSServiceErrorType Function(
        ffi.Pointer<DNSServiceRef>,
        DNSServiceFlags,
        ffi.Uint32,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        DNSServiceBrowseReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceBrowse(
  ffi.Pointer<DNSServiceRef> sdRef,
  int flags,
  int interfaceIndex,
  ffi.Pointer<ffi.Char> regtype,
  ffi.Pointer<ffi.Char> domain,
  DNSServiceBrowseReply callBack,
  ffi.Pointer<ffi.Void> context,
);

/// !
/// @brief
/// Resolve a service name discovered via DNSServiceBrowse() to a target host name, port number, and
/// txt record.
///
/// @param sdRef
/// A pointer to an uninitialized DNSServiceRef
/// (or, if the kDNSServiceFlagsShareConnection flag is used,
/// a copy of the shared connection reference that is to be used).
/// If the call succeeds then it initializes (or updates) the DNSServiceRef,
/// returns kDNSServiceErr_NoError, and the resolve operation
/// will remain active indefinitely until the client terminates it
/// by passing this DNSServiceRef to DNSServiceRefDeallocate()
/// (or by closing the underlying shared connection, if used).
///
/// @param flags
/// Possible values are:
/// kDNSServiceFlagsShareConnection to use a shared connection.
/// Specifying kDNSServiceFlagsForceMulticast will cause query to be
/// performed with a link-local mDNS query, even if the name is an
/// apparently non-local name (i.e. a name not ending in ".local.")
///
/// @param interfaceIndex
/// The interface on which to resolve the service. If this resolve call is
/// as a result of a currently active DNSServiceBrowse() operation, then the
/// interfaceIndex should be the index reported in the DNSServiceBrowseReply
/// callback. If this resolve call is using information previously saved
/// (e.g. in a preference file) for later use, then use interfaceIndex 0, because
/// the desired service may now be reachable via a different physical interface.
/// See "Constants for specifying an interface index" for more details.
///
/// @param name
/// The name of the service instance to be resolved, as reported to the
/// DNSServiceBrowseReply() callback.
///
/// @param regtype
/// The type of the service instance to be resolved, as reported to the
/// DNSServiceBrowseReply() callback.
///
/// @param domain
/// The domain of the service instance to be resolved, as reported to the
/// DNSServiceBrowseReply() callback.
///
/// @param callBack
/// The function to be called when a result is found, or if the call
/// asynchronously fails.
///
/// @param context
/// An application context pointer which is passed to the callback function
/// (may be NULL).
///
/// @result
/// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
/// errors are delivered to the callback), otherwise returns an error code indicating
/// the error that occurred (the callback is never invoked and the DNSServiceRef
/// is not initialized).
/// @discussion
/// Note: Applications should NOT use DNSServiceResolve() solely for txt record monitoring - use
/// DNSServiceQueryRecord() instead, as it is more efficient for this task.
///
/// Note: When the desired results have been returned, the client MUST terminate the resolve by calling
/// DNSServiceRefDeallocate().
///
/// Note: DNSServiceResolve() behaves correctly for typical services that have a single SRV record
/// and a single TXT record. To resolve non-standard services with multiple SRV or TXT records,
/// DNSServiceQueryRecord() should be used.
///
/// NOTE: In earlier versions of this header file, the txtRecord parameter was declared "const char *"
/// This is incorrect, since it contains length bytes which are values in the range 0 to 255, not -128 to +127.
/// Depending on your compiler settings, this change may cause signed/unsigned mismatch warnings.
/// These should be fixed by updating your own callback function definition to match the corrected
/// function signature using "const unsigned char *txtRecord". Making this change may also fix inadvertent
/// bugs in your callback function, where it could have incorrectly interpreted a length byte with value 250
/// as being -6 instead, with various bad consequences ranging from incorrect operation to software crashes.
/// If you need to maintain portable code that will compile cleanly with both the old and new versions of
/// this header file, you should update your callback function definition to use the correct unsigned value,
/// and then in the place where you pass your callback function to DNSServiceResolve(), use a cast to eliminate
/// the compiler warning, e.g.:
/// DNSServiceResolve(sd, flags, index, name, regtype, domain, (DNSServiceResolveReply)MyCallback, context);
/// This will ensure that your code compiles cleanly without warnings (and more importantly, works correctly)
/// with both the old header and with the new corrected version.
@ffi.Native<
    DNSServiceErrorType Function(
        ffi.Pointer<DNSServiceRef>,
        DNSServiceFlags,
        ffi.Uint32,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        DNSServiceResolveReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceResolve(
  ffi.Pointer<DNSServiceRef> sdRef,
  int flags,
  int interfaceIndex,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Char> regtype,
  ffi.Pointer<ffi.Char> domain,
  DNSServiceResolveReply callBack,
  ffi.Pointer<ffi.Void> context,
);

/// !
/// @brief
/// Query for an arbitrary DNS record.
///
/// @param sdRef
/// A pointer to an uninitialized DNSServiceRef
/// (or, if the kDNSServiceFlagsShareConnection flag is used,
/// a copy of the shared connection reference that is to be used).
/// If the call succeeds then it initializes (or updates) the DNSServiceRef,
/// returns kDNSServiceErr_NoError, and the query operation
/// will remain active indefinitely until the client terminates it
/// by passing this DNSServiceRef to DNSServiceRefDeallocate()
/// (or by closing the underlying shared connection, if used).
///
/// @param flags
/// Possible values are:
/// kDNSServiceFlagsShareConnection to use a shared connection.
/// kDNSServiceFlagsForceMulticast or kDNSServiceFlagsLongLivedQuery.
/// Pass kDNSServiceFlagsLongLivedQuery to create a "long-lived" unicast
/// query to a unicast DNS server that implements the protocol. This flag
/// has no effect on link-local multicast queries.
///
/// @param interfaceIndex
/// If non-zero, specifies the interface on which to issue the query
/// (the index for a given interface is determined via the if_nametoindex()
/// family of calls.) Passing 0 causes the name to be queried for on all
/// interfaces. See "Constants for specifying an interface index" for more details.
///
/// @param fullname
/// The full domain name of the resource record to be queried for.
///
/// @param rrtype
/// The numerical type of the resource record to be queried for
/// (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
///
/// @param rrclass
/// The class of the resource record (usually kDNSServiceClass_IN).
///
/// @param callBack
/// The function to be called when a result is found, or if the call
/// asynchronously fails.
///
/// @param context
/// An application context pointer which is passed to the callback function
/// (may be NULL).
///
/// @result:
/// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
/// errors are delivered to the callback), otherwise returns an error code indicating
/// the error that occurred (the callback is never invoked and the DNSServiceRef
/// is not initialized).
@ffi.Native<
    DNSServiceErrorType Function(
        ffi.Pointer<DNSServiceRef>,
        DNSServiceFlags,
        ffi.Uint32,
        ffi.Pointer<ffi.Char>,
        ffi.Uint16,
        ffi.Uint16,
        DNSServiceQueryRecordReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceQueryRecord(
  ffi.Pointer<DNSServiceRef> sdRef,
  int flags,
  int interfaceIndex,
  ffi.Pointer<ffi.Char> fullname,
  int rrtype,
  int rrclass,
  DNSServiceQueryRecordReply callBack,
  ffi.Pointer<ffi.Void> context,
);

/// !
/// @brief
/// Queries for the IP address of a hostname by using either Multicast or Unicast DNS.
///
/// @param sdRef
/// A pointer to an uninitialized DNSServiceRef
/// (or, if the kDNSServiceFlagsShareConnection flag is used,
/// a copy of the shared connection reference that is to be used).
/// If the call succeeds then it initializes (or updates) the DNSServiceRef,
/// returns kDNSServiceErr_NoError, and the address query operation
/// will remain active indefinitely until the client terminates it
/// by passing this DNSServiceRef to DNSServiceRefDeallocate()
/// (or by closing the underlying shared connection, if used).
///
/// @param flags
/// Possible values are:
/// kDNSServiceFlagsShareConnection to use a shared connection.
/// kDNSServiceFlagsForceMulticast
///
/// @param interfaceIndex
/// The interface on which to issue the query.  Passing 0 causes the query to be
/// sent on all active interfaces via Multicast or the primary interface via Unicast.
///
/// @param protocol
/// Pass in kDNSServiceProtocol_IPv4 to look up IPv4 addresses, or kDNSServiceProtocol_IPv6
/// to look up IPv6 addresses, or both to look up both kinds. If neither flag is
/// set, the system will apply an intelligent heuristic, which is (currently)
/// that it will attempt to look up both, except:
///
/// * If "hostname" is a wide-area unicast DNS hostname (i.e. not a ".local." name)
/// but this host has no routable IPv6 address, then the call will not try to
/// look up IPv6 addresses for "hostname", since any addresses it found would be
/// unlikely to be of any use anyway. Similarly, if this host has no routable
/// IPv4 address, the call will not try to look up IPv4 addresses for "hostname".
///
/// @param hostname
/// The fully qualified domain name of the host to be queried for.
///
/// @param callBack
/// The function to be called when the query succeeds or fails asynchronously.
///
/// @param context
/// An application context pointer which is passed to the callback function
/// (may be NULL).
///
/// @result
/// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
/// errors are delivered to the callback), otherwise returns an error code indicating
/// the error that occurred.
@ffi.Native<
    DNSServiceErrorType Function(
        ffi.Pointer<DNSServiceRef>,
        DNSServiceFlags,
        ffi.Uint32,
        DNSServiceProtocol,
        ffi.Pointer<ffi.Char>,
        DNSServiceGetAddrInfoReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceGetAddrInfo(
  ffi.Pointer<DNSServiceRef> sdRef,
  int flags,
  int interfaceIndex,
  int protocol,
  ffi.Pointer<ffi.Char> hostname,
  DNSServiceGetAddrInfoReply callBack,
  ffi.Pointer<ffi.Void> context,
);

/// !
/// @brief
/// Create a connection to the daemon allowing efficient registration of
/// multiple individual records.
///
/// @param sdRef
/// A pointer to an uninitialized DNSServiceRef.
/// Deallocating the reference (via DNSServiceRefDeallocate())
/// severs the connection and cancels all operations and
/// deregisters all records registered on this connection.
///
/// @result
/// Returns kDNSServiceErr_NoError on success, otherwise returns
/// an error code indicating the specific failure that occurred
/// (in which case the DNSServiceRef is not initialized).
@ffi.Native<DNSServiceErrorType Function(ffi.Pointer<DNSServiceRef>)>()
external int DNSServiceCreateConnection(
  ffi.Pointer<DNSServiceRef> sdRef,
);

/// !
/// @brief
/// Register an individual resource record on a connected DNSServiceRef.
///
/// @param sdRef
/// A DNSServiceRef initialized by DNSServiceCreateConnection().
///
/// @param RecordRef
/// A pointer to an uninitialized DNSRecordRef. Upon succesfull completion of this
/// call, this ref may be passed to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().
/// (To deregister ALL records registered on a single connected DNSServiceRef
/// and deallocate each of their corresponding DNSServiceRecordRefs, call
/// DNSServiceRefDeallocate()).
///
/// @param flags
/// Required values are:
/// One of kDNSServiceFlagsShared, kDNSServiceFlagsUnique or kDNSServiceFlagsKnownUnique flags.
///
/// Possible values are:
/// kDNSServiceFlagsForceMulticast: If it is specified, the registration will be performed just like
/// a link-local mDNS registration even if the name is an apparently non-local name (i.e. a name not
/// ending in ".local.")
///
/// @param interfaceIndex
/// If non-zero, specifies the interface on which to register the record
/// (the index for a given interface is determined via the if_nametoindex()
/// family of calls.) Passing 0 causes the record to be registered on all interfaces.
/// See "Constants for specifying an interface index" for more details.
///
/// @param fullname
/// The full domain name of the resource record.
///
/// @param rrtype
/// The numerical type of the resource record (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
///
/// @param rrclass
/// The class of the resource record (usually kDNSServiceClass_IN)
///
/// @param rdlen
/// Length, in bytes, of the rdata.
///
/// @param rdata
/// A pointer to the raw rdata, as it is to appear in the DNS record.
///
/// @param ttl
/// The time to live of the resource record, in seconds.
/// Most clients should pass 0 to indicate that the system should
/// select a sensible default value.
///
/// @param callBack
/// The function to be called when a result is found, or if the call
/// asynchronously fails (e.g. because of a name conflict.)
///
/// @param context
/// An application context pointer which is passed to the callback function
/// (may be NULL).
///
/// @result
/// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
/// errors are delivered to the callback), otherwise returns an error code indicating
/// the error that occurred (the callback is never invoked and the DNSRecordRef is
/// not initialized).
///
/// @discussion
/// Note that name conflicts occurring for records registered via this call must be handled
/// by the client in the callback. The RecordRef object returned by the DNSServiceRegisterRecord
/// call in this case is not disposed of as a result of the error. The caller is responsible
/// for disposing of it either calling DNSServiceRemoveRecord on the value returned in RecordRef,
/// or by calling DNSServiceRefDeallocate on the DNSServiceRef value passed in sdRef.
@ffi.Native<
    DNSServiceErrorType Function(
        DNSServiceRef,
        ffi.Pointer<DNSRecordRef>,
        DNSServiceFlags,
        ffi.Uint32,
        ffi.Pointer<ffi.Char>,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Pointer<ffi.Void>,
        ffi.Uint32,
        DNSServiceRegisterRecordReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceRegisterRecord(
  DNSServiceRef sdRef,
  ffi.Pointer<DNSRecordRef> RecordRef,
  int flags,
  int interfaceIndex,
  ffi.Pointer<ffi.Char> fullname,
  int rrtype,
  int rrclass,
  int rdlen,
  ffi.Pointer<ffi.Void> rdata,
  int ttl,
  DNSServiceRegisterRecordReply callBack,
  ffi.Pointer<ffi.Void> context,
);

/// !
/// @brief
/// Instruct the daemon to verify the validity of a resource record that appears
/// to be out of date (e.g. because TCP connection to a service's target failed.)
/// Causes the record to be flushed from the daemon's cache (as well as all other
/// daemons' caches on the network) if the record is determined to be invalid.
/// Use this routine conservatively. Reconfirming a record necessarily consumes
/// network bandwidth, so this should not be done indiscriminately.
///
/// @param flags
/// Not currently used.
///
/// @param interfaceIndex
/// Specifies the interface of the record in question.
/// The caller must specify the interface.
/// This API (by design) causes increased network traffic, so it requires
/// the caller to be precise about which record should be reconfirmed.
/// It is not possible to pass zero for the interface index to perform
/// a "wildcard" reconfirmation, where *all* matching records are reconfirmed.
///
/// @param fullname
/// The resource record's full domain name.
///
/// @param rrtype
/// The resource record's type (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
///
/// @param rrclass
/// The class of the resource record (usually kDNSServiceClass_IN).
///
/// @param rdlen
/// The length, in bytes, of the resource record rdata.
///
/// @param rdata
/// The raw rdata of the resource record.
@ffi.Native<
    DNSServiceErrorType Function(
        DNSServiceFlags,
        ffi.Uint32,
        ffi.Pointer<ffi.Char>,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceReconfirmRecord(
  int flags,
  int interfaceIndex,
  ffi.Pointer<ffi.Char> fullname,
  int rrtype,
  int rrclass,
  int rdlen,
  ffi.Pointer<ffi.Void> rdata,
);

/// !
/// @brief
/// Request a port mapping in the NAT gateway, which maps a port on the local machine
/// to an external port on the NAT.
///
/// @param sdRef
/// A pointer to an uninitialized DNSServiceRef
/// (or, if the kDNSServiceFlagsShareConnection flag is used,
/// a copy of the shared connection reference that is to be used).
/// If the call succeeds then it initializes (or updates) the DNSServiceRef,
/// returns kDNSServiceErr_NoError, and the NAT port mapping
/// will remain active indefinitely until the client terminates it
/// by passing this DNSServiceRef to DNSServiceRefDeallocate()
/// (or by closing the underlying shared connection, if used).
///
/// @param flags
/// Possible values are:
/// kDNSServiceFlagsShareConnection to use a shared connection.
///
/// @param interfaceIndex
/// The interface on which to create port mappings in a NAT gateway.
/// Passing 0 causes the port mapping request to be sent on the primary interface.
///
/// @param protocol
/// To request a port mapping, pass in kDNSServiceProtocol_UDP, or kDNSServiceProtocol_TCP,
/// or (kDNSServiceProtocol_UDP | kDNSServiceProtocol_TCP) to map both.
/// The local listening port number must also be specified in the internalPort parameter.
/// To just discover the NAT gateway's external IP address, pass zero for protocol,
/// internalPort, externalPort and ttl.
///
/// @param internalPort
/// The port number in network byte order on the local machine which is listening for packets.
///
/// @param externalPort
/// The requested external port in network byte order in the NAT gateway that you would
/// like to map to the internal port. Pass 0 if you don't care which external port is chosen for you.
///
/// @param ttl
/// The requested renewal period of the NAT port mapping, in seconds.
/// If the client machine crashes, suffers a power failure, is disconnected from
/// the network, or suffers some other unfortunate demise which causes it to vanish
/// unexpectedly without explicitly removing its NAT port mappings, then the NAT gateway
/// will garbage-collect old stale NAT port mappings when their lifetime expires.
/// Requesting a short TTL causes such orphaned mappings to be garbage-collected
/// more promptly, but consumes system resources and network bandwidth with
/// frequent renewal packets to keep the mapping from expiring.
/// Requesting a long TTL is more efficient on the network, but in the event of the
/// client vanishing, stale NAT port mappings will not be garbage-collected as quickly.
/// Most clients should pass 0 to use a system-wide default value.
///
/// @param callBack
/// The function to be called when the port mapping request succeeds or fails asynchronously.
///
/// @param context
/// An application context pointer which is passed to the callback function
/// (may be NULL).
///
/// @result
/// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
/// errors are delivered to the callback), otherwise returns an error code indicating
/// the error that occurred.
///
/// If you don't actually want a port mapped, and are just calling the API
/// because you want to find out the NAT's external IP address (e.g. for UI
/// display) then pass zero for protocol, internalPort, externalPort and ttl.
///
/// @discussion
/// The NAT should support either PCP, NAT-PMP or the
/// UPnP/IGD protocol for this API to create a successful mapping. Note that this API
/// currently supports IPv4 addresses/mappings only. If the NAT gateway supports PCP and
/// returns an IPv6 address (incorrectly, since this API specifically requests IPv4
/// addresses), the DNSServiceNATPortMappingReply callback will be invoked with errorCode
/// kDNSServiceErr_NATPortMappingUnsupported.
///
/// The port mapping will be renewed indefinitely until the client process exits, or
/// explicitly terminates the port mapping request by calling DNSServiceRefDeallocate().
/// The client callback will be invoked, informing the client of the NAT gateway's
/// external IP address and the external port that has been allocated for this client.
/// The client should then record this external IP address and port using whatever
/// directory service mechanism it is using to enable peers to connect to it.
/// (Clients advertising services using Wide-Area DNS-SD DO NOT need to use this API
/// -- when a client calls DNSServiceRegister() NAT mappings are automatically created
/// and the external IP address and port for the service are recorded in the global DNS.
/// Only clients using some directory mechanism other than Wide-Area DNS-SD need to use
/// this API to explicitly map their own ports.)
///
/// It's possible that the client callback could be called multiple times, for example
/// if the NAT gateway's IP address changes, or if a configuration change results in a
/// different external port being mapped for this client. Over the lifetime of any long-lived
/// port mapping, the client should be prepared to handle these notifications of changes
/// in the environment, and should update its recorded address and/or port as appropriate.
///
/// NOTE: There are two unusual aspects of how the DNSServiceNATPortMappingCreate API works,
/// which were intentionally designed to help simplify client code:
///
/// 1. It's not an error to request a NAT mapping when the machine is not behind a NAT gateway.
/// In other NAT mapping APIs, if you request a NAT mapping and the machine is not behind a NAT
/// gateway, then the API returns an error code -- it can't get you a NAT mapping if there's no
/// NAT gateway. The DNSServiceNATPortMappingCreate API takes a different view. Working out
/// whether or not you need a NAT mapping can be tricky and non-obvious, particularly on
/// a machine with multiple active network interfaces. Rather than make every client recreate
/// this logic for deciding whether a NAT mapping is required, the PortMapping API does that
/// work for you. If the client calls the PortMapping API when the machine already has a
/// routable public IP address, then instead of complaining about it and giving an error,
/// the PortMapping API just invokes your callback, giving the machine's public address
/// and your own port number. This means you don't need to write code to work out whether
/// your client needs to call the PortMapping API -- just call it anyway, and if it wasn't
/// necessary, no harm is done:
///
/// - If the machine already has a routable public IP address, then your callback
/// will just be invoked giving your own address and port.
/// - If a NAT mapping is required and obtained, then your callback will be invoked
/// giving you the external address and port.
/// - If a NAT mapping is required but not obtained from the local NAT gateway,
/// or the machine has no network connectivity, then your callback will be
/// invoked giving zero address and port.
///
/// 2. In other NAT mapping APIs, if a laptop computer is put to sleep and woken up on a new
/// network, it's the client's job to notice this, and work out whether a NAT mapping
/// is required on the new network, and make a new NAT mapping request if necessary.
/// The DNSServiceNATPortMappingCreate API does this for you, automatically.
/// The client just needs to make one call to the PortMapping API, and its callback will
/// be invoked any time the mapping state changes. This property complements point (1) above.
/// If the client didn't make a NAT mapping request just because it determined that one was
/// not required at that particular moment in time, the client would then have to monitor
/// for network state changes to determine if a NAT port mapping later became necessary.
/// By unconditionally making a NAT mapping request, even when a NAT mapping not to be
/// necessary, the PortMapping API will then begin monitoring network state changes on behalf of
/// the client, and if a NAT mapping later becomes necessary, it will automatically create a NAT
/// mapping and inform the client with a new callback giving the new address and port information.
@ffi.Native<
    DNSServiceErrorType Function(
        ffi.Pointer<DNSServiceRef>,
        DNSServiceFlags,
        ffi.Uint32,
        DNSServiceProtocol,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Uint32,
        DNSServiceNATPortMappingReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceNATPortMappingCreate(
  ffi.Pointer<DNSServiceRef> sdRef,
  int flags,
  int interfaceIndex,
  int protocol,
  int internalPort,
  int externalPort,
  int ttl,
  DNSServiceNATPortMappingReply callBack,
  ffi.Pointer<ffi.Void> context,
);

/// !
/// @brief
/// Concatenate a three-part domain name (as returned by the above callbacks) into a
/// properly-escaped full domain name. Note that callbacks in the above functions ALREADY ESCAPE
/// strings where necessary.
///
/// @param fullName
/// A pointer to a buffer that where the resulting full domain name is to be written.
/// The buffer must be kDNSServiceMaxDomainName (1009) bytes in length to
/// accommodate the longest legal domain name without buffer overrun.
///
/// @param service
/// The service name - any dots or backslashes must NOT be escaped.
/// May be NULL (to construct a PTR record name, e.g.
/// "_ftp._tcp.apple.com.").
///
/// @param regtype
/// The service type followed by the protocol, separated by a dot
/// (e.g. "_ftp._tcp").
///
/// @param domain
/// The domain name, e.g. "apple.com.". Literal dots or backslashes,
/// if any, must be escaped, e.g. "1st\. Floor.apple.com."
///
/// @result:
/// Returns kDNSServiceErr_NoError (0) on success, kDNSServiceErr_BadParam on error.
@ffi.Native<
    DNSServiceErrorType Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external int DNSServiceConstructFullName(
  ffi.Pointer<ffi.Char> fullName,
  ffi.Pointer<ffi.Char> service,
  ffi.Pointer<ffi.Char> regtype,
  ffi.Pointer<ffi.Char> domain,
);

/// !
/// @brief
/// Allows you to schedule a DNSServiceRef on a serial dispatch queue for receiving asynchronous
/// callbacks.  It's the clients responsibility to ensure that the provided dispatch queue is running.
///
/// @param service
/// DNSServiceRef that was allocated and returned to the application, when the
/// application calls one of the DNSService API.
///
/// @param queue
/// dispatch queue where the application callback will be scheduled
///
/// @result
/// Returns kDNSServiceErr_NoError on success.
/// Returns kDNSServiceErr_NoMemory if it cannot create a dispatch source
/// Returns kDNSServiceErr_BadParam if the service param is invalid or the
/// queue param is invalid
///
/// @discussion
/// A typical application that uses CFRunLoopRun or dispatch_main on its main thread will
/// usually schedule DNSServiceRefs on its main queue (which is always a serial queue)
/// using "DNSServiceSetDispatchQueue(sdref, dispatch_get_main_queue());"
///
/// If there is any error during the processing of events, the application callback will
/// be called with an error code. For shared connections, each subordinate DNSServiceRef
/// will get its own error callback. Currently these error callbacks only happen
/// if the daemon is manually terminated or crashes, and the error
/// code in this case is kDNSServiceErr_ServiceNotRunning. The application must call
/// DNSServiceRefDeallocate to free the DNSServiceRef when it gets such an error code.
/// These error callbacks are rare and should not normally happen on customer machines,
/// but application code should be written defensively to handle such error callbacks
/// gracefully if they occur.
///
/// After using DNSServiceSetDispatchQueue on a DNSServiceRef, calling DNSServiceProcessResult
/// on the same DNSServiceRef will result in undefined behavior and should be avoided.
///
/// Once the application successfully schedules a DNSServiceRef on a serial dispatch queue using
/// DNSServiceSetDispatchQueue, it cannot remove the DNSServiceRef from the dispatch queue, or use
/// DNSServiceSetDispatchQueue a second time to schedule the DNSServiceRef onto a different serial dispatch
/// queue. Once scheduled onto a dispatch queue a DNSServiceRef will deliver events to that queue until
/// the application no longer requires that operation and terminates it using DNSServiceRefDeallocate.
/// Note that the call to DNSServiceRefDeallocate() must be done on the same queue originally passed
/// as an argument to DNSServiceSetDispatchQueue().
@ffi.Native<DNSServiceErrorType Function(DNSServiceRef, dispatch_queue_t)>()
external int DNSServiceSetDispatchQueue(
  DNSServiceRef service,
  dispatch_queue_t queue,
);

@ffi.Native<
    DNSServiceErrorType Function(
        ffi.Pointer<DNSServiceRef>,
        DNSServiceFlags,
        ffi.Int,
        ffi.UnsignedInt,
        DNSServiceSleepKeepaliveReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceSleepKeepalive(
  ffi.Pointer<DNSServiceRef> sdRef,
  int flags,
  int fd,
  int timeout,
  DNSServiceSleepKeepaliveReply callBack,
  ffi.Pointer<ffi.Void> context,
);

@ffi.Native<DNSServiceAttributeRef Function()>()
external DNSServiceAttributeRef DNSServiceAttributeCreate();

@ffi.Native<DNSServiceErrorType Function(DNSServiceAttributeRef, ffi.Int32)>()
external int DNSServiceAttributeSetAAAAPolicy(
  DNSServiceAttributeRef attr,
  int policy,
);

@ffi.Native<DNSServiceErrorType Function(DNSServiceAttributeRef, ffi.Uint32)>()
external int DNSServiceAttributeSetTimestamp(
  DNSServiceAttributeRef attr,
  int timestamp,
);

@ffi.Native<ffi.Void Function(DNSServiceAttributeRef)>()
external void DNSServiceAttributeDeallocate(
  DNSServiceAttributeRef attr,
);

@ffi.Native<
    DNSServiceErrorType Function(
        ffi.Pointer<DNSServiceRef>,
        DNSServiceFlags,
        ffi.Uint32,
        ffi.Pointer<ffi.Char>,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Pointer<DNSServiceAttribute>,
        DNSServiceQueryRecordReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceQueryRecordWithAttribute(
  ffi.Pointer<DNSServiceRef> sdRef,
  int flags,
  int ifindex,
  ffi.Pointer<ffi.Char> name,
  int rrtype,
  int rrclass,
  ffi.Pointer<DNSServiceAttribute> attr,
  DNSServiceQueryRecordReply callback,
  ffi.Pointer<ffi.Void> context,
);

@ffi.Native<
    DNSServiceErrorType Function(
        ffi.Pointer<DNSServiceRef>,
        DNSServiceFlags,
        ffi.Uint32,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Pointer<ffi.Void>,
        DNSServiceAttributeRef,
        DNSServiceRegisterReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceRegisterWithAttribute(
  ffi.Pointer<DNSServiceRef> sdRef,
  int flags,
  int interfaceIndex,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Char> regtype,
  ffi.Pointer<ffi.Char> domain,
  ffi.Pointer<ffi.Char> host,
  int portInNetworkByteOrder,
  int txtLen,
  ffi.Pointer<ffi.Void> txtRecord,
  DNSServiceAttributeRef attr,
  DNSServiceRegisterReply callBack,
  ffi.Pointer<ffi.Void> context,
);

@ffi.Native<
    DNSServiceErrorType Function(
        DNSServiceRef,
        ffi.Pointer<DNSRecordRef>,
        DNSServiceFlags,
        ffi.Uint32,
        ffi.Pointer<ffi.Char>,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Uint16,
        ffi.Pointer<ffi.Void>,
        ffi.Uint32,
        DNSServiceAttributeRef,
        DNSServiceRegisterRecordReply,
        ffi.Pointer<ffi.Void>)>()
external int DNSServiceRegisterRecordWithAttribute(
  DNSServiceRef sdRef,
  ffi.Pointer<DNSRecordRef> recordRef,
  int flags,
  int interfaceIndex,
  ffi.Pointer<ffi.Char> fullname,
  int rrtype,
  int rrclass,
  int rdlen,
  ffi.Pointer<ffi.Void> rdata,
  int ttl,
  DNSServiceAttributeRef attr,
  DNSServiceRegisterRecordReply callBack,
  ffi.Pointer<ffi.Void> context,
);

@ffi.Native<DNSServiceErrorType Function(DNSServiceRef)>()
external int DNSServiceSendQueuedRequests(
  DNSServiceRef sdRef,
);

@ffi.Native<
    ffi.Int Function(
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
        ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
        ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>)>()
external int res_9_dn_comp(
  ffi.Pointer<ffi.Char> arg0,
  ffi.Pointer<ffi.UnsignedChar> arg1,
  int arg2,
  ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> arg3,
  ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> arg4,
);

/// !
/// @typedef dispatch_time_t
///
/// @abstract
/// A somewhat abstract representation of time; where zero means "now" and
/// DISPATCH_TIME_FOREVER means "infinity" and every value in between is an
/// opaque encoding.
typedef dispatch_time_t = ffi.Uint64;
typedef Dartdispatch_time_t = int;

final class timespec extends ffi.Struct {
  @ffi.Long()
  external int tv_sec;

  @ffi.Long()
  external int tv_nsec;
}

final class dispatch_object_t extends ffi.Union {
  external ffi.Pointer<_os_object_s> _os_obj;

  external ffi.Pointer<dispatch_object_s> _do;

  external ffi.Pointer<dispatch_queue_s> _dq;

  external ffi.Pointer<dispatch_queue_attr_s> _dqa;

  external ffi.Pointer<dispatch_group_s> _dg;

  external ffi.Pointer<dispatch_source_s> _ds;

  external ffi.Pointer<dispatch_channel_s> _dch;

  external ffi.Pointer<dispatch_mach_s> _dm;

  external ffi.Pointer<dispatch_mach_msg_s> _dmsg;

  external ffi.Pointer<dispatch_semaphore_s> _dsema;

  external ffi.Pointer<dispatch_data_s> _ddata;

  external ffi.Pointer<dispatch_io_s> _dchannel;
}

final class _os_object_s extends ffi.Opaque {}

final class dispatch_object_s extends ffi.Opaque {}

final class dispatch_queue_s extends ffi.Opaque {}

final class dispatch_queue_attr_s extends ffi.Opaque {}

final class dispatch_group_s extends ffi.Opaque {}

final class dispatch_source_s extends ffi.Opaque {}

final class dispatch_channel_s extends ffi.Opaque {}

final class dispatch_mach_s extends ffi.Opaque {}

final class dispatch_mach_msg_s extends ffi.Opaque {}

final class dispatch_semaphore_s extends ffi.Opaque {}

final class dispatch_data_s extends ffi.Opaque {}

final class dispatch_io_s extends ffi.Opaque {}

typedef dispatch_function_t
    = ffi.Pointer<ffi.NativeFunction<dispatch_function_tFunction>>;
typedef dispatch_function_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void>);
typedef Dartdispatch_function_tFunction = void Function(ffi.Pointer<ffi.Void>);
typedef dispatch_qos_class_t = ffi.UnsignedInt;
typedef Dartdispatch_qos_class_t = int;
typedef dispatch_queue_t = ffi.Pointer<dispatch_queue_s>;
typedef dispatch_queue_global_t = dispatch_queue_t;
typedef dispatch_queue_attr_t = ffi.Pointer<dispatch_queue_attr_s>;

abstract class dispatch_autorelease_frequency_t {
  /// !
  /// @typedef dispatch_autorelease_frequency_t
  /// Values to pass to the dispatch_queue_attr_make_with_autorelease_frequency()
  /// function.
  ///
  /// @const DISPATCH_AUTORELEASE_FREQUENCY_INHERIT
  /// Dispatch queues with this autorelease frequency inherit the behavior from
  /// their target queue. This is the default behavior for manually created queues.
  ///
  /// @const DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM
  /// Dispatch queues with this autorelease frequency push and pop an autorelease
  /// pool around the execution of every block that was submitted to it
  /// asynchronously.
  /// @see dispatch_queue_attr_make_with_autorelease_frequency().
  ///
  /// @const DISPATCH_AUTORELEASE_FREQUENCY_NEVER
  /// Dispatch queues with this autorelease frequency never set up an individual
  /// autorelease pool around the execution of a block that is submitted to it
  /// asynchronously. This is the behavior of the global concurrent queues.
  static const int DISPATCH_AUTORELEASE_FREQUENCY_INHERIT = 0;
  static const int DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM = 1;
  static const int DISPATCH_AUTORELEASE_FREQUENCY_NEVER = 2;
}

final class dispatch_source_type_s extends ffi.Opaque {}

typedef dispatch_source_t = ffi.Pointer<dispatch_source_s>;

/// !
/// @typedef dispatch_source_type_t
///
/// @abstract
/// Constants of this type represent the class of low-level system object that
/// is being monitored by the dispatch source. Constants of this type are
/// passed as a parameter to dispatch_source_create() and determine how the
/// handle argument is interpreted (i.e. as a file descriptor, mach port,
/// signal number, process identifier, etc.), and how the mask argument is
/// interpreted.
typedef dispatch_source_type_t = ffi.Pointer<dispatch_source_type_s>;
typedef dispatch_group_t = ffi.Pointer<dispatch_group_s>;
typedef dispatch_semaphore_t = ffi.Pointer<dispatch_semaphore_s>;

/// !
/// @typedef dispatch_once_t
///
/// @abstract
/// A predicate for use with dispatch_once(). It must be initialized to zero.
/// Note: static and global variables default to zero.
typedef dispatch_once_t = ffi.IntPtr;
typedef Dartdispatch_once_t = int;
typedef dispatch_data_t = ffi.Pointer<dispatch_data_s>;
typedef dispatch_io_t = ffi.Pointer<dispatch_io_s>;
typedef dispatch_io_close_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_io_close_flags_t = int;
typedef dispatch_fd_t = ffi.Int;
typedef Dartdispatch_fd_t = int;
typedef dispatch_io_interval_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_io_interval_flags_t = int;
typedef dispatch_workloop_t = dispatch_queue_t;

final class os_workgroup_s extends ffi.Opaque {}

final class DNSServiceAttribute_s extends ffi.Opaque {}

typedef DNSServiceErrorType = ffi.Int32;
typedef DartDNSServiceErrorType = int;

/// DNSServiceRef, DNSRecordRef
///
/// Opaque internal data types.
/// Note: client is responsible for serializing access to these structures if
/// they are shared between concurrent threads.
typedef DNSServiceRef = ffi.Pointer<_DNSServiceRef_t>;

final class _DNSServiceRef_t extends ffi.Opaque {}

typedef DNSServiceFlags = ffi.Uint32;
typedef DartDNSServiceFlags = int;

/// !
/// @brief
/// The definition of the DNSServiceEnumerateDomains callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceEnumerateDomains().
///
/// @param flags
/// Possible values are:
/// kDNSServiceFlagsMoreComing
/// kDNSServiceFlagsAdd
/// kDNSServiceFlagsDefault
///
/// @param interfaceIndex
/// Specifies the interface on which the domain exists. (The index for a given
/// interface is determined via the if_nametoindex() family of calls.)
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError (0) on success, otherwise indicates
/// the failure that occurred (other parameters are undefined if errorCode is nonzero).
///
/// @param replyDomain
/// The name of the domain.
///
/// @param context
/// The context pointer passed to DNSServiceEnumerateDomains.
typedef DNSServiceDomainEnumReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceDomainEnumReplyFunction>>;
typedef DNSServiceDomainEnumReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> replyDomain,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceDomainEnumReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> replyDomain,
    ffi.Pointer<ffi.Void> context);

/// !
/// @brief
/// The definition of the DNSServiceRegister callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceRegister().
///
/// @param flags
/// When a name is successfully registered, the callback will be
/// invoked with the kDNSServiceFlagsAdd flag set. When Wide-Area
/// DNS-SD is in use, it is possible for a single service to get
/// more than one success callback (e.g. one in the "local" multicast
/// DNS domain, and another in a wide-area unicast DNS domain).
/// If a successfully-registered name later suffers a name conflict
/// or similar problem and has to be deregistered, the callback will
/// be invoked with the kDNSServiceFlagsAdd flag not set. The callback
/// is *not* invoked in the case where the caller explicitly terminates
/// the service registration by calling DNSServiceRefDeallocate(ref);
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError on success, otherwise will
/// indicate the failure that occurred (including name conflicts,
/// if the kDNSServiceFlagsNoAutoRename flag was used when registering.)
/// Other parameters are undefined if errorCode is nonzero.
///
/// @param name
/// The service name registered (if the application did not specify a name in
/// DNSServiceRegister(), this indicates what name was automatically chosen).
///
/// @param regtype
/// The type of service registered, as it was passed to the callout.
///
/// @param domain
/// The domain on which the service was registered (if the application did not
/// specify a domain in DNSServiceRegister(), this indicates the default domain
/// on which the service was registered).
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceRegisterReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceRegisterReplyFunction>>;
typedef DNSServiceRegisterReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> domain,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceRegisterReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> domain,
    ffi.Pointer<ffi.Void> context);
typedef DNSRecordRef = ffi.Pointer<_DNSRecordRef_t>;

final class _DNSRecordRef_t extends ffi.Opaque {}

typedef DNSServiceAttributeRef = ffi.Pointer<DNSServiceAttribute>;
typedef DNSServiceAttribute = DNSServiceAttribute_s;

/// !
/// @brief
/// The definition of the DNSServiceBrowse callback function
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceBrowse().
///
/// @param flags
/// Possible values are kDNSServiceFlagsMoreComing and kDNSServiceFlagsAdd.
/// See flag definitions for details.
///
/// @param interfaceIndex
/// The interface on which the service is advertised. This index should
/// be passed to DNSServiceResolve() when resolving the service.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError (0) on success, otherwise will
/// indicate the failure that occurred. Other parameters are undefined if
/// the errorCode is nonzero.
///
/// @param serviceName
/// The discovered service name. This name should be displayed to the user,
/// and stored for subsequent use in the DNSServiceResolve() call.
///
/// @param regtype
/// The service type, which is usually (but not always) the same as was passed
/// to DNSServiceBrowse(). One case where the discovered service type may
/// not be the same as the requested service type is when using subtypes:
/// The client may want to browse for only those ftp servers that allow
/// anonymous connections. The client will pass the string "_ftp._tcp,_anon"
/// to DNSServiceBrowse(), but the type of the service that's discovered
/// is simply "_ftp._tcp". The regtype for each discovered service instance
/// should be stored along with the name, so that it can be passed to
/// DNSServiceResolve() when the service is later resolved.
///
/// @param replyDomain
/// The domain of the discovered service instance. This may or may not be the
/// same as the domain that was passed to DNSServiceBrowse(). The domain for each
/// discovered service instance should be stored along with the name, so that
/// it can be passed to DNSServiceResolve() when the service is later resolved.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceBrowseReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceBrowseReplyFunction>>;
typedef DNSServiceBrowseReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> serviceName,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> replyDomain,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceBrowseReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> serviceName,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> replyDomain,
    ffi.Pointer<ffi.Void> context);

/// !
/// @brief
/// The definition of the DNSServiceResolve callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceResolve().
///
/// @param flags
/// Possible values: kDNSServiceFlagsMoreComing
///
/// @param interfaceIndex
/// The interface on which the service was resolved.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError (0) on success, otherwise will
/// indicate the failure that occurred. Other parameters are undefined if
/// the errorCode is nonzero.
///
/// @param fullname
/// The full service domain name, in the form <servicename>.<protocol>.<domain>.
/// (This name is escaped following standard DNS rules, making it suitable for
/// passing to standard system DNS APIs such as res_query(), or to the
/// special-purpose functions included in this API that take fullname parameters.
/// See "Notes on DNS Name Escaping" earlier in this file for more details.)
///
/// @param hosttarget
/// The target hostname of the machine providing the service. This name can
/// be passed to functions like gethostbyname() to identify the host's IP address.
///
/// @param port
/// The port, in network byte order, on which connections are accepted for this service.
///
/// @param txtLen
/// The length of the txt record, in bytes.
///
/// @param txtRecord
/// The service's primary txt record, in standard txt record format.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceResolveReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceResolveReplyFunction>>;
typedef DNSServiceResolveReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> fullname,
    ffi.Pointer<ffi.Char> hosttarget,
    ffi.Uint16 port,
    ffi.Uint16 txtLen,
    ffi.Pointer<ffi.UnsignedChar> txtRecord,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceResolveReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> fullname,
    ffi.Pointer<ffi.Char> hosttarget,
    int port,
    int txtLen,
    ffi.Pointer<ffi.UnsignedChar> txtRecord,
    ffi.Pointer<ffi.Void> context);

/// !
/// @brief
/// The definition of the DNSServiceQueryRecord callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceQueryRecord().
///
/// @param flags
/// Possible values are kDNSServiceFlagsMoreComing and
/// kDNSServiceFlagsAdd. The Add flag is NOT set for PTR records
/// with a ttl of 0, i.e. "Remove" events.
///
/// @param interfaceIndex
/// The interface on which the query was resolved (the index for a given
/// interface is determined via the if_nametoindex() family of calls).
/// See "Constants for specifying an interface index" for more details.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError on success, otherwise will
/// indicate the failure that occurred. Other parameters are undefined if
/// errorCode is nonzero.
///
/// @param fullname
/// The resource record's full domain name.
///
/// @param rrtype
/// The resource record's type (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
///
/// @param rrclass
/// The class of the resource record (usually kDNSServiceClass_IN).
///
/// @param rdlen
/// The length, in bytes, of the resource record rdata.
///
/// @param rdata
/// The raw rdata of the resource record.
///
/// @param ttl
/// If the client wishes to cache the result for performance reasons,
/// the TTL indicates how long the client may legitimately hold onto
/// this result, in seconds. After the TTL expires, the client should
/// consider the result no longer valid, and if it requires this data
/// again, it should be re-fetched with a new query. Of course, this
/// only applies to clients that cancel the asynchronous operation when
/// they get a result. Clients that leave the asynchronous operation
/// running can safely assume that the data remains valid until they
/// get another callback telling them otherwise. The ttl value is not
/// updated when the daemon answers from the cache, hence relying on
/// the accuracy of the ttl value is not recommended.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceQueryRecordReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceQueryRecordReplyFunction>>;
typedef DNSServiceQueryRecordReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> fullname,
    ffi.Uint16 rrtype,
    ffi.Uint16 rrclass,
    ffi.Uint16 rdlen,
    ffi.Pointer<ffi.Void> rdata,
    ffi.Uint32 ttl,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceQueryRecordReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> fullname,
    int rrtype,
    int rrclass,
    int rdlen,
    ffi.Pointer<ffi.Void> rdata,
    int ttl,
    ffi.Pointer<ffi.Void> context);
typedef DNSServiceProtocol = ffi.Uint32;
typedef DartDNSServiceProtocol = int;

/// !
/// @brief
/// The definition of the DNSServiceGetAddrInfo callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceGetAddrInfo().
///
/// @param flags
/// Possible values are kDNSServiceFlagsMoreComing and
/// kDNSServiceFlagsAdd.
///
/// @param interfaceIndex
/// The interface to which the answers pertain.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError on success, otherwise will
/// indicate the failure that occurred.  Other parameters are
/// undefined if errorCode is nonzero.
///
/// @param hostname
/// The fully qualified domain name of the host to be queried for.
///
/// @param address
/// IPv4 or IPv6 address.
///
/// @param ttl
/// If the client wishes to cache the result for performance reasons,
/// the TTL indicates how long the client may legitimately hold onto
/// this result, in seconds. After the TTL expires, the client should
/// consider the result no longer valid, and if it requires this data
/// again, it should be re-fetched with a new query. Of course, this
/// only applies to clients that cancel the asynchronous operation when
/// they get a result. Clients that leave the asynchronous operation
/// running can safely assume that the data remains valid until they
/// get another callback telling them otherwise. The ttl value is not
/// updated when the daemon answers from the cache, hence relying on
/// the accuracy of the ttl value is not recommended.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceGetAddrInfoReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceGetAddrInfoReplyFunction>>;
typedef DNSServiceGetAddrInfoReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> hostname,
    ffi.Pointer<sockaddr> address,
    ffi.Uint32 ttl,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceGetAddrInfoReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> hostname,
    ffi.Pointer<sockaddr> address,
    int ttl,
    ffi.Pointer<ffi.Void> context);

/// [XSI] Structure used by kernel to store most addresses.
final class sockaddr extends ffi.Struct {
  /// total length
  @ffi.UnsignedChar()
  external int sa_len;

  /// [XSI] address family
  @ffi.UnsignedChar()
  external int sa_family;

  /// [XSI] addr value
  @ffi.Array.multi([14])
  external ffi.Array<ffi.Char> sa_data;
}

/// !
/// @brief
/// The definition of the DNSServiceRegisterRecord callback function.
///
/// @param sdRef
/// The connected DNSServiceRef initialized by
/// DNSServiceCreateConnection().
///
/// @param RecordRef
/// The DNSRecordRef initialized by DNSServiceRegisterRecord(). If the above
/// DNSServiceRef is passed to DNSServiceRefDeallocate(), this DNSRecordRef is
/// invalidated, and may not be used further.
///
/// @param flags
/// Currently unused, reserved for future use.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError on success, otherwise will
/// indicate the failure that occurred (including name conflicts.)
/// Other parameters are undefined if errorCode is nonzero.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceRegisterRecordReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceRegisterRecordReplyFunction>>;
typedef DNSServiceRegisterRecordReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSRecordRef RecordRef,
    DNSServiceFlags flags,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceRegisterRecordReplyFunction = void Function(
    DNSServiceRef sdRef,
    DNSRecordRef RecordRef,
    DartDNSServiceFlags flags,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Void> context);

/// !
/// @brief
/// The definition of the DNSServiceNATPortMappingCreate callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceNATPortMappingCreate().
///
/// @param flags
/// Currently unused, reserved for future use.
///
/// @param interfaceIndex
/// The interface through which the NAT gateway is reached.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError on success.
/// Will be kDNSServiceErr_DoubleNAT when the NAT gateway is itself behind one or
/// more layers of NAT, in which case the other parameters have the defined values.
/// For other failures, will indicate the failure that occurred, and the other
/// parameters are undefined.
///
/// @param externalAddress
/// Four byte IPv4 address in network byte order.
///
/// @param protocol
/// Will be kDNSServiceProtocol_UDP or kDNSServiceProtocol_TCP or both.
///
/// @param internalPort
/// The port on the local machine that was mapped.
///
/// @param externalPort
/// The actual external port in the NAT gateway that was mapped.
/// This is likely to be different than the requested external port.
///
/// @param ttl
/// The lifetime of the NAT port mapping created on the gateway.
/// This controls how quickly stale mappings will be garbage-collected
/// if the client machine crashes, suffers a power failure, is disconnected
/// from the network, or suffers some other unfortunate demise which
/// causes it to vanish without explicitly removing its NAT port mapping.
/// It's possible that the ttl value will differ from the requested ttl value.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceNATPortMappingReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceNATPortMappingReplyFunction>>;
typedef DNSServiceNATPortMappingReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Uint32 externalAddress,
    DNSServiceProtocol protocol,
    ffi.Uint16 internalPort,
    ffi.Uint16 externalPort,
    ffi.Uint32 ttl,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceNATPortMappingReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    int externalAddress,
    DartDNSServiceProtocol protocol,
    int internalPort,
    int externalPort,
    int ttl,
    ffi.Pointer<ffi.Void> context);
typedef DNSServiceSleepKeepaliveReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceSleepKeepaliveReplyFunction>>;
typedef DNSServiceSleepKeepaliveReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceSleepKeepaliveReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Void> context);

abstract class DNSServiceAAAAPolicy {
  static const int kDNSServiceAAAAPolicyNone = 0;

  /// If AAAA record doesn't exist, query for A.
  static const int kDNSServiceAAAAPolicyFallback = 1;
}

/// DNS query / reply header
final class dns_header_t extends ffi.Struct {
  @ffi.Uint16()
  external int xid;

  @ffi.Uint16()
  external int flags;

  @ffi.Uint16()
  external int qdcount;

  @ffi.Uint16()
  external int ancount;

  @ffi.Uint16()
  external int nscount;

  @ffi.Uint16()
  external int arcount;
}

/// DNS query
final class dns_question_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  @ffi.Uint16()
  external int dnstype;

  @ffi.Uint16()
  external int dnsclass;
}

/// Resource Record types
/// dns_parse_packet() creates resourse records of these types.
final class dns_raw_resource_record_t extends ffi.Struct {
  @ffi.Uint16()
  external int length;

  external ffi.Pointer<ffi.Char> data;
}

final class dns_address_record_t extends ffi.Struct {
  external in_addr addr;
}

/// Internet address (a structure for historical reasons)
final class in_addr extends ffi.Struct {
  @ffi.UnsignedInt()
  external int s_addr;
}

final class dns_in6_address_record_t extends ffi.Struct {
  external in6_addr addr;
}

/// IPv6 address
final class in6_addr extends ffi.Struct {
  /// 128-bit IP6 address
  external UnnamedUnion1 __u6_addr;
}

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedChar> __u6_addr8;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedShort> __u6_addr16;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedInt> __u6_addr32;
}

final class dns_domain_name_record_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;
}

final class dns_SOA_record_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> mname;

  external ffi.Pointer<ffi.Char> rname;

  @ffi.Uint32()
  external int serial;

  @ffi.Uint32()
  external int refresh;

  @ffi.Uint32()
  external int retry;

  @ffi.Uint32()
  external int expire;

  @ffi.Uint32()
  external int minimum;
}

final class dns_HINFO_record_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> cpu;

  external ffi.Pointer<ffi.Char> os;
}

final class dns_MINFO_record_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> rmailbx;

  external ffi.Pointer<ffi.Char> emailbx;
}

final class dns_MX_record_t extends ffi.Struct {
  @ffi.Uint16()
  external int preference;

  external ffi.Pointer<ffi.Char> name;
}

final class dns_TXT_record_t extends ffi.Struct {
  @ffi.Uint32()
  external int string_count;

  external ffi.Pointer<ffi.Pointer<ffi.Char>> strings;
}

final class dns_WKS_record_t extends ffi.Struct {
  external in_addr addr;

  @ffi.Uint8()
  external int protocol;

  @ffi.Uint32()
  external int maplength;

  external ffi.Pointer<ffi.Uint8> map;
}

final class dns_RP_record_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> mailbox;

  external ffi.Pointer<ffi.Char> txtdname;
}

final class dns_AFSDB_record_t extends ffi.Struct {
  @ffi.Uint32()
  external int subtype;

  external ffi.Pointer<ffi.Char> hostname;
}

final class dns_X25_record_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> psdn_address;
}

final class dns_ISDN_record_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> isdn_address;

  external ffi.Pointer<ffi.Char> subaddress;
}

final class dns_RT_record_t extends ffi.Struct {
  @ffi.Uint16()
  external int preference;

  external ffi.Pointer<ffi.Char> intermediate;
}

final class dns_LOC_record_t extends ffi.Struct {
  @ffi.Uint8()
  external int version;

  @ffi.Uint8()
  external int size;

  @ffi.Uint8()
  external int horizontal_precision;

  @ffi.Uint8()
  external int vertical_precision;

  @ffi.Uint32()
  external int latitude;

  @ffi.Uint32()
  external int longitude;

  @ffi.Uint32()
  external int altitude;
}

final class dns_SRV_record_t extends ffi.Struct {
  @ffi.Uint16()
  external int priority;

  @ffi.Uint16()
  external int weight;

  @ffi.Uint16()
  external int port;

  external ffi.Pointer<ffi.Char> target;
}

/// DNS Resource Record
///
/// Data contained in unsupported or obsolete Resource Record types
/// may be accessed via DNSNULL as a dns_raw_resource_record_t.
final class dns_resource_record_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  @ffi.Uint16()
  external int dnstype;

  @ffi.Uint16()
  external int dnsclass;

  @ffi.Uint32()
  external int ttl;

  external UnnamedUnion2 data;
}

final class UnnamedUnion2 extends ffi.Union {
  external ffi.Pointer<dns_address_record_t> A;

  external ffi.Pointer<dns_domain_name_record_t> NS;

  /// Obsolete
  external ffi.Pointer<dns_domain_name_record_t> MD;

  /// Obsolete
  external ffi.Pointer<dns_domain_name_record_t> MF;

  external ffi.Pointer<dns_domain_name_record_t> CNAME;

  external ffi.Pointer<dns_SOA_record_t> SOA;

  external ffi.Pointer<dns_domain_name_record_t> MB;

  external ffi.Pointer<dns_domain_name_record_t> MG;

  external ffi.Pointer<dns_domain_name_record_t> MR;

  external ffi.Pointer<dns_raw_resource_record_t> DNSNULL;

  external ffi.Pointer<dns_WKS_record_t> WKS;

  external ffi.Pointer<dns_domain_name_record_t> PTR;

  external ffi.Pointer<dns_HINFO_record_t> HINFO;

  external ffi.Pointer<dns_MINFO_record_t> MINFO;

  external ffi.Pointer<dns_MX_record_t> MX;

  external ffi.Pointer<dns_TXT_record_t> TXT;

  external ffi.Pointer<dns_RP_record_t> RP;

  external ffi.Pointer<dns_AFSDB_record_t> AFSDB;

  external ffi.Pointer<dns_X25_record_t> X25;

  external ffi.Pointer<dns_ISDN_record_t> ISDN;

  external ffi.Pointer<dns_RT_record_t> RT;

  external ffi.Pointer<dns_in6_address_record_t> AAAA;

  external ffi.Pointer<dns_LOC_record_t> LOC;

  external ffi.Pointer<dns_SRV_record_t> SRV;
}

/// A parsed DNS record.  Returned by dns_parse_packet() and dns_lookup().
/// The contents may be printed using dns_print_reply().
final class dns_reply_t extends ffi.Struct {
  @ffi.Uint32()
  external int status;

  external ffi.Pointer<sockaddr> server;

  external ffi.Pointer<dns_header_t> header;

  external ffi.Pointer<ffi.Pointer<dns_question_t>> question;

  external ffi.Pointer<ffi.Pointer<dns_resource_record_t>> answer;

  external ffi.Pointer<ffi.Pointer<dns_resource_record_t>> authority;

  external ffi.Pointer<ffi.Pointer<dns_resource_record_t>> additional;
}

const int kDNSServiceFlagsMoreComing = 1;

const int kDNSServiceFlagsQueueRequest = 1;

const int kDNSServiceFlagsAutoTrigger = 1;

const int kDNSServiceFlagsAdd = 2;

const int kDNSServiceFlagsDefault = 4;

const int kDNSServiceFlagsNoAutoRename = 8;

const int kDNSServiceFlagsShared = 16;

const int kDNSServiceFlagsUnique = 32;

const int kDNSServiceFlagsBrowseDomains = 64;

const int kDNSServiceFlagsRegistrationDomains = 128;

const int kDNSServiceFlagsLongLivedQuery = 256;

const int kDNSServiceFlagsAllowRemoteQuery = 512;

const int kDNSServiceFlagsForceMulticast = 1024;

const int kDNSServiceFlagsForce = 2048;

const int kDNSServiceFlagsKnownUnique = 2048;

const int kDNSServiceFlagsReturnIntermediates = 4096;

const int kDNSServiceFlagsShareConnection = 16384;

const int kDNSServiceFlagsSuppressUnusable = 32768;

const int kDNSServiceFlagsTimeout = 65536;

const int kDNSServiceFlagsIncludeP2P = 131072;

const int kDNSServiceFlagsWakeOnResolve = 262144;

const int kDNSServiceFlagsBackgroundTrafficClass = 524288;

const int kDNSServiceFlagsIncludeAWDL = 1048576;

const int kDNSServiceFlagsEnableDNSSEC = 2097152;

const int kDNSServiceFlagsValidate = 2097152;

const int kDNSServiceFlagsSecure = 2097168;

const int kDNSServiceFlagsInsecure = 2097184;

const int kDNSServiceFlagsBogus = 2097216;

const int kDNSServiceFlagsIndeterminate = 2097280;

const int kDNSServiceFlagsUnicastResponse = 4194304;

const int kDNSServiceFlagsValidateOptional = 8388608;

const int kDNSServiceFlagsWakeOnlyService = 16777216;

const int kDNSServiceFlagsThresholdOne = 33554432;

const int kDNSServiceFlagsThresholdFinder = 67108864;

const int kDNSServiceFlagsThresholdReached = 33554432;

const int kDNSServiceFlagsPrivateOne = 8192;

const int kDNSServiceFlagsPrivateTwo = 134217728;

const int kDNSServiceFlagsPrivateThree = 268435456;

const int kDNSServiceFlagsPrivateFour = 536870912;

const int kDNSServiceFlagsPrivateFive = 1073741824;

const int kDNSServiceFlagAnsweredFromCache = 1073741824;

const int kDNSServiceFlagsAllowExpiredAnswers = -2147483648;

const int kDNSServiceFlagsExpiredAnswer = -2147483648;

const int kDNSServiceProtocol_IPv4 = 1;

const int kDNSServiceProtocol_IPv6 = 2;

const int kDNSServiceProtocol_UDP = 16;

const int kDNSServiceProtocol_TCP = 32;

const int kDNSServiceClass_IN = 1;

const int kDNSServiceType_A = 1;

const int kDNSServiceType_NS = 2;

const int kDNSServiceType_MD = 3;

const int kDNSServiceType_MF = 4;

const int kDNSServiceType_CNAME = 5;

const int kDNSServiceType_SOA = 6;

const int kDNSServiceType_MB = 7;

const int kDNSServiceType_MG = 8;

const int kDNSServiceType_MR = 9;

const int kDNSServiceType_NULL = 10;

const int kDNSServiceType_WKS = 11;

const int kDNSServiceType_PTR = 12;

const int kDNSServiceType_HINFO = 13;

const int kDNSServiceType_MINFO = 14;

const int kDNSServiceType_MX = 15;

const int kDNSServiceType_TXT = 16;

const int kDNSServiceType_RP = 17;

const int kDNSServiceType_AFSDB = 18;

const int kDNSServiceType_X25 = 19;

const int kDNSServiceType_ISDN = 20;

const int kDNSServiceType_RT = 21;

const int kDNSServiceType_NSAP = 22;

const int kDNSServiceType_NSAP_PTR = 23;

const int kDNSServiceType_SIG = 24;

const int kDNSServiceType_KEY = 25;

const int kDNSServiceType_PX = 26;

const int kDNSServiceType_GPOS = 27;

const int kDNSServiceType_AAAA = 28;

const int kDNSServiceType_LOC = 29;

const int kDNSServiceType_NXT = 30;

const int kDNSServiceType_EID = 31;

const int kDNSServiceType_NIMLOC = 32;

const int kDNSServiceType_SRV = 33;

const int kDNSServiceType_ATMA = 34;

const int kDNSServiceType_NAPTR = 35;

const int kDNSServiceType_KX = 36;

const int kDNSServiceType_CERT = 37;

const int kDNSServiceType_A6 = 38;

const int kDNSServiceType_DNAME = 39;

const int kDNSServiceType_SINK = 40;

const int kDNSServiceType_OPT = 41;

const int kDNSServiceType_APL = 42;

const int kDNSServiceType_DS = 43;

const int kDNSServiceType_SSHFP = 44;

const int kDNSServiceType_IPSECKEY = 45;

const int kDNSServiceType_RRSIG = 46;

const int kDNSServiceType_NSEC = 47;

const int kDNSServiceType_DNSKEY = 48;

const int kDNSServiceType_DHCID = 49;

const int kDNSServiceType_NSEC3 = 50;

const int kDNSServiceType_NSEC3PARAM = 51;

const int kDNSServiceType_HIP = 55;

const int kDNSServiceType_SVCB = 64;

const int kDNSServiceType_HTTPS = 65;

const int kDNSServiceType_SPF = 99;

const int kDNSServiceType_UINFO = 100;

const int kDNSServiceType_UID = 101;

const int kDNSServiceType_GID = 102;

const int kDNSServiceType_UNSPEC = 103;

const int kDNSServiceType_TKEY = 249;

const int kDNSServiceType_TSIG = 250;

const int kDNSServiceType_IXFR = 251;

const int kDNSServiceType_AXFR = 252;

const int kDNSServiceType_MAILB = 253;

const int kDNSServiceType_MAILA = 254;

const int kDNSServiceType_ANY = 255;

const int kDNSServiceErr_NoError = 0;

const int kDNSServiceErr_Unknown = -65537;

const int kDNSServiceErr_NoSuchName = -65538;

const int kDNSServiceErr_NoMemory = -65539;

const int kDNSServiceErr_BadParam = -65540;

const int kDNSServiceErr_BadReference = -65541;

const int kDNSServiceErr_BadState = -65542;

const int kDNSServiceErr_BadFlags = -65543;

const int kDNSServiceErr_Unsupported = -65544;

const int kDNSServiceErr_NotInitialized = -65545;

const int kDNSServiceErr_AlreadyRegistered = -65547;

const int kDNSServiceErr_NameConflict = -65548;

const int kDNSServiceErr_Invalid = -65549;

const int kDNSServiceErr_Firewall = -65550;

const int kDNSServiceErr_Incompatible = -65551;

const int kDNSServiceErr_BadInterfaceIndex = -65552;

const int kDNSServiceErr_Refused = -65553;

const int kDNSServiceErr_NoSuchRecord = -65554;

const int kDNSServiceErr_NoAuth = -65555;

const int kDNSServiceErr_NoSuchKey = -65556;

const int kDNSServiceErr_NATTraversal = -65557;

const int kDNSServiceErr_DoubleNAT = -65558;

const int kDNSServiceErr_BadTime = -65559;

const int kDNSServiceErr_BadSig = -65560;

const int kDNSServiceErr_BadKey = -65561;

const int kDNSServiceErr_Transient = -65562;

const int kDNSServiceErr_ServiceNotRunning = -65563;

const int kDNSServiceErr_NATPortMappingUnsupported = -65564;

const int kDNSServiceErr_NATPortMappingDisabled = -65565;

const int kDNSServiceErr_NoRouter = -65566;

const int kDNSServiceErr_PollingMode = -65567;

const int kDNSServiceErr_Timeout = -65568;

const int kDNSServiceErr_DefunctConnection = -65569;

const int kDNSServiceErr_PolicyDenied = -65570;

const int kDNSServiceErr_NotPermitted = -65571;
