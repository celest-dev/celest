// ignore_for_file: type=lint
// ignore_for_file: return_of_invalid_type, unnecessary_non_null_assertion

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart' as pkg_ffi;

/// Bindings for the Bonjour/DNS-SD (Service Discovery) framework on iOS & macOS.
///
/// Regenerate bindings with `dart run ffigen --config=ffigen.darwin.yaml`.
///
class BonjourFramework {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  BonjourFramework(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  BonjourFramework.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ObjCSel> _registerName1(String name) {
    final cstr = name.toNativeUtf8();
    final sel = _sel_registerName(cstr.cast());
    pkg_ffi.calloc.free(cstr);
    return sel;
  }

  ffi.Pointer<ObjCSel> _sel_registerName(
    ffi.Pointer<ffi.Char> str,
  ) {
    return __sel_registerName(
      str,
    );
  }

  late final __sel_registerNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCSel> Function(
              ffi.Pointer<ffi.Char>)>>('sel_registerName');
  late final __sel_registerName = __sel_registerNamePtr
      .asFunction<ffi.Pointer<ObjCSel> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ObjCObject> _getClass1(String name) {
    final cstr = name.toNativeUtf8();
    final clazz = _objc_getClass(cstr.cast());
    pkg_ffi.calloc.free(cstr);
    if (clazz == ffi.nullptr) {
      throw Exception('Failed to load Objective-C class: $name');
    }
    return clazz;
  }

  ffi.Pointer<ObjCObject> _objc_getClass(
    ffi.Pointer<ffi.Char> str,
  ) {
    return __objc_getClass(
      str,
    );
  }

  late final __objc_getClassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ffi.Char>)>>('objc_getClass');
  late final __objc_getClass = __objc_getClassPtr
      .asFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ObjCObject> _objc_retain(
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_retain(
      value,
    );
  }

  late final __objc_retainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>)>>('objc_retain');
  late final __objc_retain = __objc_retainPtr
      .asFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>)>();

  void _objc_release(
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_release(
      value,
    );
  }

  late final __objc_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ObjCObject>)>>(
          'objc_release');
  late final __objc_release =
      __objc_releasePtr.asFunction<void Function(ffi.Pointer<ObjCObject>)>();

  late final _objc_releaseFinalizer2 =
      ffi.NativeFinalizer(__objc_releasePtr.cast());
  late final _class_NSObject1 = _getClass1("NSObject");
  late final _sel_load1 = _registerName1("load");
  void _objc_msgSend_1(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_1(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_1 = __objc_msgSend_1Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_initialize1 = _registerName1("initialize");
  late final _sel_init1 = _registerName1("init");
  instancetype _objc_msgSend_2(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_2(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_2Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_2 = __objc_msgSend_2Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_new1 = _registerName1("new");
  late final _sel_allocWithZone_1 = _registerName1("allocWithZone:");
  instancetype _objc_msgSend_3(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_NSZone> zone,
  ) {
    return __objc_msgSend_3(
      obj,
      sel,
      zone,
    );
  }

  late final __objc_msgSend_3Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_NSZone>)>>('objc_msgSend');
  late final __objc_msgSend_3 = __objc_msgSend_3Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_NSZone>)>();

  late final _sel_alloc1 = _registerName1("alloc");
  late final _sel_dealloc1 = _registerName1("dealloc");
  late final _sel_finalize1 = _registerName1("finalize");
  late final _sel_copy1 = _registerName1("copy");
  late final _sel_mutableCopy1 = _registerName1("mutableCopy");
  late final _sel_copyWithZone_1 = _registerName1("copyWithZone:");
  late final _sel_mutableCopyWithZone_1 =
      _registerName1("mutableCopyWithZone:");
  late final _sel_instancesRespondToSelector_1 =
      _registerName1("instancesRespondToSelector:");
  bool _objc_msgSend_4(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_4(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_4 = __objc_msgSend_4Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  bool _objc_msgSend_0(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> clazz,
  ) {
    return __objc_msgSend_0(
      obj,
      sel,
      clazz,
    );
  }

  late final __objc_msgSend_0Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_0 = __objc_msgSend_0Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_isKindOfClass_1 = _registerName1("isKindOfClass:");
  late final _class_Protocol1 = _getClass1("Protocol");
  late final _sel_conformsToProtocol_1 = _registerName1("conformsToProtocol:");
  bool _objc_msgSend_5(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> protocol,
  ) {
    return __objc_msgSend_5(
      obj,
      sel,
      protocol,
    );
  }

  late final __objc_msgSend_5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_5 = __objc_msgSend_5Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_methodForSelector_1 = _registerName1("methodForSelector:");
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _objc_msgSend_6(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_6(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_6Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_6 = __objc_msgSend_6Ptr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _sel_instanceMethodForSelector_1 =
      _registerName1("instanceMethodForSelector:");
  late final _sel_doesNotRecognizeSelector_1 =
      _registerName1("doesNotRecognizeSelector:");
  void _objc_msgSend_7(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_7(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_7 = __objc_msgSend_7Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _sel_forwardingTargetForSelector_1 =
      _registerName1("forwardingTargetForSelector:");
  ffi.Pointer<ObjCObject> _objc_msgSend_8(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_8(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_8 = __objc_msgSend_8Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>();

  late final _class_NSInvocation1 = _getClass1("NSInvocation");
  late final _sel_forwardInvocation_1 = _registerName1("forwardInvocation:");
  void _objc_msgSend_9(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anInvocation,
  ) {
    return __objc_msgSend_9(
      obj,
      sel,
      anInvocation,
    );
  }

  late final __objc_msgSend_9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_9 = __objc_msgSend_9Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _class_NSMethodSignature1 = _getClass1("NSMethodSignature");
  late final _sel_methodSignatureForSelector_1 =
      _registerName1("methodSignatureForSelector:");
  ffi.Pointer<ObjCObject> _objc_msgSend_10(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_10(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_10 = __objc_msgSend_10Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>();

  late final _sel_instanceMethodSignatureForSelector_1 =
      _registerName1("instanceMethodSignatureForSelector:");
  late final _sel_allowsWeakReference1 = _registerName1("allowsWeakReference");
  bool _objc_msgSend_11(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_11(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_11 = __objc_msgSend_11Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_retainWeakReference1 = _registerName1("retainWeakReference");
  late final _sel_isSubclassOfClass_1 = _registerName1("isSubclassOfClass:");
  late final _sel_resolveClassMethod_1 = _registerName1("resolveClassMethod:");
  late final _sel_resolveInstanceMethod_1 =
      _registerName1("resolveInstanceMethod:");
  late final _sel_hash1 = _registerName1("hash");
  int _objc_msgSend_12(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_12(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_12 = __objc_msgSend_12Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_superclass1 = _registerName1("superclass");
  late final _sel_class1 = _registerName1("class");
  late final _class_NSString1 = _getClass1("NSString");
  late final _sel_stringWithCharacters_length_1 =
      _registerName1("stringWithCharacters:length:");
  ffi.Pointer<ObjCObject> _objc_msgSend_13(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.WChar> characters,
    int length,
  ) {
    return __objc_msgSend_13(
      obj,
      sel,
      characters,
      length,
    );
  }

  late final __objc_msgSend_13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.WChar>,
              ffi.UnsignedInt)>>('objc_msgSend');
  late final __objc_msgSend_13 = __objc_msgSend_13Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ffi.WChar>, int)>();

  late final _class_NSData1 = _getClass1("NSData");
  late final _sel_bytes1 = _registerName1("bytes");
  ffi.Pointer<ffi.Void> _objc_msgSend_14(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_14(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_14 = __objc_msgSend_14Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_dataUsingEncoding_1 = _registerName1("dataUsingEncoding:");
  ffi.Pointer<ObjCObject> _objc_msgSend_15(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int encoding,
  ) {
    return __objc_msgSend_15(
      obj,
      sel,
      encoding,
    );
  }

  late final __objc_msgSend_15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedInt)>>('objc_msgSend');
  late final __objc_msgSend_15 = __objc_msgSend_15Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_length1 = _registerName1("length");
  int _objc_msgSend_16(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_16(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_16 = __objc_msgSend_16Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_description1 = _registerName1("description");
  ffi.Pointer<ObjCObject> _objc_msgSend_17(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_17(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_17 = __objc_msgSend_17Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_debugDescription1 = _registerName1("debugDescription");
  int dispatch_time(
    int when,
    int delta,
  ) {
    return _dispatch_time(
      when,
      delta,
    );
  }

  late final _dispatch_timePtr = _lookup<
      ffi.NativeFunction<
          dispatch_time_t Function(
              dispatch_time_t, ffi.Int64)>>('dispatch_time');
  late final _dispatch_time =
      _dispatch_timePtr.asFunction<int Function(int, int)>();

  int dispatch_walltime(
    ffi.Pointer<timespec> when,
    int delta,
  ) {
    return _dispatch_walltime(
      when,
      delta,
    );
  }

  late final _dispatch_walltimePtr = _lookup<
      ffi.NativeFunction<
          dispatch_time_t Function(
              ffi.Pointer<timespec>, ffi.Int64)>>('dispatch_walltime');
  late final _dispatch_walltime = _dispatch_walltimePtr
      .asFunction<int Function(ffi.Pointer<timespec>, int)>();

  void dispatch_retain(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_retain(
      object._id,
    );
  }

  late final _dispatch_retainPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_object_t)>>(
          'dispatch_retain');
  late final _dispatch_retain =
      _dispatch_retainPtr.asFunction<void Function(dispatch_object_t)>();

  void dispatch_release(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_release(
      object._id,
    );
  }

  late final _dispatch_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_object_t)>>(
          'dispatch_release');
  late final _dispatch_release =
      _dispatch_releasePtr.asFunction<void Function(dispatch_object_t)>();

  ffi.Pointer<ffi.Void> dispatch_get_context(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_get_context(
      object._id,
    );
  }

  late final _dispatch_get_contextPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ffi.Void> Function(dispatch_object_t)>>(
      'dispatch_get_context');
  late final _dispatch_get_context = _dispatch_get_contextPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(dispatch_object_t)>();

  void dispatch_set_context(
    Dartdispatch_object_t object,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _dispatch_set_context(
      object._id,
      context,
    );
  }

  late final _dispatch_set_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_object_t,
              ffi.Pointer<ffi.Void>)>>('dispatch_set_context');
  late final _dispatch_set_context = _dispatch_set_contextPtr
      .asFunction<void Function(dispatch_object_t, ffi.Pointer<ffi.Void>)>();

  void dispatch_set_finalizer_f(
    Dartdispatch_object_t object,
    dispatch_function_t finalizer,
  ) {
    return _dispatch_set_finalizer_f(
      object._id,
      finalizer,
    );
  }

  late final _dispatch_set_finalizer_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_object_t,
              dispatch_function_t)>>('dispatch_set_finalizer_f');
  late final _dispatch_set_finalizer_f = _dispatch_set_finalizer_fPtr
      .asFunction<void Function(dispatch_object_t, dispatch_function_t)>();

  void dispatch_activate(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_activate(
      object._id,
    );
  }

  late final _dispatch_activatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_object_t)>>(
          'dispatch_activate');
  late final _dispatch_activate =
      _dispatch_activatePtr.asFunction<void Function(dispatch_object_t)>();

  void dispatch_suspend(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_suspend(
      object._id,
    );
  }

  late final _dispatch_suspendPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_object_t)>>(
          'dispatch_suspend');
  late final _dispatch_suspend =
      _dispatch_suspendPtr.asFunction<void Function(dispatch_object_t)>();

  void dispatch_resume(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_resume(
      object._id,
    );
  }

  late final _dispatch_resumePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_object_t)>>(
          'dispatch_resume');
  late final _dispatch_resume =
      _dispatch_resumePtr.asFunction<void Function(dispatch_object_t)>();

  void dispatch_set_qos_class_floor(
    Dartdispatch_object_t object,
    int qos_class,
    int relative_priority,
  ) {
    return _dispatch_set_qos_class_floor(
      object._id,
      qos_class,
      relative_priority,
    );
  }

  late final _dispatch_set_qos_class_floorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_object_t, ffi.Int32,
              ffi.Int)>>('dispatch_set_qos_class_floor');
  late final _dispatch_set_qos_class_floor = _dispatch_set_qos_class_floorPtr
      .asFunction<void Function(dispatch_object_t, int, int)>();

  int dispatch_wait(
    ffi.Pointer<ffi.Void> object,
    int timeout,
  ) {
    return _dispatch_wait(
      object,
      timeout,
    );
  }

  late final _dispatch_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Void>, dispatch_time_t)>>('dispatch_wait');
  late final _dispatch_wait =
      _dispatch_waitPtr.asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  void dispatch_notify(
    ffi.Pointer<ffi.Void> object,
    Dartdispatch_object_t queue,
    Dartdispatch_block_t notification_block,
  ) {
    return _dispatch_notify(
      object,
      queue._id,
      notification_block._id,
    );
  }

  late final _dispatch_notifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, dispatch_object_t,
              dispatch_block_t)>>('dispatch_notify');
  late final _dispatch_notify = _dispatch_notifyPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>, dispatch_object_t, dispatch_block_t)>();

  ffi.Pointer<_ObjCBlockDesc> _newBlockDesc1() {
    final d =
        pkg_ffi.calloc.allocate<_ObjCBlockDesc>(ffi.sizeOf<_ObjCBlockDesc>());
    d.ref.reserved = 0;
    d.ref.size = ffi.sizeOf<_ObjCBlock>();
    d.ref.copy_helper = ffi.nullptr;
    d.ref.dispose_helper = ffi.nullptr;
    d.ref.signature = ffi.nullptr;
    return d;
  }

  late final _objc_block_desc1 = _newBlockDesc1();
  late final _objc_concrete_global_block1 =
      _lookup<ffi.Void>('_NSConcreteGlobalBlock');
  ffi.Pointer<_ObjCBlock> _newBlock1(
      ffi.Pointer<ffi.Void> invoke, ffi.Pointer<ffi.Void> target) {
    final b = pkg_ffi.calloc.allocate<_ObjCBlock>(ffi.sizeOf<_ObjCBlock>());
    b.ref.isa = _objc_concrete_global_block1;
    b.ref.flags = 0;
    b.ref.reserved = 0;
    b.ref.invoke = invoke;
    b.ref.target = target;
    b.ref.descriptor = _objc_block_desc1;
    final copy = _Block_copy(b.cast()).cast<_ObjCBlock>();
    pkg_ffi.calloc.free(b);
    return copy;
  }

  ffi.Pointer<ffi.Void> _Block_copy(
    ffi.Pointer<ffi.Void> value,
  ) {
    return __Block_copy(
      value,
    );
  }

  late final __Block_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>)>>('_Block_copy');
  late final __Block_copy = __Block_copyPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  void _Block_release(
    ffi.Pointer<ffi.Void> value,
  ) {
    return __Block_release(
      value,
    );
  }

  late final __Block_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          '_Block_release');
  late final __Block_release =
      __Block_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  late final _objc_releaseFinalizer11 =
      ffi.NativeFinalizer(__Block_releasePtr.cast());
  void dispatch_cancel(
    ffi.Pointer<ffi.Void> object,
  ) {
    return _dispatch_cancel(
      object,
    );
  }

  late final _dispatch_cancelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'dispatch_cancel');
  late final _dispatch_cancel =
      _dispatch_cancelPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  int dispatch_testcancel(
    ffi.Pointer<ffi.Void> object,
  ) {
    return _dispatch_testcancel(
      object,
    );
  }

  late final _dispatch_testcancelPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(ffi.Pointer<ffi.Void>)>>(
          'dispatch_testcancel');
  late final _dispatch_testcancel =
      _dispatch_testcancelPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  void dispatch_debug(
    Dartdispatch_object_t object,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _dispatch_debug(
      object._id,
      message,
    );
  }

  late final _dispatch_debugPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_object_t, ffi.Pointer<ffi.Char>)>>('dispatch_debug');
  late final _dispatch_debug = _dispatch_debugPtr
      .asFunction<void Function(dispatch_object_t, ffi.Pointer<ffi.Char>)>();

  void dispatch_debugv(
    Dartdispatch_object_t object,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<ffi.Char> ap,
  ) {
    return _dispatch_debugv(
      object._id,
      message,
      ap,
    );
  }

  late final _dispatch_debugvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_object_t, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('dispatch_debugv');
  late final _dispatch_debugv = _dispatch_debugvPtr.asFunction<
      void Function(
          dispatch_object_t, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  void dispatch_async(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_async(
      queue._id,
      block._id,
    );
  }

  late final _dispatch_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t, dispatch_block_t)>>('dispatch_async');
  late final _dispatch_async = _dispatch_asyncPtr
      .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_async_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_async_f(
      queue._id,
      context,
      work,
    );
  }

  late final _dispatch_async_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_async_f');
  late final _dispatch_async_f = _dispatch_async_fPtr.asFunction<
      void Function(
          dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_sync(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_sync(
      queue._id,
      block._id,
    );
  }

  late final _dispatch_syncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t, dispatch_block_t)>>('dispatch_sync');
  late final _dispatch_sync = _dispatch_syncPtr
      .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_sync_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_sync_f(
      queue._id,
      context,
      work,
    );
  }

  late final _dispatch_sync_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_sync_f');
  late final _dispatch_sync_f = _dispatch_sync_fPtr.asFunction<
      void Function(
          dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_async_and_wait(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_async_and_wait(
      queue._id,
      block._id,
    );
  }

  late final _dispatch_async_and_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t, dispatch_block_t)>>('dispatch_async_and_wait');
  late final _dispatch_async_and_wait = _dispatch_async_and_waitPtr
      .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_async_and_wait_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_async_and_wait_f(
      queue._id,
      context,
      work,
    );
  }

  late final _dispatch_async_and_wait_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_async_and_wait_f');
  late final _dispatch_async_and_wait_f =
      _dispatch_async_and_wait_fPtr.asFunction<
          void Function(
              dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_apply(
    int iterations,
    Dartdispatch_queue_t queue,
    ObjCBlock_ffiVoid_ffiSize block,
  ) {
    return _dispatch_apply(
      iterations,
      queue._id,
      block._id,
    );
  }

  late final _dispatch_applyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Size, dispatch_queue_t,
              ffi.Pointer<_ObjCBlock>)>>('dispatch_apply');
  late final _dispatch_apply = _dispatch_applyPtr.asFunction<
      void Function(int, dispatch_queue_t, ffi.Pointer<_ObjCBlock>)>();

  void dispatch_apply_f(
    int iterations,
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> context, ffi.Size iteration)>>
        work,
  ) {
    return _dispatch_apply_f(
      iterations,
      queue._id,
      context,
      work,
    );
  }

  late final _dispatch_apply_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Size,
              dispatch_queue_t,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> context,
                          ffi.Size iteration)>>)>>('dispatch_apply_f');
  late final _dispatch_apply_f = _dispatch_apply_fPtr.asFunction<
      void Function(
          int,
          dispatch_queue_t,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> context, ffi.Size iteration)>>)>();

  Dartdispatch_queue_t dispatch_get_current_queue() {
    return NSObject._(_dispatch_get_current_queue(), this,
        retain: true, release: true);
  }

  late final _dispatch_get_current_queuePtr =
      _lookup<ffi.NativeFunction<dispatch_queue_t Function()>>(
          'dispatch_get_current_queue');
  late final _dispatch_get_current_queue =
      _dispatch_get_current_queuePtr.asFunction<dispatch_queue_t Function()>();

  Dartdispatch_queue_global_t dispatch_get_global_queue(
    int identifier,
    int flags,
  ) {
    return NSObject._(
        _dispatch_get_global_queue(
          identifier,
          flags,
        ),
        this,
        retain: true,
        release: true);
  }

  late final _dispatch_get_global_queuePtr = _lookup<
      ffi.NativeFunction<
          dispatch_queue_global_t Function(
              ffi.IntPtr, ffi.UintPtr)>>('dispatch_get_global_queue');
  late final _dispatch_get_global_queue = _dispatch_get_global_queuePtr
      .asFunction<dispatch_queue_global_t Function(int, int)>();

  Dartdispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(
    Dartdispatch_queue_attr_t attr,
  ) {
    return NSObject._(
        _dispatch_queue_attr_make_initially_inactive(
          attr._id,
        ),
        this,
        retain: true,
        release: true);
  }

  late final _dispatch_queue_attr_make_initially_inactivePtr = _lookup<
          ffi.NativeFunction<
              dispatch_queue_attr_t Function(dispatch_queue_attr_t)>>(
      'dispatch_queue_attr_make_initially_inactive');
  late final _dispatch_queue_attr_make_initially_inactive =
      _dispatch_queue_attr_make_initially_inactivePtr
          .asFunction<dispatch_queue_attr_t Function(dispatch_queue_attr_t)>();

  Dartdispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(
    Dartdispatch_queue_attr_t attr,
    int frequency,
  ) {
    return NSObject._(
        _dispatch_queue_attr_make_with_autorelease_frequency(
          attr._id,
          frequency,
        ),
        this,
        retain: true,
        release: true);
  }

  late final _dispatch_queue_attr_make_with_autorelease_frequencyPtr = _lookup<
          ffi.NativeFunction<
              dispatch_queue_attr_t Function(
                  dispatch_queue_attr_t, ffi.Int32)>>(
      'dispatch_queue_attr_make_with_autorelease_frequency');
  late final _dispatch_queue_attr_make_with_autorelease_frequency =
      _dispatch_queue_attr_make_with_autorelease_frequencyPtr.asFunction<
          dispatch_queue_attr_t Function(dispatch_queue_attr_t, int)>();

  Dartdispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(
    Dartdispatch_queue_attr_t attr,
    int qos_class,
    int relative_priority,
  ) {
    return NSObject._(
        _dispatch_queue_attr_make_with_qos_class(
          attr._id,
          qos_class,
          relative_priority,
        ),
        this,
        retain: true,
        release: true);
  }

  late final _dispatch_queue_attr_make_with_qos_classPtr = _lookup<
      ffi.NativeFunction<
          dispatch_queue_attr_t Function(dispatch_queue_attr_t, ffi.Int32,
              ffi.Int)>>('dispatch_queue_attr_make_with_qos_class');
  late final _dispatch_queue_attr_make_with_qos_class =
      _dispatch_queue_attr_make_with_qos_classPtr.asFunction<
          dispatch_queue_attr_t Function(dispatch_queue_attr_t, int, int)>();

  Dartdispatch_queue_t dispatch_queue_create_with_target(
    ffi.Pointer<ffi.Char> label,
    Dartdispatch_queue_attr_t attr,
    Dartdispatch_queue_t target,
  ) {
    return NSObject._(
        _dispatch_queue_create_with_target(
          label,
          attr._id,
          target._id,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_queue_create_with_targetPtr = _lookup<
      ffi.NativeFunction<
          dispatch_queue_t Function(
              ffi.Pointer<ffi.Char>,
              dispatch_queue_attr_t,
              dispatch_queue_t)>>('dispatch_queue_create_with_target');
  late final _dispatch_queue_create_with_target =
      _dispatch_queue_create_with_targetPtr.asFunction<
          dispatch_queue_t Function(ffi.Pointer<ffi.Char>,
              dispatch_queue_attr_t, dispatch_queue_t)>();

  Dartdispatch_queue_t dispatch_queue_create(
    ffi.Pointer<ffi.Char> label,
    Dartdispatch_queue_attr_t attr,
  ) {
    return NSObject._(
        _dispatch_queue_create(
          label,
          attr._id,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_queue_createPtr = _lookup<
      ffi.NativeFunction<
          dispatch_queue_t Function(ffi.Pointer<ffi.Char>,
              dispatch_queue_attr_t)>>('dispatch_queue_create');
  late final _dispatch_queue_create = _dispatch_queue_createPtr.asFunction<
      dispatch_queue_t Function(
          ffi.Pointer<ffi.Char>, dispatch_queue_attr_t)>();

  ffi.Pointer<ffi.Char> dispatch_queue_get_label(
    Dartdispatch_queue_t queue,
  ) {
    return _dispatch_queue_get_label(
      queue._id,
    );
  }

  late final _dispatch_queue_get_labelPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(dispatch_queue_t)>>(
      'dispatch_queue_get_label');
  late final _dispatch_queue_get_label = _dispatch_queue_get_labelPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(dispatch_queue_t)>();

  int dispatch_queue_get_qos_class(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Int> relative_priority_ptr,
  ) {
    return _dispatch_queue_get_qos_class(
      queue._id,
      relative_priority_ptr,
    );
  }

  late final _dispatch_queue_get_qos_classPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(dispatch_queue_t,
              ffi.Pointer<ffi.Int>)>>('dispatch_queue_get_qos_class');
  late final _dispatch_queue_get_qos_class = _dispatch_queue_get_qos_classPtr
      .asFunction<int Function(dispatch_queue_t, ffi.Pointer<ffi.Int>)>();

  void dispatch_set_target_queue(
    Dartdispatch_object_t object,
    Dartdispatch_queue_t queue,
  ) {
    return _dispatch_set_target_queue(
      object._id,
      queue._id,
    );
  }

  late final _dispatch_set_target_queuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_object_t,
              dispatch_queue_t)>>('dispatch_set_target_queue');
  late final _dispatch_set_target_queue = _dispatch_set_target_queuePtr
      .asFunction<void Function(dispatch_object_t, dispatch_queue_t)>();

  void dispatch_main() {
    return _dispatch_main();
  }

  late final _dispatch_mainPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('dispatch_main');
  late final _dispatch_main = _dispatch_mainPtr.asFunction<void Function()>();

  void dispatch_after(
    Dartdispatch_time_t when,
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_after(
      when,
      queue._id,
      block._id,
    );
  }

  late final _dispatch_afterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_time_t, dispatch_queue_t,
              dispatch_block_t)>>('dispatch_after');
  late final _dispatch_after = _dispatch_afterPtr
      .asFunction<void Function(int, dispatch_queue_t, dispatch_block_t)>();

  void dispatch_after_f(
    Dartdispatch_time_t when,
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_after_f(
      when,
      queue._id,
      context,
      work,
    );
  }

  late final _dispatch_after_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_time_t, dispatch_queue_t,
              ffi.Pointer<ffi.Void>, dispatch_function_t)>>('dispatch_after_f');
  late final _dispatch_after_f = _dispatch_after_fPtr.asFunction<
      void Function(
          int, dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_barrier_async(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_barrier_async(
      queue._id,
      block._id,
    );
  }

  late final _dispatch_barrier_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t, dispatch_block_t)>>('dispatch_barrier_async');
  late final _dispatch_barrier_async = _dispatch_barrier_asyncPtr
      .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_barrier_async_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_barrier_async_f(
      queue._id,
      context,
      work,
    );
  }

  late final _dispatch_barrier_async_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_barrier_async_f');
  late final _dispatch_barrier_async_f =
      _dispatch_barrier_async_fPtr.asFunction<
          void Function(
              dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_barrier_sync(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_barrier_sync(
      queue._id,
      block._id,
    );
  }

  late final _dispatch_barrier_syncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t, dispatch_block_t)>>('dispatch_barrier_sync');
  late final _dispatch_barrier_sync = _dispatch_barrier_syncPtr
      .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_barrier_sync_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_barrier_sync_f(
      queue._id,
      context,
      work,
    );
  }

  late final _dispatch_barrier_sync_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_barrier_sync_f');
  late final _dispatch_barrier_sync_f = _dispatch_barrier_sync_fPtr.asFunction<
      void Function(
          dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_barrier_async_and_wait(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_barrier_async_and_wait(
      queue._id,
      block._id,
    );
  }

  late final _dispatch_barrier_async_and_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t,
              dispatch_block_t)>>('dispatch_barrier_async_and_wait');
  late final _dispatch_barrier_async_and_wait =
      _dispatch_barrier_async_and_waitPtr
          .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_barrier_async_and_wait_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_barrier_async_and_wait_f(
      queue._id,
      context,
      work,
    );
  }

  late final _dispatch_barrier_async_and_wait_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_barrier_async_and_wait_f');
  late final _dispatch_barrier_async_and_wait_f =
      _dispatch_barrier_async_and_wait_fPtr.asFunction<
          void Function(
              dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_queue_set_specific(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t destructor,
  ) {
    return _dispatch_queue_set_specific(
      queue._id,
      key,
      context,
      destructor,
    );
  }

  late final _dispatch_queue_set_specificPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_queue_set_specific');
  late final _dispatch_queue_set_specific =
      _dispatch_queue_set_specificPtr.asFunction<
          void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  ffi.Pointer<ffi.Void> dispatch_queue_get_specific(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> key,
  ) {
    return _dispatch_queue_get_specific(
      queue._id,
      key,
    );
  }

  late final _dispatch_queue_get_specificPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(dispatch_queue_t,
              ffi.Pointer<ffi.Void>)>>('dispatch_queue_get_specific');
  late final _dispatch_queue_get_specific =
      _dispatch_queue_get_specificPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              dispatch_queue_t, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> dispatch_get_specific(
    ffi.Pointer<ffi.Void> key,
  ) {
    return _dispatch_get_specific(
      key,
    );
  }

  late final _dispatch_get_specificPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>)>>('dispatch_get_specific');
  late final _dispatch_get_specific = _dispatch_get_specificPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  void dispatch_assert_queue(
    Dartdispatch_queue_t queue,
  ) {
    return _dispatch_assert_queue(
      queue._id,
    );
  }

  late final _dispatch_assert_queuePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_queue_t)>>(
          'dispatch_assert_queue');
  late final _dispatch_assert_queue =
      _dispatch_assert_queuePtr.asFunction<void Function(dispatch_queue_t)>();

  void dispatch_assert_queue_barrier(
    Dartdispatch_queue_t queue,
  ) {
    return _dispatch_assert_queue_barrier(
      queue._id,
    );
  }

  late final _dispatch_assert_queue_barrierPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_queue_t)>>(
          'dispatch_assert_queue_barrier');
  late final _dispatch_assert_queue_barrier = _dispatch_assert_queue_barrierPtr
      .asFunction<void Function(dispatch_queue_t)>();

  void dispatch_assert_queue_not(
    Dartdispatch_queue_t queue,
  ) {
    return _dispatch_assert_queue_not(
      queue._id,
    );
  }

  late final _dispatch_assert_queue_notPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_queue_t)>>(
          'dispatch_assert_queue_not');
  late final _dispatch_assert_queue_not = _dispatch_assert_queue_notPtr
      .asFunction<void Function(dispatch_queue_t)>();

  Dartdispatch_block_t dispatch_block_create(
    int flags,
    Dartdispatch_block_t block,
  ) {
    return ObjCBlock_ffiVoid._(
        _dispatch_block_create(
          flags,
          block._id,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_block_createPtr = _lookup<
      ffi.NativeFunction<
          dispatch_block_t Function(
              ffi.Int32, dispatch_block_t)>>('dispatch_block_create');
  late final _dispatch_block_create = _dispatch_block_createPtr
      .asFunction<dispatch_block_t Function(int, dispatch_block_t)>();

  Dartdispatch_block_t dispatch_block_create_with_qos_class(
    int flags,
    int qos_class,
    int relative_priority,
    Dartdispatch_block_t block,
  ) {
    return ObjCBlock_ffiVoid._(
        _dispatch_block_create_with_qos_class(
          flags,
          qos_class,
          relative_priority,
          block._id,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_block_create_with_qos_classPtr = _lookup<
      ffi.NativeFunction<
          dispatch_block_t Function(ffi.Int32, ffi.Int32, ffi.Int,
              dispatch_block_t)>>('dispatch_block_create_with_qos_class');
  late final _dispatch_block_create_with_qos_class =
      _dispatch_block_create_with_qos_classPtr.asFunction<
          dispatch_block_t Function(int, int, int, dispatch_block_t)>();

  void dispatch_block_perform(
    int flags,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_block_perform(
      flags,
      block._id,
    );
  }

  late final _dispatch_block_performPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Int32, dispatch_block_t)>>(
      'dispatch_block_perform');
  late final _dispatch_block_perform = _dispatch_block_performPtr
      .asFunction<void Function(int, dispatch_block_t)>();

  int dispatch_block_wait(
    Dartdispatch_block_t block,
    Dartdispatch_time_t timeout,
  ) {
    return _dispatch_block_wait(
      block._id,
      timeout,
    );
  }

  late final _dispatch_block_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              dispatch_block_t, dispatch_time_t)>>('dispatch_block_wait');
  late final _dispatch_block_wait =
      _dispatch_block_waitPtr.asFunction<int Function(dispatch_block_t, int)>();

  void dispatch_block_notify(
    Dartdispatch_block_t block,
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t notification_block,
  ) {
    return _dispatch_block_notify(
      block._id,
      queue._id,
      notification_block._id,
    );
  }

  late final _dispatch_block_notifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_block_t, dispatch_queue_t,
              dispatch_block_t)>>('dispatch_block_notify');
  late final _dispatch_block_notify = _dispatch_block_notifyPtr.asFunction<
      void Function(dispatch_block_t, dispatch_queue_t, dispatch_block_t)>();

  void dispatch_block_cancel(
    Dartdispatch_block_t block,
  ) {
    return _dispatch_block_cancel(
      block._id,
    );
  }

  late final _dispatch_block_cancelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_block_t)>>(
          'dispatch_block_cancel');
  late final _dispatch_block_cancel =
      _dispatch_block_cancelPtr.asFunction<void Function(dispatch_block_t)>();

  int dispatch_block_testcancel(
    Dartdispatch_block_t block,
  ) {
    return _dispatch_block_testcancel(
      block._id,
    );
  }

  late final _dispatch_block_testcancelPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(dispatch_block_t)>>(
          'dispatch_block_testcancel');
  late final _dispatch_block_testcancel = _dispatch_block_testcancelPtr
      .asFunction<int Function(dispatch_block_t)>();

  Dartdispatch_source_t dispatch_source_create(
    dispatch_source_type_t type,
    int handle,
    int mask,
    Dartdispatch_queue_t queue,
  ) {
    return NSObject._(
        _dispatch_source_create(
          type,
          handle,
          mask,
          queue._id,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_source_createPtr = _lookup<
      ffi.NativeFunction<
          dispatch_source_t Function(dispatch_source_type_t, ffi.UintPtr,
              ffi.UintPtr, dispatch_queue_t)>>('dispatch_source_create');
  late final _dispatch_source_create = _dispatch_source_createPtr.asFunction<
      dispatch_source_t Function(
          dispatch_source_type_t, int, int, dispatch_queue_t)>();

  void dispatch_source_set_event_handler(
    Dartdispatch_source_t source,
    Dartdispatch_block_t handler,
  ) {
    return _dispatch_source_set_event_handler(
      source._id,
      handler._id,
    );
  }

  late final _dispatch_source_set_event_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t,
              dispatch_block_t)>>('dispatch_source_set_event_handler');
  late final _dispatch_source_set_event_handler =
      _dispatch_source_set_event_handlerPtr
          .asFunction<void Function(dispatch_source_t, dispatch_block_t)>();

  void dispatch_source_set_event_handler_f(
    Dartdispatch_source_t source,
    dispatch_function_t handler,
  ) {
    return _dispatch_source_set_event_handler_f(
      source._id,
      handler,
    );
  }

  late final _dispatch_source_set_event_handler_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t,
              dispatch_function_t)>>('dispatch_source_set_event_handler_f');
  late final _dispatch_source_set_event_handler_f =
      _dispatch_source_set_event_handler_fPtr
          .asFunction<void Function(dispatch_source_t, dispatch_function_t)>();

  void dispatch_source_set_cancel_handler(
    Dartdispatch_source_t source,
    Dartdispatch_block_t handler,
  ) {
    return _dispatch_source_set_cancel_handler(
      source._id,
      handler._id,
    );
  }

  late final _dispatch_source_set_cancel_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t,
              dispatch_block_t)>>('dispatch_source_set_cancel_handler');
  late final _dispatch_source_set_cancel_handler =
      _dispatch_source_set_cancel_handlerPtr
          .asFunction<void Function(dispatch_source_t, dispatch_block_t)>();

  void dispatch_source_set_cancel_handler_f(
    Dartdispatch_source_t source,
    dispatch_function_t handler,
  ) {
    return _dispatch_source_set_cancel_handler_f(
      source._id,
      handler,
    );
  }

  late final _dispatch_source_set_cancel_handler_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t,
              dispatch_function_t)>>('dispatch_source_set_cancel_handler_f');
  late final _dispatch_source_set_cancel_handler_f =
      _dispatch_source_set_cancel_handler_fPtr
          .asFunction<void Function(dispatch_source_t, dispatch_function_t)>();

  void dispatch_source_cancel(
    Dartdispatch_source_t source,
  ) {
    return _dispatch_source_cancel(
      source._id,
    );
  }

  late final _dispatch_source_cancelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_source_t)>>(
          'dispatch_source_cancel');
  late final _dispatch_source_cancel =
      _dispatch_source_cancelPtr.asFunction<void Function(dispatch_source_t)>();

  int dispatch_source_testcancel(
    Dartdispatch_source_t source,
  ) {
    return _dispatch_source_testcancel(
      source._id,
    );
  }

  late final _dispatch_source_testcancelPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(dispatch_source_t)>>(
          'dispatch_source_testcancel');
  late final _dispatch_source_testcancel = _dispatch_source_testcancelPtr
      .asFunction<int Function(dispatch_source_t)>();

  int dispatch_source_get_handle(
    Dartdispatch_source_t source,
  ) {
    return _dispatch_source_get_handle(
      source._id,
    );
  }

  late final _dispatch_source_get_handlePtr =
      _lookup<ffi.NativeFunction<ffi.UintPtr Function(dispatch_source_t)>>(
          'dispatch_source_get_handle');
  late final _dispatch_source_get_handle = _dispatch_source_get_handlePtr
      .asFunction<int Function(dispatch_source_t)>();

  int dispatch_source_get_mask(
    Dartdispatch_source_t source,
  ) {
    return _dispatch_source_get_mask(
      source._id,
    );
  }

  late final _dispatch_source_get_maskPtr =
      _lookup<ffi.NativeFunction<ffi.UintPtr Function(dispatch_source_t)>>(
          'dispatch_source_get_mask');
  late final _dispatch_source_get_mask = _dispatch_source_get_maskPtr
      .asFunction<int Function(dispatch_source_t)>();

  int dispatch_source_get_data(
    Dartdispatch_source_t source,
  ) {
    return _dispatch_source_get_data(
      source._id,
    );
  }

  late final _dispatch_source_get_dataPtr =
      _lookup<ffi.NativeFunction<ffi.UintPtr Function(dispatch_source_t)>>(
          'dispatch_source_get_data');
  late final _dispatch_source_get_data = _dispatch_source_get_dataPtr
      .asFunction<int Function(dispatch_source_t)>();

  void dispatch_source_merge_data(
    Dartdispatch_source_t source,
    int value,
  ) {
    return _dispatch_source_merge_data(
      source._id,
      value,
    );
  }

  late final _dispatch_source_merge_dataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(dispatch_source_t, ffi.UintPtr)>>(
      'dispatch_source_merge_data');
  late final _dispatch_source_merge_data = _dispatch_source_merge_dataPtr
      .asFunction<void Function(dispatch_source_t, int)>();

  void dispatch_source_set_timer(
    Dartdispatch_source_t source,
    Dartdispatch_time_t start,
    int interval,
    int leeway,
  ) {
    return _dispatch_source_set_timer(
      source._id,
      start,
      interval,
      leeway,
    );
  }

  late final _dispatch_source_set_timerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t, dispatch_time_t, ffi.Uint64,
              ffi.Uint64)>>('dispatch_source_set_timer');
  late final _dispatch_source_set_timer = _dispatch_source_set_timerPtr
      .asFunction<void Function(dispatch_source_t, int, int, int)>();

  void dispatch_source_set_registration_handler(
    Dartdispatch_source_t source,
    Dartdispatch_block_t handler,
  ) {
    return _dispatch_source_set_registration_handler(
      source._id,
      handler._id,
    );
  }

  late final _dispatch_source_set_registration_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t,
              dispatch_block_t)>>('dispatch_source_set_registration_handler');
  late final _dispatch_source_set_registration_handler =
      _dispatch_source_set_registration_handlerPtr
          .asFunction<void Function(dispatch_source_t, dispatch_block_t)>();

  void dispatch_source_set_registration_handler_f(
    Dartdispatch_source_t source,
    dispatch_function_t handler,
  ) {
    return _dispatch_source_set_registration_handler_f(
      source._id,
      handler,
    );
  }

  late final _dispatch_source_set_registration_handler_fPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(dispatch_source_t, dispatch_function_t)>>(
      'dispatch_source_set_registration_handler_f');
  late final _dispatch_source_set_registration_handler_f =
      _dispatch_source_set_registration_handler_fPtr
          .asFunction<void Function(dispatch_source_t, dispatch_function_t)>();

  Dartdispatch_group_t dispatch_group_create() {
    return NSObject._(_dispatch_group_create(), this,
        retain: false, release: true);
  }

  late final _dispatch_group_createPtr =
      _lookup<ffi.NativeFunction<dispatch_group_t Function()>>(
          'dispatch_group_create');
  late final _dispatch_group_create =
      _dispatch_group_createPtr.asFunction<dispatch_group_t Function()>();

  void dispatch_group_async(
    Dartdispatch_group_t group,
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_group_async(
      group._id,
      queue._id,
      block._id,
    );
  }

  late final _dispatch_group_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_group_t, dispatch_queue_t,
              dispatch_block_t)>>('dispatch_group_async');
  late final _dispatch_group_async = _dispatch_group_asyncPtr.asFunction<
      void Function(dispatch_group_t, dispatch_queue_t, dispatch_block_t)>();

  void dispatch_group_async_f(
    Dartdispatch_group_t group,
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_group_async_f(
      group._id,
      queue._id,
      context,
      work,
    );
  }

  late final _dispatch_group_async_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_group_t,
              dispatch_queue_t,
              ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_group_async_f');
  late final _dispatch_group_async_f = _dispatch_group_async_fPtr.asFunction<
      void Function(dispatch_group_t, dispatch_queue_t, ffi.Pointer<ffi.Void>,
          dispatch_function_t)>();

  int dispatch_group_wait(
    Dartdispatch_group_t group,
    Dartdispatch_time_t timeout,
  ) {
    return _dispatch_group_wait(
      group._id,
      timeout,
    );
  }

  late final _dispatch_group_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              dispatch_group_t, dispatch_time_t)>>('dispatch_group_wait');
  late final _dispatch_group_wait =
      _dispatch_group_waitPtr.asFunction<int Function(dispatch_group_t, int)>();

  void dispatch_group_notify(
    Dartdispatch_group_t group,
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_group_notify(
      group._id,
      queue._id,
      block._id,
    );
  }

  late final _dispatch_group_notifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_group_t, dispatch_queue_t,
              dispatch_block_t)>>('dispatch_group_notify');
  late final _dispatch_group_notify = _dispatch_group_notifyPtr.asFunction<
      void Function(dispatch_group_t, dispatch_queue_t, dispatch_block_t)>();

  void dispatch_group_notify_f(
    Dartdispatch_group_t group,
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_group_notify_f(
      group._id,
      queue._id,
      context,
      work,
    );
  }

  late final _dispatch_group_notify_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_group_t,
              dispatch_queue_t,
              ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_group_notify_f');
  late final _dispatch_group_notify_f = _dispatch_group_notify_fPtr.asFunction<
      void Function(dispatch_group_t, dispatch_queue_t, ffi.Pointer<ffi.Void>,
          dispatch_function_t)>();

  void dispatch_group_enter(
    Dartdispatch_group_t group,
  ) {
    return _dispatch_group_enter(
      group._id,
    );
  }

  late final _dispatch_group_enterPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_group_t)>>(
          'dispatch_group_enter');
  late final _dispatch_group_enter =
      _dispatch_group_enterPtr.asFunction<void Function(dispatch_group_t)>();

  void dispatch_group_leave(
    Dartdispatch_group_t group,
  ) {
    return _dispatch_group_leave(
      group._id,
    );
  }

  late final _dispatch_group_leavePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_group_t)>>(
          'dispatch_group_leave');
  late final _dispatch_group_leave =
      _dispatch_group_leavePtr.asFunction<void Function(dispatch_group_t)>();

  Dartdispatch_semaphore_t dispatch_semaphore_create(
    int value,
  ) {
    return NSObject._(
        _dispatch_semaphore_create(
          value,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_semaphore_createPtr =
      _lookup<ffi.NativeFunction<dispatch_semaphore_t Function(ffi.IntPtr)>>(
          'dispatch_semaphore_create');
  late final _dispatch_semaphore_create = _dispatch_semaphore_createPtr
      .asFunction<dispatch_semaphore_t Function(int)>();

  int dispatch_semaphore_wait(
    Dartdispatch_semaphore_t dsema,
    Dartdispatch_time_t timeout,
  ) {
    return _dispatch_semaphore_wait(
      dsema._id,
      timeout,
    );
  }

  late final _dispatch_semaphore_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(dispatch_semaphore_t,
              dispatch_time_t)>>('dispatch_semaphore_wait');
  late final _dispatch_semaphore_wait = _dispatch_semaphore_waitPtr
      .asFunction<int Function(dispatch_semaphore_t, int)>();

  int dispatch_semaphore_signal(
    Dartdispatch_semaphore_t dsema,
  ) {
    return _dispatch_semaphore_signal(
      dsema._id,
    );
  }

  late final _dispatch_semaphore_signalPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(dispatch_semaphore_t)>>(
          'dispatch_semaphore_signal');
  late final _dispatch_semaphore_signal = _dispatch_semaphore_signalPtr
      .asFunction<int Function(dispatch_semaphore_t)>();

  void dispatch_once(
    ffi.Pointer<dispatch_once_t> predicate,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_once(
      predicate,
      block._id,
    );
  }

  late final _dispatch_oncePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<dispatch_once_t>,
              dispatch_block_t)>>('dispatch_once');
  late final _dispatch_once = _dispatch_oncePtr.asFunction<
      void Function(ffi.Pointer<dispatch_once_t>, dispatch_block_t)>();

  void dispatch_once_f(
    ffi.Pointer<dispatch_once_t> predicate,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t function,
  ) {
    return _dispatch_once_f(
      predicate,
      context,
      function,
    );
  }

  late final _dispatch_once_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<dispatch_once_t>, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_once_f');
  late final _dispatch_once_f = _dispatch_once_fPtr.asFunction<
      void Function(ffi.Pointer<dispatch_once_t>, ffi.Pointer<ffi.Void>,
          dispatch_function_t)>();

  Dartdispatch_data_t dispatch_data_create(
    ffi.Pointer<ffi.Void> buffer,
    int size,
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t destructor,
  ) {
    return NSObject._(
        _dispatch_data_create(
          buffer,
          size,
          queue._id,
          destructor._id,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_data_createPtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(ffi.Pointer<ffi.Void>, ffi.Size,
              dispatch_queue_t, dispatch_block_t)>>('dispatch_data_create');
  late final _dispatch_data_create = _dispatch_data_createPtr.asFunction<
      dispatch_data_t Function(
          ffi.Pointer<ffi.Void>, int, dispatch_queue_t, dispatch_block_t)>();

  int dispatch_data_get_size(
    Dartdispatch_data_t data,
  ) {
    return _dispatch_data_get_size(
      data._id,
    );
  }

  late final _dispatch_data_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(dispatch_data_t)>>(
          'dispatch_data_get_size');
  late final _dispatch_data_get_size =
      _dispatch_data_get_sizePtr.asFunction<int Function(dispatch_data_t)>();

  Dartdispatch_data_t dispatch_data_create_map(
    Dartdispatch_data_t data,
    ffi.Pointer<ffi.Pointer<ffi.Void>> buffer_ptr,
    ffi.Pointer<ffi.Size> size_ptr,
  ) {
    return NSObject._(
        _dispatch_data_create_map(
          data._id,
          buffer_ptr,
          size_ptr,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_data_create_mapPtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(
              dispatch_data_t,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>)>>('dispatch_data_create_map');
  late final _dispatch_data_create_map =
      _dispatch_data_create_mapPtr.asFunction<
          dispatch_data_t Function(dispatch_data_t,
              ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Size>)>();

  Dartdispatch_data_t dispatch_data_create_concat(
    Dartdispatch_data_t data1,
    Dartdispatch_data_t data2,
  ) {
    return NSObject._(
        _dispatch_data_create_concat(
          data1._id,
          data2._id,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_data_create_concatPtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(dispatch_data_t,
              dispatch_data_t)>>('dispatch_data_create_concat');
  late final _dispatch_data_create_concat = _dispatch_data_create_concatPtr
      .asFunction<dispatch_data_t Function(dispatch_data_t, dispatch_data_t)>();

  Dartdispatch_data_t dispatch_data_create_subrange(
    Dartdispatch_data_t data,
    int offset,
    int length,
  ) {
    return NSObject._(
        _dispatch_data_create_subrange(
          data._id,
          offset,
          length,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_data_create_subrangePtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(dispatch_data_t, ffi.Size,
              ffi.Size)>>('dispatch_data_create_subrange');
  late final _dispatch_data_create_subrange = _dispatch_data_create_subrangePtr
      .asFunction<dispatch_data_t Function(dispatch_data_t, int, int)>();

  bool dispatch_data_apply(
    Dartdispatch_data_t data,
    Dartdispatch_data_applier_t applier,
  ) {
    return _dispatch_data_apply(
      data._id,
      applier._id,
    );
  }

  late final _dispatch_data_applyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(dispatch_data_t,
              dispatch_data_applier_t)>>('dispatch_data_apply');
  late final _dispatch_data_apply = _dispatch_data_applyPtr
      .asFunction<bool Function(dispatch_data_t, dispatch_data_applier_t)>();

  Dartdispatch_data_t dispatch_data_copy_region(
    Dartdispatch_data_t data,
    int location,
    ffi.Pointer<ffi.Size> offset_ptr,
  ) {
    return NSObject._(
        _dispatch_data_copy_region(
          data._id,
          location,
          offset_ptr,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_data_copy_regionPtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(dispatch_data_t, ffi.Size,
              ffi.Pointer<ffi.Size>)>>('dispatch_data_copy_region');
  late final _dispatch_data_copy_region =
      _dispatch_data_copy_regionPtr.asFunction<
          dispatch_data_t Function(
              dispatch_data_t, int, ffi.Pointer<ffi.Size>)>();

  void dispatch_read(
    Dartdispatch_fd_t fd,
    int length,
    Dartdispatch_queue_t queue,
    ObjCBlock_ffiVoid_dispatchdatat_ffiInt handler,
  ) {
    return _dispatch_read(
      fd,
      length,
      queue._id,
      handler._id,
    );
  }

  late final _dispatch_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_fd_t, ffi.Size, dispatch_queue_t,
              ffi.Pointer<_ObjCBlock>)>>('dispatch_read');
  late final _dispatch_read = _dispatch_readPtr.asFunction<
      void Function(int, int, dispatch_queue_t, ffi.Pointer<_ObjCBlock>)>();

  void dispatch_write(
    Dartdispatch_fd_t fd,
    Dartdispatch_data_t data,
    Dartdispatch_queue_t queue,
    ObjCBlock_ffiVoid_dispatchdatat_ffiInt handler,
  ) {
    return _dispatch_write(
      fd,
      data._id,
      queue._id,
      handler._id,
    );
  }

  late final _dispatch_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_fd_t, dispatch_data_t, dispatch_queue_t,
              ffi.Pointer<_ObjCBlock>)>>('dispatch_write');
  late final _dispatch_write = _dispatch_writePtr.asFunction<
      void Function(
          int, dispatch_data_t, dispatch_queue_t, ffi.Pointer<_ObjCBlock>)>();

  Dartdispatch_io_t dispatch_io_create(
    Dartdispatch_io_type_t type,
    Dartdispatch_fd_t fd,
    Dartdispatch_queue_t queue,
    ObjCBlock_ffiVoid_ffiInt cleanup_handler,
  ) {
    return NSObject._(
        _dispatch_io_create(
          type,
          fd,
          queue._id,
          cleanup_handler._id,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_io_createPtr = _lookup<
      ffi.NativeFunction<
          dispatch_io_t Function(
              dispatch_io_type_t,
              dispatch_fd_t,
              dispatch_queue_t,
              ffi.Pointer<_ObjCBlock>)>>('dispatch_io_create');
  late final _dispatch_io_create = _dispatch_io_createPtr.asFunction<
      dispatch_io_t Function(
          int, int, dispatch_queue_t, ffi.Pointer<_ObjCBlock>)>();

  Dartdispatch_io_t dispatch_io_create_with_path(
    Dartdispatch_io_type_t type,
    ffi.Pointer<ffi.Char> path,
    int oflag,
    int mode,
    Dartdispatch_queue_t queue,
    ObjCBlock_ffiVoid_ffiInt cleanup_handler,
  ) {
    return NSObject._(
        _dispatch_io_create_with_path(
          type,
          path,
          oflag,
          mode,
          queue._id,
          cleanup_handler._id,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_io_create_with_pathPtr = _lookup<
      ffi.NativeFunction<
          dispatch_io_t Function(
              dispatch_io_type_t,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.UnsignedShort,
              dispatch_queue_t,
              ffi.Pointer<_ObjCBlock>)>>('dispatch_io_create_with_path');
  late final _dispatch_io_create_with_path =
      _dispatch_io_create_with_pathPtr.asFunction<
          dispatch_io_t Function(int, ffi.Pointer<ffi.Char>, int, int,
              dispatch_queue_t, ffi.Pointer<_ObjCBlock>)>();

  Dartdispatch_io_t dispatch_io_create_with_io(
    Dartdispatch_io_type_t type,
    Dartdispatch_io_t io,
    Dartdispatch_queue_t queue,
    ObjCBlock_ffiVoid_ffiInt cleanup_handler,
  ) {
    return NSObject._(
        _dispatch_io_create_with_io(
          type,
          io._id,
          queue._id,
          cleanup_handler._id,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_io_create_with_ioPtr = _lookup<
      ffi.NativeFunction<
          dispatch_io_t Function(
              dispatch_io_type_t,
              dispatch_io_t,
              dispatch_queue_t,
              ffi.Pointer<_ObjCBlock>)>>('dispatch_io_create_with_io');
  late final _dispatch_io_create_with_io =
      _dispatch_io_create_with_ioPtr.asFunction<
          dispatch_io_t Function(
              int, dispatch_io_t, dispatch_queue_t, ffi.Pointer<_ObjCBlock>)>();

  void dispatch_io_read(
    Dartdispatch_io_t channel,
    int offset,
    int length,
    Dartdispatch_queue_t queue,
    Dartdispatch_io_handler_t io_handler,
  ) {
    return _dispatch_io_read(
      channel._id,
      offset,
      length,
      queue._id,
      io_handler._id,
    );
  }

  late final _dispatch_io_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_io_t, ffi.LongLong, ffi.Size,
              dispatch_queue_t, dispatch_io_handler_t)>>('dispatch_io_read');
  late final _dispatch_io_read = _dispatch_io_readPtr.asFunction<
      void Function(
          dispatch_io_t, int, int, dispatch_queue_t, dispatch_io_handler_t)>();

  void dispatch_io_write(
    Dartdispatch_io_t channel,
    int offset,
    Dartdispatch_data_t data,
    Dartdispatch_queue_t queue,
    Dartdispatch_io_handler_t io_handler,
  ) {
    return _dispatch_io_write(
      channel._id,
      offset,
      data._id,
      queue._id,
      io_handler._id,
    );
  }

  late final _dispatch_io_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_io_t, ffi.LongLong, dispatch_data_t,
              dispatch_queue_t, dispatch_io_handler_t)>>('dispatch_io_write');
  late final _dispatch_io_write = _dispatch_io_writePtr.asFunction<
      void Function(dispatch_io_t, int, dispatch_data_t, dispatch_queue_t,
          dispatch_io_handler_t)>();

  void dispatch_io_close(
    Dartdispatch_io_t channel,
    Dartdispatch_io_close_flags_t flags,
  ) {
    return _dispatch_io_close(
      channel._id,
      flags,
    );
  }

  late final _dispatch_io_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_io_t, dispatch_io_close_flags_t)>>('dispatch_io_close');
  late final _dispatch_io_close =
      _dispatch_io_closePtr.asFunction<void Function(dispatch_io_t, int)>();

  void dispatch_io_barrier(
    Dartdispatch_io_t channel,
    Dartdispatch_block_t barrier,
  ) {
    return _dispatch_io_barrier(
      channel._id,
      barrier._id,
    );
  }

  late final _dispatch_io_barrierPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(dispatch_io_t, dispatch_block_t)>>(
      'dispatch_io_barrier');
  late final _dispatch_io_barrier = _dispatch_io_barrierPtr
      .asFunction<void Function(dispatch_io_t, dispatch_block_t)>();

  Dartdispatch_fd_t dispatch_io_get_descriptor(
    Dartdispatch_io_t channel,
  ) {
    return _dispatch_io_get_descriptor(
      channel._id,
    );
  }

  late final _dispatch_io_get_descriptorPtr =
      _lookup<ffi.NativeFunction<dispatch_fd_t Function(dispatch_io_t)>>(
          'dispatch_io_get_descriptor');
  late final _dispatch_io_get_descriptor =
      _dispatch_io_get_descriptorPtr.asFunction<int Function(dispatch_io_t)>();

  void dispatch_io_set_high_water(
    Dartdispatch_io_t channel,
    int high_water,
  ) {
    return _dispatch_io_set_high_water(
      channel._id,
      high_water,
    );
  }

  late final _dispatch_io_set_high_waterPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_io_t, ffi.Size)>>(
          'dispatch_io_set_high_water');
  late final _dispatch_io_set_high_water = _dispatch_io_set_high_waterPtr
      .asFunction<void Function(dispatch_io_t, int)>();

  void dispatch_io_set_low_water(
    Dartdispatch_io_t channel,
    int low_water,
  ) {
    return _dispatch_io_set_low_water(
      channel._id,
      low_water,
    );
  }

  late final _dispatch_io_set_low_waterPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_io_t, ffi.Size)>>(
          'dispatch_io_set_low_water');
  late final _dispatch_io_set_low_water = _dispatch_io_set_low_waterPtr
      .asFunction<void Function(dispatch_io_t, int)>();

  void dispatch_io_set_interval(
    Dartdispatch_io_t channel,
    int interval,
    Dartdispatch_io_interval_flags_t flags,
  ) {
    return _dispatch_io_set_interval(
      channel._id,
      interval,
      flags,
    );
  }

  late final _dispatch_io_set_intervalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_io_t, ffi.Uint64,
              dispatch_io_interval_flags_t)>>('dispatch_io_set_interval');
  late final _dispatch_io_set_interval = _dispatch_io_set_intervalPtr
      .asFunction<void Function(dispatch_io_t, int, int)>();

  Dartdispatch_workloop_t dispatch_workloop_create(
    ffi.Pointer<ffi.Char> label,
  ) {
    return NSObject._(
        _dispatch_workloop_create(
          label,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_workloop_createPtr = _lookup<
          ffi
          .NativeFunction<dispatch_workloop_t Function(ffi.Pointer<ffi.Char>)>>(
      'dispatch_workloop_create');
  late final _dispatch_workloop_create = _dispatch_workloop_createPtr
      .asFunction<dispatch_workloop_t Function(ffi.Pointer<ffi.Char>)>();

  Dartdispatch_workloop_t dispatch_workloop_create_inactive(
    ffi.Pointer<ffi.Char> label,
  ) {
    return NSObject._(
        _dispatch_workloop_create_inactive(
          label,
        ),
        this,
        retain: false,
        release: true);
  }

  late final _dispatch_workloop_create_inactivePtr = _lookup<
          ffi
          .NativeFunction<dispatch_workloop_t Function(ffi.Pointer<ffi.Char>)>>(
      'dispatch_workloop_create_inactive');
  late final _dispatch_workloop_create_inactive =
      _dispatch_workloop_create_inactivePtr
          .asFunction<dispatch_workloop_t Function(ffi.Pointer<ffi.Char>)>();

  void dispatch_workloop_set_autorelease_frequency(
    Dartdispatch_workloop_t workloop,
    int frequency,
  ) {
    return _dispatch_workloop_set_autorelease_frequency(
      workloop._id,
      frequency,
    );
  }

  late final _dispatch_workloop_set_autorelease_frequencyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(dispatch_workloop_t, ffi.Int32)>>(
      'dispatch_workloop_set_autorelease_frequency');
  late final _dispatch_workloop_set_autorelease_frequency =
      _dispatch_workloop_set_autorelease_frequencyPtr
          .asFunction<void Function(dispatch_workloop_t, int)>();

  void dispatch_workloop_set_os_workgroup(
    Dartdispatch_workloop_t workloop,
    OS_os_workgroup workgroup,
  ) {
    return _dispatch_workloop_set_os_workgroup(
      workloop._id,
      workgroup._id,
    );
  }

  late final _dispatch_workloop_set_os_workgroupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_workloop_t,
              ffi.Pointer<ObjCObject>)>>('dispatch_workloop_set_os_workgroup');
  late final _dispatch_workloop_set_os_workgroup =
      _dispatch_workloop_set_os_workgroupPtr.asFunction<
          void Function(dispatch_workloop_t, ffi.Pointer<ObjCObject>)>();

  late final _class_OS_os_workgroup1 = _getClass1("OS_os_workgroup");
  late final _class_OS_object1 = _getClass1("OS_object");

  /// !
  /// @brief
  /// Get value of service property.
  ///
  /// @param property
  /// The requested property.
  /// Currently the only property defined is kDNSServiceProperty_DaemonVersion.
  ///
  /// @param result
  /// Place to store result.
  /// For retrieving DaemonVersion, this should be the address of a uint32_t.
  ///
  /// @param size
  /// Pointer to uint32_t containing size of the result location.
  /// For retrieving DaemonVersion, this should be sizeof(uint32_t).
  /// On return the uint32_t is updated to the size of the data returned.
  /// For DaemonVersion, the returned size is always sizeof(uint32_t), but
  /// future properties could be defined which return variable-sized results.
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success, or kDNSServiceErr_ServiceNotRunning
  /// if the daemon (or "system service" on Windows) is not running.
  int DNSServiceGetProperty(
    ffi.Pointer<ffi.Char> property,
    ffi.Pointer<ffi.Void> result,
    ffi.Pointer<ffi.Uint32> size,
  ) {
    return _DNSServiceGetProperty(
      property,
      result,
      size,
    );
  }

  late final _DNSServiceGetPropertyPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Uint32>)>>('DNSServiceGetProperty');
  late final _DNSServiceGetProperty = _DNSServiceGetPropertyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Uint32>)>();

  /// !
  /// @brief
  /// Access underlying Unix domain socket for an initialized DNSServiceRef.
  ///
  /// @param sdRef
  /// A DNSServiceRef initialized by any of the DNSService calls.
  ///
  /// @result
  /// The DNSServiceRef's underlying socket descriptor, or -1 on error.
  ///
  /// @discussion
  /// The DNS Service Discovery implementation uses this socket to communicate between the client and
  /// the daemon. The application MUST NOT directly read from or write to this socket.
  /// Access to the socket is provided so that it can be used as a kqueue event source, a CFRunLoop
  /// event source, in a select() loop, etc. When the underlying event management subsystem (kqueue/
  /// select/CFRunLoop etc.) indicates to the client that data is available for reading on the
  /// socket, the client should call DNSServiceProcessResult(), which will extract the daemon's
  /// reply from the socket, and pass it to the appropriate application callback. By using a run
  /// loop or select(), results from the daemon can be processed asynchronously. Alternatively,
  /// a client can choose to fork a thread and have it loop calling "DNSServiceProcessResult(ref);"
  /// If DNSServiceProcessResult() is called when no data is available for reading on the socket, it
  /// will block until data does become available, and then process the data and return to the caller.
  /// The application is responsible for checking the return value of DNSServiceProcessResult()
  /// to determine if the socket is valid and if it should continue to process data on the socket.
  /// When data arrives on the socket, the client is responsible for calling DNSServiceProcessResult(ref)
  /// in a timely fashion -- if the client allows a large backlog of data to build up the daemon
  /// may terminate the connection.
  int DNSServiceRefSockFD(
    DNSServiceRef sdRef,
  ) {
    return _DNSServiceRefSockFD(
      sdRef,
    );
  }

  late final _DNSServiceRefSockFDPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(DNSServiceRef)>>(
          'DNSServiceRefSockFD');
  late final _DNSServiceRefSockFD =
      _DNSServiceRefSockFDPtr.asFunction<int Function(DNSServiceRef)>();

  /// !
  /// @brief
  /// Read a reply from the daemon, calling the appropriate application callback.
  ///
  /// @param sdRef
  /// A DNSServiceRef initialized by any of the DNSService calls
  /// that take a callback parameter.
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success, otherwise returns
  /// an error code indicating the specific failure that occurred.
  ///
  /// @discussion
  /// This call will block until the daemon's response is received. Use DNSServiceRefSockFD() in
  /// conjunction with a run loop or select() to determine the presence of a response from the
  /// server before calling this function to process the reply without blocking. Call this function
  /// at any point if it is acceptable to block until the daemon's response arrives. Note that the
  /// client is responsible for ensuring that DNSServiceProcessResult() is called whenever there is
  /// a reply from the daemon - the daemon may terminate its connection with a client that does not
  /// process the daemon's responses.
  int DNSServiceProcessResult(
    DNSServiceRef sdRef,
  ) {
    return _DNSServiceProcessResult(
      sdRef,
    );
  }

  late final _DNSServiceProcessResultPtr =
      _lookup<ffi.NativeFunction<DNSServiceErrorType Function(DNSServiceRef)>>(
          'DNSServiceProcessResult');
  late final _DNSServiceProcessResult =
      _DNSServiceProcessResultPtr.asFunction<int Function(DNSServiceRef)>();

  /// !
  /// @brief
  /// Terminate a connection with the daemon and free memory associated with the DNSServiceRef.
  ///
  /// @param sdRef
  /// A DNSServiceRef initialized by any of the DNSService calls.
  ///
  /// @discussion
  /// Any services or records registered with this DNSServiceRef will be deregistered. Any
  /// Browse, Resolve, or Query operations called with this reference will be terminated.
  ///
  /// Note: If the reference's underlying socket is used in a run loop or select() call, it should
  /// be removed BEFORE DNSServiceRefDeallocate() is called, as this function closes the reference's
  /// socket.
  ///
  /// Note: If the reference was initialized with DNSServiceCreateConnection(), any DNSRecordRefs
  /// created via this reference will be invalidated by this call - the resource records are
  /// deregistered, and their DNSRecordRefs may not be used in subsequent functions. Similarly,
  /// if the reference was initialized with DNSServiceRegister, and an extra resource record was
  /// added to the service via DNSServiceAddRecord(), the DNSRecordRef created by the Add() call
  /// is invalidated when this function is called - the DNSRecordRef may not be used in subsequent
  /// functions.
  ///
  /// If the reference was passed to DNSServiceSetDispatchQueue(), DNSServiceRefDeallocate() must
  /// be called on the same queue originally passed as an argument to DNSServiceSetDispatchQueue().
  ///
  /// Note: This call is to be used only with the DNSServiceRef defined by this API.
  void DNSServiceRefDeallocate(
    DNSServiceRef sdRef,
  ) {
    return _DNSServiceRefDeallocate(
      sdRef,
    );
  }

  late final _DNSServiceRefDeallocatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(DNSServiceRef)>>(
          'DNSServiceRefDeallocate');
  late final _DNSServiceRefDeallocate =
      _DNSServiceRefDeallocatePtr.asFunction<void Function(DNSServiceRef)>();

  /// !
  /// @brief
  /// Asynchronously enumerate domains available for browsing and registration.
  ///
  /// @param sdRef
  /// A pointer to an uninitialized DNSServiceRef
  /// (or, if the kDNSServiceFlagsShareConnection flag is used,
  /// a copy of the shared connection reference that is to be used).
  /// If the call succeeds then it initializes (or updates) the DNSServiceRef,
  /// returns kDNSServiceErr_NoError, and the enumeration operation
  /// will remain active indefinitely until the client terminates it
  /// by passing this DNSServiceRef to DNSServiceRefDeallocate()
  /// (or by closing the underlying shared connection, if used).
  ///
  /// @param flags
  /// Possible values are:
  /// kDNSServiceFlagsShareConnection to use a shared connection.
  /// kDNSServiceFlagsBrowseDomains to enumerate domains recommended for browsing.
  /// kDNSServiceFlagsRegistrationDomains to enumerate domains recommended
  /// for registration.
  ///
  /// @param interfaceIndex
  /// If non-zero, specifies the interface on which to look for domains.
  /// (the index for a given interface is determined via the if_nametoindex()
  /// family of calls.) Most applications will pass 0 to enumerate domains on
  /// all interfaces. See "Constants for specifying an interface index" for more details.
  ///
  /// @param callBack
  /// The function to be called when a domain is found or the call asynchronously
  /// fails.
  ///
  /// @param context
  /// An application context pointer which is passed to the callback function
  /// (may be NULL).
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
  /// errors are delivered to the callback), otherwise returns an error code indicating
  /// the error that occurred (the callback is not invoked and the DNSServiceRef
  /// is not initialized).
  /// @discussion
  /// The enumeration MUST be cancelled via DNSServiceRefDeallocate() when no more domains
  /// are to be found.
  ///
  /// Note that the names returned are (like all of DNS-SD) UTF-8 strings,
  /// and are escaped using standard DNS escaping rules.
  /// (See "Notes on DNS Name Escaping" earlier in this file for more details.)
  /// A graphical browser displaying a hierarchical tree-structured view should cut
  /// the names at the bare dots to yield individual labels, then de-escape each
  /// label according to the escaping rules, and then display the resulting UTF-8 text.
  int DNSServiceEnumerateDomains(
    ffi.Pointer<DNSServiceRef> sdRef,
    int flags,
    int interfaceIndex,
    DNSServiceDomainEnumReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceEnumerateDomains(
      sdRef,
      flags,
      interfaceIndex,
      callBack,
      context,
    );
  }

  late final _DNSServiceEnumerateDomainsPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>,
              DNSServiceFlags,
              ffi.Uint32,
              DNSServiceDomainEnumReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceEnumerateDomains');
  late final _DNSServiceEnumerateDomains =
      _DNSServiceEnumerateDomainsPtr.asFunction<
          int Function(ffi.Pointer<DNSServiceRef>, int, int,
              DNSServiceDomainEnumReply, ffi.Pointer<ffi.Void>)>();

  /// !
  /// @brief
  /// Register a service that is discovered via Browse() and Resolve() calls.
  ///
  /// @param sdRef
  /// A pointer to an uninitialized DNSServiceRef
  /// (or, if the kDNSServiceFlagsShareConnection flag is used,
  /// a copy of the shared connection reference that is to be used).
  /// If the call succeeds then it initializes (or updates) the DNSServiceRef,
  /// returns kDNSServiceErr_NoError, and the service registration
  /// will remain active indefinitely until the client terminates it
  /// by passing this DNSServiceRef to DNSServiceRefDeallocate()
  /// (or by closing the underlying shared connection, if used).
  ///
  /// @param flags
  /// Possible values are:
  /// kDNSServiceFlagsShareConnection to use a shared connection.
  /// Other flags indicate the renaming behavior on name conflict
  /// (not required for most applications).
  /// See flag definitions above for details.
  ///
  /// @param interfaceIndex
  /// If non-zero, specifies the interface on which to register the service
  /// (the index for a given interface is determined via the if_nametoindex()
  /// family of calls.) Most applications will pass 0 to register on all
  /// available interfaces. See "Constants for specifying an interface index" for more details.
  ///
  /// @param name
  /// If non-NULL, specifies the service name to be registered.
  /// Most applications will not specify a name, in which case the computer
  /// name is used (this name is communicated to the client via the callback).
  /// If a name is specified, it must be 1-63 bytes of UTF-8 text.
  /// If the name is longer than 63 bytes it will be automatically truncated
  /// to a legal length, unless the NoAutoRename flag is set,
  /// in which case kDNSServiceErr_BadParam will be returned.
  ///
  /// @param regtype
  /// The service type followed by the protocol, separated by a dot
  /// (e.g. "_ftp._tcp"). The service type must be an underscore, followed
  /// by 1-15 characters, which may be letters, digits, or hyphens.
  /// The transport protocol must be "_tcp" or "_udp". New service types
  /// should be registered at <http://www.dns-sd.org/ServiceTypes.html>.
  ///
  /// Additional subtypes of the primary service type (where a service
  /// type has defined subtypes) follow the primary service type in a
  /// comma-separated list, with no additional spaces, e.g.
  /// "_primarytype._tcp,_subtype1,_subtype2,_subtype3"
  /// Subtypes provide a mechanism for filtered browsing: A client browsing
  /// for "_primarytype._tcp" will discover all instances of this type;
  /// a client browsing for "_primarytype._tcp,_subtype2" will discover only
  /// those instances that were registered with "_subtype2" in their list of
  /// registered subtypes.
  ///
  /// The subtype mechanism can be illustrated with some examples using the
  /// dns-sd command-line tool:
  ///
  /// % dns-sd -R Simple _test._tcp "" 1001 &
  /// % dns-sd -R Better _test._tcp,HasFeatureA "" 1002 &
  /// % dns-sd -R Best   _test._tcp,HasFeatureA,HasFeatureB "" 1003 &
  ///
  /// Now:
  /// % dns-sd -B _test._tcp             # will find all three services
  /// % dns-sd -B _test._tcp,HasFeatureA # finds "Better" and "Best"
  /// % dns-sd -B _test._tcp,HasFeatureB # finds only "Best"
  ///
  /// Subtype labels may be up to 63 bytes long, and may contain any eight-
  /// bit byte values, including zero bytes. However, due to the nature of
  /// using a C-string-based API, conventional DNS escaping must be used for
  /// dots ('.'), commas (','), backslashes ('\') and zero bytes, as shown below:
  ///
  /// % dns-sd -R Test '_test._tcp,s\.one,s\,two,s\\three,s\000four' local 123
  ///
  /// @param domain
  /// If non-NULL, specifies the domain on which to advertise the service.
  /// Most applications will not specify a domain, instead automatically
  /// registering in the default domain(s).
  ///
  /// @param host
  /// If non-NULL, specifies the SRV target host name. Most applications
  /// will not specify a host, instead automatically using the machine's
  /// default host name(s). Note that specifying a non-NULL host does NOT
  /// create an address record for that host - the application is responsible
  /// for ensuring that the appropriate address record exists, or creating it
  /// via DNSServiceRegisterRecord().
  ///
  /// @param port
  /// The port, in network byte order, on which the service accepts connections.
  /// Pass 0 for a "placeholder" service (i.e. a service that will not be discovered
  /// by browsing, but will cause a name conflict if another client tries to
  /// register that same name). Most clients will not use placeholder services.
  ///
  /// @param txtLen
  /// The length of the txtRecord, in bytes. Must be zero if the txtRecord is NULL.
  ///
  /// @param txtRecord
  /// The TXT record rdata. A non-NULL txtRecord MUST be a properly formatted DNS
  /// TXT record, i.e. <length byte> <data> <length byte> <data> ...
  /// Passing NULL for the txtRecord is allowed as a synonym for txtLen=1, txtRecord="",
  /// i.e. it creates a TXT record of length one containing a single empty string.
  /// RFC 1035 doesn't allow a TXT record to contain *zero* strings, so a single empty
  /// string is the smallest legal DNS TXT record.
  /// As with the other parameters, the DNSServiceRegister call copies the txtRecord
  /// data; e.g. if you allocated the storage for the txtRecord parameter with malloc()
  /// then you can safely free that memory right after the DNSServiceRegister call returns.
  ///
  /// @param callBack
  /// The function to be called when the registration completes or asynchronously
  /// fails. The client MAY pass NULL for the callback -  The client will NOT be notified
  /// of the default values picked on its behalf, and the client will NOT be notified of any
  /// asynchronous errors (e.g. out of memory errors, etc.) that may prevent the registration
  /// of the service. The client may NOT pass the NoAutoRename flag if the callback is NULL.
  /// The client may still deregister the service at any time via DNSServiceRefDeallocate().
  ///
  /// @param context
  /// An application context pointer which is passed to the callback function
  /// (may be NULL).
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
  /// errors are delivered to the callback), otherwise returns an error code indicating
  /// the error that occurred (the callback is never invoked and the DNSServiceRef
  /// is not initialized).
  int DNSServiceRegister(
    ffi.Pointer<DNSServiceRef> sdRef,
    int flags,
    int interfaceIndex,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> domain,
    ffi.Pointer<ffi.Char> host,
    int port,
    int txtLen,
    ffi.Pointer<ffi.Void> txtRecord,
    DNSServiceRegisterReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceRegister(
      sdRef,
      flags,
      interfaceIndex,
      name,
      regtype,
      domain,
      host,
      port,
      txtLen,
      txtRecord,
      callBack,
      context,
    );
  }

  late final _DNSServiceRegisterPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>,
              DNSServiceFlags,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Pointer<ffi.Void>,
              DNSServiceRegisterReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceRegister');
  late final _DNSServiceRegister = _DNSServiceRegisterPtr.asFunction<
      int Function(
          ffi.Pointer<DNSServiceRef>,
          int,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          DNSServiceRegisterReply,
          ffi.Pointer<ffi.Void>)>();

  /// !
  /// @brief
  /// Add a record to a registered service.
  ///
  /// @param sdRef
  /// A DNSServiceRef initialized by DNSServiceRegister().
  ///
  /// @param RecordRef
  /// A pointer to an uninitialized DNSRecordRef. Upon succesfull completion of this
  /// call, this ref may be passed to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().
  /// If the above DNSServiceRef is passed to DNSServiceRefDeallocate(), RecordRef is also
  /// invalidated and may not be used further.
  ///
  /// @param flags
  /// Currently ignored, reserved for future use.
  ///
  /// @param rrtype
  /// The type of the record (e.g. kDNSServiceType_TXT, kDNSServiceType_SRV, etc)
  ///
  /// @param rdlen
  /// The length, in bytes, of the rdata.
  ///
  /// @param rdata
  /// The raw rdata to be contained in the added resource record.
  ///
  /// @param ttl
  /// The time to live of the resource record, in seconds.
  /// Most clients should pass 0 to indicate that the system should
  /// select a sensible default value.
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success, otherwise returns an
  /// error code indicating the error that occurred (the RecordRef is not initialized).
  ///
  /// @discussion
  /// The name of the record will be the same as the
  /// registered service's name.
  /// The record can later be updated or deregistered by passing the RecordRef initialized
  /// by this function to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().
  ///
  /// Note that the DNSServiceAddRecord/UpdateRecord/RemoveRecord are *NOT* thread-safe
  /// with respect to a single DNSServiceRef. If you plan to have multiple threads
  /// in your program simultaneously add, update, or remove records from the same
  /// DNSServiceRef, then it's the caller's responsibility to use a mutex lock
  /// or take similar appropriate precautions to serialize those calls.
  int DNSServiceAddRecord(
    DNSServiceRef sdRef,
    ffi.Pointer<DNSRecordRef> RecordRef,
    int flags,
    int rrtype,
    int rdlen,
    ffi.Pointer<ffi.Void> rdata,
    int ttl,
  ) {
    return _DNSServiceAddRecord(
      sdRef,
      RecordRef,
      flags,
      rrtype,
      rdlen,
      rdata,
      ttl,
    );
  }

  late final _DNSServiceAddRecordPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              DNSServiceRef,
              ffi.Pointer<DNSRecordRef>,
              DNSServiceFlags,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Pointer<ffi.Void>,
              ffi.Uint32)>>('DNSServiceAddRecord');
  late final _DNSServiceAddRecord = _DNSServiceAddRecordPtr.asFunction<
      int Function(DNSServiceRef, ffi.Pointer<DNSRecordRef>, int, int, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @brief
  /// Update a registered resource record. This function can update three types of records:
  /// 1. The primary txt record for a service that was previously registered.
  /// 2. Some other record that was added to the service using DNSServiceAddRecord().
  /// 3. A record registered using DNSServiceRegisterRecord().
  ///
  /// @param sdRef
  /// For updates of records associated with a registered service (cases 1 and 2), this is the
  /// DNSServiceRef returned by DNSServiceRegister(). For updates of records registered with
  /// DNSServiceRegisterRecord() (case 3), this is the DNSServiceRef that was passed to
  /// DNSServiceRegisterRecord().
  ///
  /// @param recordRef
  /// For case 1, this is NULL. For case 2, it's a DNSRecordRef returned by DNSServiceAddRecord(). For
  /// case 3, it's a DNSRecordRef returned by DNSServiceRegisterRecord().
  ///
  /// @param flags
  /// Currently ignored, reserved for future use.
  ///
  /// @param rdlen
  /// The length, in bytes, of the new rdata.
  ///
  /// @param rdata
  /// The new rdata to be contained in the updated resource record.
  ///
  /// @param ttl
  /// The time to live of the updated resource record, in seconds.
  /// Most clients should pass 0 to indicate that the system should
  /// select a sensible default value.
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success, otherwise returns an
  /// error code indicating the error that occurred.
  int DNSServiceUpdateRecord(
    DNSServiceRef sdRef,
    DNSRecordRef recordRef,
    int flags,
    int rdlen,
    ffi.Pointer<ffi.Void> rdata,
    int ttl,
  ) {
    return _DNSServiceUpdateRecord(
      sdRef,
      recordRef,
      flags,
      rdlen,
      rdata,
      ttl,
    );
  }

  late final _DNSServiceUpdateRecordPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              DNSServiceRef,
              DNSRecordRef,
              DNSServiceFlags,
              ffi.Uint16,
              ffi.Pointer<ffi.Void>,
              ffi.Uint32)>>('DNSServiceUpdateRecord');
  late final _DNSServiceUpdateRecord = _DNSServiceUpdateRecordPtr.asFunction<
      int Function(
          DNSServiceRef, DNSRecordRef, int, int, ffi.Pointer<ffi.Void>, int)>();

  int DNSServiceUpdateRecordWithAttribute(
    DNSServiceRef sdRef,
    DNSRecordRef recordRef,
    int flags,
    int rdlen,
    ffi.Pointer<ffi.Void> rdata,
    int ttl,
    DNSServiceAttributeRef attr,
  ) {
    return _DNSServiceUpdateRecordWithAttribute(
      sdRef,
      recordRef,
      flags,
      rdlen,
      rdata,
      ttl,
      attr,
    );
  }

  late final _DNSServiceUpdateRecordWithAttributePtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              DNSServiceRef,
              DNSRecordRef,
              DNSServiceFlags,
              ffi.Uint16,
              ffi.Pointer<ffi.Void>,
              ffi.Uint32,
              DNSServiceAttributeRef)>>('DNSServiceUpdateRecordWithAttribute');
  late final _DNSServiceUpdateRecordWithAttribute =
      _DNSServiceUpdateRecordWithAttributePtr.asFunction<
          int Function(DNSServiceRef, DNSRecordRef, int, int,
              ffi.Pointer<ffi.Void>, int, DNSServiceAttributeRef)>();

  /// !
  /// @brief
  /// Remove a record previously added to a service record set via DNSServiceAddRecord(), or deregister
  /// a record registered individually via DNSServiceRegisterRecord().
  ///
  /// @param sdRef
  /// A DNSServiceRef initialized by DNSServiceRegister() (if the
  /// record being removed was registered via DNSServiceAddRecord()) or by
  /// DNSServiceCreateConnection() (if the record being removed was registered via
  /// DNSServiceRegisterRecord()).
  ///
  /// @param RecordRef
  /// A DNSRecordRef initialized by a successful call to DNSServiceAddRecord()
  /// or DNSServiceRegisterRecord().
  ///
  /// @param flags
  /// Currently ignored, reserved for future use.
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success, otherwise returns an
  /// error code indicating the error that occurred.
  int DNSServiceRemoveRecord(
    DNSServiceRef sdRef,
    DNSRecordRef RecordRef,
    int flags,
  ) {
    return _DNSServiceRemoveRecord(
      sdRef,
      RecordRef,
      flags,
    );
  }

  late final _DNSServiceRemoveRecordPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(DNSServiceRef, DNSRecordRef,
              DNSServiceFlags)>>('DNSServiceRemoveRecord');
  late final _DNSServiceRemoveRecord = _DNSServiceRemoveRecordPtr.asFunction<
      int Function(DNSServiceRef, DNSRecordRef, int)>();

  /// !
  /// @brief
  /// Browse for instances of a service.
  ///
  /// @param sdRef
  /// A pointer to an uninitialized DNSServiceRef
  /// (or, if the kDNSServiceFlagsShareConnection flag is used,
  /// a copy of the shared connection reference that is to be used).
  /// If the call succeeds then it initializes (or updates) the DNSServiceRef,
  /// returns kDNSServiceErr_NoError, and the browse operation
  /// will remain active indefinitely until the client terminates it
  /// by passing this DNSServiceRef to DNSServiceRefDeallocate()
  /// (or by closing the underlying shared connection, if used).
  ///
  /// @param flags
  /// Possible values are:
  /// kDNSServiceFlagsShareConnection to use a shared connection.
  ///
  /// @param interfaceIndex
  /// If non-zero, specifies the interface on which to browse for services
  /// (the index for a given interface is determined via the if_nametoindex()
  /// family of calls.) Most applications will pass 0 to browse on all available
  /// interfaces. See "Constants for specifying an interface index" for more details.
  ///
  /// @param regtype
  /// The service type being browsed for followed by the protocol, separated by a
  /// dot (e.g. "_ftp._tcp"). The transport protocol must be "_tcp" or "_udp".
  /// A client may optionally specify a single subtype to perform filtered browsing:
  /// e.g. browsing for "_primarytype._tcp,_subtype" will discover only those
  /// instances of "_primarytype._tcp" that were registered specifying "_subtype"
  /// in their list of registered subtypes.
  ///
  /// @param domain
  /// If non-NULL, specifies the domain on which to browse for services.
  /// Most applications will not specify a domain, instead browsing on the
  /// default domain(s).
  ///
  /// @param callBack
  /// The function to be called when an instance of the service being browsed for
  /// is found, or if the call asynchronously fails.
  ///
  /// @param context
  /// An application context pointer which is passed to the callback function
  /// (may be NULL).
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
  /// errors are delivered to the callback), otherwise returns an error code indicating
  /// the error that occurred (the callback is not invoked and the DNSServiceRef
  /// is not initialized).
  int DNSServiceBrowse(
    ffi.Pointer<DNSServiceRef> sdRef,
    int flags,
    int interfaceIndex,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> domain,
    DNSServiceBrowseReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceBrowse(
      sdRef,
      flags,
      interfaceIndex,
      regtype,
      domain,
      callBack,
      context,
    );
  }

  late final _DNSServiceBrowsePtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>,
              DNSServiceFlags,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              DNSServiceBrowseReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceBrowse');
  late final _DNSServiceBrowse = _DNSServiceBrowsePtr.asFunction<
      int Function(
          ffi.Pointer<DNSServiceRef>,
          int,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          DNSServiceBrowseReply,
          ffi.Pointer<ffi.Void>)>();

  /// !
  /// @brief
  /// Resolve a service name discovered via DNSServiceBrowse() to a target host name, port number, and
  /// txt record.
  ///
  /// @param sdRef
  /// A pointer to an uninitialized DNSServiceRef
  /// (or, if the kDNSServiceFlagsShareConnection flag is used,
  /// a copy of the shared connection reference that is to be used).
  /// If the call succeeds then it initializes (or updates) the DNSServiceRef,
  /// returns kDNSServiceErr_NoError, and the resolve operation
  /// will remain active indefinitely until the client terminates it
  /// by passing this DNSServiceRef to DNSServiceRefDeallocate()
  /// (or by closing the underlying shared connection, if used).
  ///
  /// @param flags
  /// Possible values are:
  /// kDNSServiceFlagsShareConnection to use a shared connection.
  /// Specifying kDNSServiceFlagsForceMulticast will cause query to be
  /// performed with a link-local mDNS query, even if the name is an
  /// apparently non-local name (i.e. a name not ending in ".local.")
  ///
  /// @param interfaceIndex
  /// The interface on which to resolve the service. If this resolve call is
  /// as a result of a currently active DNSServiceBrowse() operation, then the
  /// interfaceIndex should be the index reported in the DNSServiceBrowseReply
  /// callback. If this resolve call is using information previously saved
  /// (e.g. in a preference file) for later use, then use interfaceIndex 0, because
  /// the desired service may now be reachable via a different physical interface.
  /// See "Constants for specifying an interface index" for more details.
  ///
  /// @param name
  /// The name of the service instance to be resolved, as reported to the
  /// DNSServiceBrowseReply() callback.
  ///
  /// @param regtype
  /// The type of the service instance to be resolved, as reported to the
  /// DNSServiceBrowseReply() callback.
  ///
  /// @param domain
  /// The domain of the service instance to be resolved, as reported to the
  /// DNSServiceBrowseReply() callback.
  ///
  /// @param callBack
  /// The function to be called when a result is found, or if the call
  /// asynchronously fails.
  ///
  /// @param context
  /// An application context pointer which is passed to the callback function
  /// (may be NULL).
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
  /// errors are delivered to the callback), otherwise returns an error code indicating
  /// the error that occurred (the callback is never invoked and the DNSServiceRef
  /// is not initialized).
  /// @discussion
  /// Note: Applications should NOT use DNSServiceResolve() solely for txt record monitoring - use
  /// DNSServiceQueryRecord() instead, as it is more efficient for this task.
  ///
  /// Note: When the desired results have been returned, the client MUST terminate the resolve by calling
  /// DNSServiceRefDeallocate().
  ///
  /// Note: DNSServiceResolve() behaves correctly for typical services that have a single SRV record
  /// and a single TXT record. To resolve non-standard services with multiple SRV or TXT records,
  /// DNSServiceQueryRecord() should be used.
  ///
  /// NOTE: In earlier versions of this header file, the txtRecord parameter was declared "const char *"
  /// This is incorrect, since it contains length bytes which are values in the range 0 to 255, not -128 to +127.
  /// Depending on your compiler settings, this change may cause signed/unsigned mismatch warnings.
  /// These should be fixed by updating your own callback function definition to match the corrected
  /// function signature using "const unsigned char *txtRecord". Making this change may also fix inadvertent
  /// bugs in your callback function, where it could have incorrectly interpreted a length byte with value 250
  /// as being -6 instead, with various bad consequences ranging from incorrect operation to software crashes.
  /// If you need to maintain portable code that will compile cleanly with both the old and new versions of
  /// this header file, you should update your callback function definition to use the correct unsigned value,
  /// and then in the place where you pass your callback function to DNSServiceResolve(), use a cast to eliminate
  /// the compiler warning, e.g.:
  /// DNSServiceResolve(sd, flags, index, name, regtype, domain, (DNSServiceResolveReply)MyCallback, context);
  /// This will ensure that your code compiles cleanly without warnings (and more importantly, works correctly)
  /// with both the old header and with the new corrected version.
  int DNSServiceResolve(
    ffi.Pointer<DNSServiceRef> sdRef,
    int flags,
    int interfaceIndex,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> domain,
    DNSServiceResolveReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceResolve(
      sdRef,
      flags,
      interfaceIndex,
      name,
      regtype,
      domain,
      callBack,
      context,
    );
  }

  late final _DNSServiceResolvePtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>,
              DNSServiceFlags,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              DNSServiceResolveReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceResolve');
  late final _DNSServiceResolve = _DNSServiceResolvePtr.asFunction<
      int Function(
          ffi.Pointer<DNSServiceRef>,
          int,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          DNSServiceResolveReply,
          ffi.Pointer<ffi.Void>)>();

  /// !
  /// @brief
  /// Query for an arbitrary DNS record.
  ///
  /// @param sdRef
  /// A pointer to an uninitialized DNSServiceRef
  /// (or, if the kDNSServiceFlagsShareConnection flag is used,
  /// a copy of the shared connection reference that is to be used).
  /// If the call succeeds then it initializes (or updates) the DNSServiceRef,
  /// returns kDNSServiceErr_NoError, and the query operation
  /// will remain active indefinitely until the client terminates it
  /// by passing this DNSServiceRef to DNSServiceRefDeallocate()
  /// (or by closing the underlying shared connection, if used).
  ///
  /// @param flags
  /// Possible values are:
  /// kDNSServiceFlagsShareConnection to use a shared connection.
  /// kDNSServiceFlagsForceMulticast or kDNSServiceFlagsLongLivedQuery.
  /// Pass kDNSServiceFlagsLongLivedQuery to create a "long-lived" unicast
  /// query to a unicast DNS server that implements the protocol. This flag
  /// has no effect on link-local multicast queries.
  ///
  /// @param interfaceIndex
  /// If non-zero, specifies the interface on which to issue the query
  /// (the index for a given interface is determined via the if_nametoindex()
  /// family of calls.) Passing 0 causes the name to be queried for on all
  /// interfaces. See "Constants for specifying an interface index" for more details.
  ///
  /// @param fullname
  /// The full domain name of the resource record to be queried for.
  ///
  /// @param rrtype
  /// The numerical type of the resource record to be queried for
  /// (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
  ///
  /// @param rrclass
  /// The class of the resource record (usually kDNSServiceClass_IN).
  ///
  /// @param callBack
  /// The function to be called when a result is found, or if the call
  /// asynchronously fails.
  ///
  /// @param context
  /// An application context pointer which is passed to the callback function
  /// (may be NULL).
  ///
  /// @result:
  /// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
  /// errors are delivered to the callback), otherwise returns an error code indicating
  /// the error that occurred (the callback is never invoked and the DNSServiceRef
  /// is not initialized).
  int DNSServiceQueryRecord(
    ffi.Pointer<DNSServiceRef> sdRef,
    int flags,
    int interfaceIndex,
    ffi.Pointer<ffi.Char> fullname,
    int rrtype,
    int rrclass,
    DNSServiceQueryRecordReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceQueryRecord(
      sdRef,
      flags,
      interfaceIndex,
      fullname,
      rrtype,
      rrclass,
      callBack,
      context,
    );
  }

  late final _DNSServiceQueryRecordPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>,
              DNSServiceFlags,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Uint16,
              ffi.Uint16,
              DNSServiceQueryRecordReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceQueryRecord');
  late final _DNSServiceQueryRecord = _DNSServiceQueryRecordPtr.asFunction<
      int Function(ffi.Pointer<DNSServiceRef>, int, int, ffi.Pointer<ffi.Char>,
          int, int, DNSServiceQueryRecordReply, ffi.Pointer<ffi.Void>)>();

  /// !
  /// @brief
  /// Queries for the IP address of a hostname by using either Multicast or Unicast DNS.
  ///
  /// @param sdRef
  /// A pointer to an uninitialized DNSServiceRef
  /// (or, if the kDNSServiceFlagsShareConnection flag is used,
  /// a copy of the shared connection reference that is to be used).
  /// If the call succeeds then it initializes (or updates) the DNSServiceRef,
  /// returns kDNSServiceErr_NoError, and the address query operation
  /// will remain active indefinitely until the client terminates it
  /// by passing this DNSServiceRef to DNSServiceRefDeallocate()
  /// (or by closing the underlying shared connection, if used).
  ///
  /// @param flags
  /// Possible values are:
  /// kDNSServiceFlagsShareConnection to use a shared connection.
  /// kDNSServiceFlagsForceMulticast
  ///
  /// @param interfaceIndex
  /// The interface on which to issue the query.  Passing 0 causes the query to be
  /// sent on all active interfaces via Multicast or the primary interface via Unicast.
  ///
  /// @param protocol
  /// Pass in kDNSServiceProtocol_IPv4 to look up IPv4 addresses, or kDNSServiceProtocol_IPv6
  /// to look up IPv6 addresses, or both to look up both kinds. If neither flag is
  /// set, the system will apply an intelligent heuristic, which is (currently)
  /// that it will attempt to look up both, except:
  ///
  /// * If "hostname" is a wide-area unicast DNS hostname (i.e. not a ".local." name)
  /// but this host has no routable IPv6 address, then the call will not try to
  /// look up IPv6 addresses for "hostname", since any addresses it found would be
  /// unlikely to be of any use anyway. Similarly, if this host has no routable
  /// IPv4 address, the call will not try to look up IPv4 addresses for "hostname".
  ///
  /// @param hostname
  /// The fully qualified domain name of the host to be queried for.
  ///
  /// @param callBack
  /// The function to be called when the query succeeds or fails asynchronously.
  ///
  /// @param context
  /// An application context pointer which is passed to the callback function
  /// (may be NULL).
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
  /// errors are delivered to the callback), otherwise returns an error code indicating
  /// the error that occurred.
  int DNSServiceGetAddrInfo(
    ffi.Pointer<DNSServiceRef> sdRef,
    int flags,
    int interfaceIndex,
    int protocol,
    ffi.Pointer<ffi.Char> hostname,
    DNSServiceGetAddrInfoReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceGetAddrInfo(
      sdRef,
      flags,
      interfaceIndex,
      protocol,
      hostname,
      callBack,
      context,
    );
  }

  late final _DNSServiceGetAddrInfoPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>,
              DNSServiceFlags,
              ffi.Uint32,
              DNSServiceProtocol,
              ffi.Pointer<ffi.Char>,
              DNSServiceGetAddrInfoReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceGetAddrInfo');
  late final _DNSServiceGetAddrInfo = _DNSServiceGetAddrInfoPtr.asFunction<
      int Function(
          ffi.Pointer<DNSServiceRef>,
          int,
          int,
          int,
          ffi.Pointer<ffi.Char>,
          DNSServiceGetAddrInfoReply,
          ffi.Pointer<ffi.Void>)>();

  /// !
  /// @brief
  /// Create a connection to the daemon allowing efficient registration of
  /// multiple individual records.
  ///
  /// @param sdRef
  /// A pointer to an uninitialized DNSServiceRef.
  /// Deallocating the reference (via DNSServiceRefDeallocate())
  /// severs the connection and cancels all operations and
  /// deregisters all records registered on this connection.
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success, otherwise returns
  /// an error code indicating the specific failure that occurred
  /// (in which case the DNSServiceRef is not initialized).
  int DNSServiceCreateConnection(
    ffi.Pointer<DNSServiceRef> sdRef,
  ) {
    return _DNSServiceCreateConnection(
      sdRef,
    );
  }

  late final _DNSServiceCreateConnectionPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>)>>('DNSServiceCreateConnection');
  late final _DNSServiceCreateConnection = _DNSServiceCreateConnectionPtr
      .asFunction<int Function(ffi.Pointer<DNSServiceRef>)>();

  /// !
  /// @brief
  /// Register an individual resource record on a connected DNSServiceRef.
  ///
  /// @param sdRef
  /// A DNSServiceRef initialized by DNSServiceCreateConnection().
  ///
  /// @param RecordRef
  /// A pointer to an uninitialized DNSRecordRef. Upon succesfull completion of this
  /// call, this ref may be passed to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().
  /// (To deregister ALL records registered on a single connected DNSServiceRef
  /// and deallocate each of their corresponding DNSServiceRecordRefs, call
  /// DNSServiceRefDeallocate()).
  ///
  /// @param flags
  /// Required values are:
  /// One of kDNSServiceFlagsShared, kDNSServiceFlagsUnique or kDNSServiceFlagsKnownUnique flags.
  ///
  /// Possible values are:
  /// kDNSServiceFlagsForceMulticast: If it is specified, the registration will be performed just like
  /// a link-local mDNS registration even if the name is an apparently non-local name (i.e. a name not
  /// ending in ".local.")
  ///
  /// @param interfaceIndex
  /// If non-zero, specifies the interface on which to register the record
  /// (the index for a given interface is determined via the if_nametoindex()
  /// family of calls.) Passing 0 causes the record to be registered on all interfaces.
  /// See "Constants for specifying an interface index" for more details.
  ///
  /// @param fullname
  /// The full domain name of the resource record.
  ///
  /// @param rrtype
  /// The numerical type of the resource record (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
  ///
  /// @param rrclass
  /// The class of the resource record (usually kDNSServiceClass_IN)
  ///
  /// @param rdlen
  /// Length, in bytes, of the rdata.
  ///
  /// @param rdata
  /// A pointer to the raw rdata, as it is to appear in the DNS record.
  ///
  /// @param ttl
  /// The time to live of the resource record, in seconds.
  /// Most clients should pass 0 to indicate that the system should
  /// select a sensible default value.
  ///
  /// @param callBack
  /// The function to be called when a result is found, or if the call
  /// asynchronously fails (e.g. because of a name conflict.)
  ///
  /// @param context
  /// An application context pointer which is passed to the callback function
  /// (may be NULL).
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
  /// errors are delivered to the callback), otherwise returns an error code indicating
  /// the error that occurred (the callback is never invoked and the DNSRecordRef is
  /// not initialized).
  ///
  /// @discussion
  /// Note that name conflicts occurring for records registered via this call must be handled
  /// by the client in the callback. The RecordRef object returned by the DNSServiceRegisterRecord
  /// call in this case is not disposed of as a result of the error. The caller is responsible
  /// for disposing of it either calling DNSServiceRemoveRecord on the value returned in RecordRef,
  /// or by calling DNSServiceRefDeallocate on the DNSServiceRef value passed in sdRef.
  int DNSServiceRegisterRecord(
    DNSServiceRef sdRef,
    ffi.Pointer<DNSRecordRef> RecordRef,
    int flags,
    int interfaceIndex,
    ffi.Pointer<ffi.Char> fullname,
    int rrtype,
    int rrclass,
    int rdlen,
    ffi.Pointer<ffi.Void> rdata,
    int ttl,
    DNSServiceRegisterRecordReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceRegisterRecord(
      sdRef,
      RecordRef,
      flags,
      interfaceIndex,
      fullname,
      rrtype,
      rrclass,
      rdlen,
      rdata,
      ttl,
      callBack,
      context,
    );
  }

  late final _DNSServiceRegisterRecordPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              DNSServiceRef,
              ffi.Pointer<DNSRecordRef>,
              DNSServiceFlags,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Pointer<ffi.Void>,
              ffi.Uint32,
              DNSServiceRegisterRecordReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceRegisterRecord');
  late final _DNSServiceRegisterRecord =
      _DNSServiceRegisterRecordPtr.asFunction<
          int Function(
              DNSServiceRef,
              ffi.Pointer<DNSRecordRef>,
              int,
              int,
              ffi.Pointer<ffi.Char>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              DNSServiceRegisterRecordReply,
              ffi.Pointer<ffi.Void>)>();

  /// !
  /// @brief
  /// Instruct the daemon to verify the validity of a resource record that appears
  /// to be out of date (e.g. because TCP connection to a service's target failed.)
  /// Causes the record to be flushed from the daemon's cache (as well as all other
  /// daemons' caches on the network) if the record is determined to be invalid.
  /// Use this routine conservatively. Reconfirming a record necessarily consumes
  /// network bandwidth, so this should not be done indiscriminately.
  ///
  /// @param flags
  /// Not currently used.
  ///
  /// @param interfaceIndex
  /// Specifies the interface of the record in question.
  /// The caller must specify the interface.
  /// This API (by design) causes increased network traffic, so it requires
  /// the caller to be precise about which record should be reconfirmed.
  /// It is not possible to pass zero for the interface index to perform
  /// a "wildcard" reconfirmation, where *all* matching records are reconfirmed.
  ///
  /// @param fullname
  /// The resource record's full domain name.
  ///
  /// @param rrtype
  /// The resource record's type (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
  ///
  /// @param rrclass
  /// The class of the resource record (usually kDNSServiceClass_IN).
  ///
  /// @param rdlen
  /// The length, in bytes, of the resource record rdata.
  ///
  /// @param rdata
  /// The raw rdata of the resource record.
  int DNSServiceReconfirmRecord(
    int flags,
    int interfaceIndex,
    ffi.Pointer<ffi.Char> fullname,
    int rrtype,
    int rrclass,
    int rdlen,
    ffi.Pointer<ffi.Void> rdata,
  ) {
    return _DNSServiceReconfirmRecord(
      flags,
      interfaceIndex,
      fullname,
      rrtype,
      rrclass,
      rdlen,
      rdata,
    );
  }

  late final _DNSServiceReconfirmRecordPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              DNSServiceFlags,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Pointer<ffi.Void>)>>('DNSServiceReconfirmRecord');
  late final _DNSServiceReconfirmRecord =
      _DNSServiceReconfirmRecordPtr.asFunction<
          int Function(int, int, ffi.Pointer<ffi.Char>, int, int, int,
              ffi.Pointer<ffi.Void>)>();

  /// !
  /// @brief
  /// Request a port mapping in the NAT gateway, which maps a port on the local machine
  /// to an external port on the NAT.
  ///
  /// @param sdRef
  /// A pointer to an uninitialized DNSServiceRef
  /// (or, if the kDNSServiceFlagsShareConnection flag is used,
  /// a copy of the shared connection reference that is to be used).
  /// If the call succeeds then it initializes (or updates) the DNSServiceRef,
  /// returns kDNSServiceErr_NoError, and the NAT port mapping
  /// will remain active indefinitely until the client terminates it
  /// by passing this DNSServiceRef to DNSServiceRefDeallocate()
  /// (or by closing the underlying shared connection, if used).
  ///
  /// @param flags
  /// Possible values are:
  /// kDNSServiceFlagsShareConnection to use a shared connection.
  ///
  /// @param interfaceIndex
  /// The interface on which to create port mappings in a NAT gateway.
  /// Passing 0 causes the port mapping request to be sent on the primary interface.
  ///
  /// @param protocol
  /// To request a port mapping, pass in kDNSServiceProtocol_UDP, or kDNSServiceProtocol_TCP,
  /// or (kDNSServiceProtocol_UDP | kDNSServiceProtocol_TCP) to map both.
  /// The local listening port number must also be specified in the internalPort parameter.
  /// To just discover the NAT gateway's external IP address, pass zero for protocol,
  /// internalPort, externalPort and ttl.
  ///
  /// @param internalPort
  /// The port number in network byte order on the local machine which is listening for packets.
  ///
  /// @param externalPort
  /// The requested external port in network byte order in the NAT gateway that you would
  /// like to map to the internal port. Pass 0 if you don't care which external port is chosen for you.
  ///
  /// @param ttl
  /// The requested renewal period of the NAT port mapping, in seconds.
  /// If the client machine crashes, suffers a power failure, is disconnected from
  /// the network, or suffers some other unfortunate demise which causes it to vanish
  /// unexpectedly without explicitly removing its NAT port mappings, then the NAT gateway
  /// will garbage-collect old stale NAT port mappings when their lifetime expires.
  /// Requesting a short TTL causes such orphaned mappings to be garbage-collected
  /// more promptly, but consumes system resources and network bandwidth with
  /// frequent renewal packets to keep the mapping from expiring.
  /// Requesting a long TTL is more efficient on the network, but in the event of the
  /// client vanishing, stale NAT port mappings will not be garbage-collected as quickly.
  /// Most clients should pass 0 to use a system-wide default value.
  ///
  /// @param callBack
  /// The function to be called when the port mapping request succeeds or fails asynchronously.
  ///
  /// @param context
  /// An application context pointer which is passed to the callback function
  /// (may be NULL).
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
  /// errors are delivered to the callback), otherwise returns an error code indicating
  /// the error that occurred.
  ///
  /// If you don't actually want a port mapped, and are just calling the API
  /// because you want to find out the NAT's external IP address (e.g. for UI
  /// display) then pass zero for protocol, internalPort, externalPort and ttl.
  ///
  /// @discussion
  /// The NAT should support either PCP, NAT-PMP or the
  /// UPnP/IGD protocol for this API to create a successful mapping. Note that this API
  /// currently supports IPv4 addresses/mappings only. If the NAT gateway supports PCP and
  /// returns an IPv6 address (incorrectly, since this API specifically requests IPv4
  /// addresses), the DNSServiceNATPortMappingReply callback will be invoked with errorCode
  /// kDNSServiceErr_NATPortMappingUnsupported.
  ///
  /// The port mapping will be renewed indefinitely until the client process exits, or
  /// explicitly terminates the port mapping request by calling DNSServiceRefDeallocate().
  /// The client callback will be invoked, informing the client of the NAT gateway's
  /// external IP address and the external port that has been allocated for this client.
  /// The client should then record this external IP address and port using whatever
  /// directory service mechanism it is using to enable peers to connect to it.
  /// (Clients advertising services using Wide-Area DNS-SD DO NOT need to use this API
  /// -- when a client calls DNSServiceRegister() NAT mappings are automatically created
  /// and the external IP address and port for the service are recorded in the global DNS.
  /// Only clients using some directory mechanism other than Wide-Area DNS-SD need to use
  /// this API to explicitly map their own ports.)
  ///
  /// It's possible that the client callback could be called multiple times, for example
  /// if the NAT gateway's IP address changes, or if a configuration change results in a
  /// different external port being mapped for this client. Over the lifetime of any long-lived
  /// port mapping, the client should be prepared to handle these notifications of changes
  /// in the environment, and should update its recorded address and/or port as appropriate.
  ///
  /// NOTE: There are two unusual aspects of how the DNSServiceNATPortMappingCreate API works,
  /// which were intentionally designed to help simplify client code:
  ///
  /// 1. It's not an error to request a NAT mapping when the machine is not behind a NAT gateway.
  /// In other NAT mapping APIs, if you request a NAT mapping and the machine is not behind a NAT
  /// gateway, then the API returns an error code -- it can't get you a NAT mapping if there's no
  /// NAT gateway. The DNSServiceNATPortMappingCreate API takes a different view. Working out
  /// whether or not you need a NAT mapping can be tricky and non-obvious, particularly on
  /// a machine with multiple active network interfaces. Rather than make every client recreate
  /// this logic for deciding whether a NAT mapping is required, the PortMapping API does that
  /// work for you. If the client calls the PortMapping API when the machine already has a
  /// routable public IP address, then instead of complaining about it and giving an error,
  /// the PortMapping API just invokes your callback, giving the machine's public address
  /// and your own port number. This means you don't need to write code to work out whether
  /// your client needs to call the PortMapping API -- just call it anyway, and if it wasn't
  /// necessary, no harm is done:
  ///
  /// - If the machine already has a routable public IP address, then your callback
  /// will just be invoked giving your own address and port.
  /// - If a NAT mapping is required and obtained, then your callback will be invoked
  /// giving you the external address and port.
  /// - If a NAT mapping is required but not obtained from the local NAT gateway,
  /// or the machine has no network connectivity, then your callback will be
  /// invoked giving zero address and port.
  ///
  /// 2. In other NAT mapping APIs, if a laptop computer is put to sleep and woken up on a new
  /// network, it's the client's job to notice this, and work out whether a NAT mapping
  /// is required on the new network, and make a new NAT mapping request if necessary.
  /// The DNSServiceNATPortMappingCreate API does this for you, automatically.
  /// The client just needs to make one call to the PortMapping API, and its callback will
  /// be invoked any time the mapping state changes. This property complements point (1) above.
  /// If the client didn't make a NAT mapping request just because it determined that one was
  /// not required at that particular moment in time, the client would then have to monitor
  /// for network state changes to determine if a NAT port mapping later became necessary.
  /// By unconditionally making a NAT mapping request, even when a NAT mapping not to be
  /// necessary, the PortMapping API will then begin monitoring network state changes on behalf of
  /// the client, and if a NAT mapping later becomes necessary, it will automatically create a NAT
  /// mapping and inform the client with a new callback giving the new address and port information.
  int DNSServiceNATPortMappingCreate(
    ffi.Pointer<DNSServiceRef> sdRef,
    int flags,
    int interfaceIndex,
    int protocol,
    int internalPort,
    int externalPort,
    int ttl,
    DNSServiceNATPortMappingReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceNATPortMappingCreate(
      sdRef,
      flags,
      interfaceIndex,
      protocol,
      internalPort,
      externalPort,
      ttl,
      callBack,
      context,
    );
  }

  late final _DNSServiceNATPortMappingCreatePtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>,
              DNSServiceFlags,
              ffi.Uint32,
              DNSServiceProtocol,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Uint32,
              DNSServiceNATPortMappingReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceNATPortMappingCreate');
  late final _DNSServiceNATPortMappingCreate =
      _DNSServiceNATPortMappingCreatePtr.asFunction<
          int Function(ffi.Pointer<DNSServiceRef>, int, int, int, int, int, int,
              DNSServiceNATPortMappingReply, ffi.Pointer<ffi.Void>)>();

  /// !
  /// @brief
  /// Concatenate a three-part domain name (as returned by the above callbacks) into a
  /// properly-escaped full domain name. Note that callbacks in the above functions ALREADY ESCAPE
  /// strings where necessary.
  ///
  /// @param fullName
  /// A pointer to a buffer that where the resulting full domain name is to be written.
  /// The buffer must be kDNSServiceMaxDomainName (1009) bytes in length to
  /// accommodate the longest legal domain name without buffer overrun.
  ///
  /// @param service
  /// The service name - any dots or backslashes must NOT be escaped.
  /// May be NULL (to construct a PTR record name, e.g.
  /// "_ftp._tcp.apple.com.").
  ///
  /// @param regtype
  /// The service type followed by the protocol, separated by a dot
  /// (e.g. "_ftp._tcp").
  ///
  /// @param domain
  /// The domain name, e.g. "apple.com.". Literal dots or backslashes,
  /// if any, must be escaped, e.g. "1st\. Floor.apple.com."
  ///
  /// @result:
  /// Returns kDNSServiceErr_NoError (0) on success, kDNSServiceErr_BadParam on error.
  int DNSServiceConstructFullName(
    ffi.Pointer<ffi.Char> fullName,
    ffi.Pointer<ffi.Char> service,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> domain,
  ) {
    return _DNSServiceConstructFullName(
      fullName,
      service,
      regtype,
      domain,
    );
  }

  late final _DNSServiceConstructFullNamePtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('DNSServiceConstructFullName');
  late final _DNSServiceConstructFullName =
      _DNSServiceConstructFullNamePtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// !
  /// @brief
  /// Allows you to schedule a DNSServiceRef on a serial dispatch queue for receiving asynchronous
  /// callbacks.  It's the clients responsibility to ensure that the provided dispatch queue is running.
  ///
  /// @param service
  /// DNSServiceRef that was allocated and returned to the application, when the
  /// application calls one of the DNSService API.
  ///
  /// @param queue
  /// dispatch queue where the application callback will be scheduled
  ///
  /// @result
  /// Returns kDNSServiceErr_NoError on success.
  /// Returns kDNSServiceErr_NoMemory if it cannot create a dispatch source
  /// Returns kDNSServiceErr_BadParam if the service param is invalid or the
  /// queue param is invalid
  ///
  /// @discussion
  /// A typical application that uses CFRunLoopRun or dispatch_main on its main thread will
  /// usually schedule DNSServiceRefs on its main queue (which is always a serial queue)
  /// using "DNSServiceSetDispatchQueue(sdref, dispatch_get_main_queue());"
  ///
  /// If there is any error during the processing of events, the application callback will
  /// be called with an error code. For shared connections, each subordinate DNSServiceRef
  /// will get its own error callback. Currently these error callbacks only happen
  /// if the daemon is manually terminated or crashes, and the error
  /// code in this case is kDNSServiceErr_ServiceNotRunning. The application must call
  /// DNSServiceRefDeallocate to free the DNSServiceRef when it gets such an error code.
  /// These error callbacks are rare and should not normally happen on customer machines,
  /// but application code should be written defensively to handle such error callbacks
  /// gracefully if they occur.
  ///
  /// After using DNSServiceSetDispatchQueue on a DNSServiceRef, calling DNSServiceProcessResult
  /// on the same DNSServiceRef will result in undefined behavior and should be avoided.
  ///
  /// Once the application successfully schedules a DNSServiceRef on a serial dispatch queue using
  /// DNSServiceSetDispatchQueue, it cannot remove the DNSServiceRef from the dispatch queue, or use
  /// DNSServiceSetDispatchQueue a second time to schedule the DNSServiceRef onto a different serial dispatch
  /// queue. Once scheduled onto a dispatch queue a DNSServiceRef will deliver events to that queue until
  /// the application no longer requires that operation and terminates it using DNSServiceRefDeallocate.
  /// Note that the call to DNSServiceRefDeallocate() must be done on the same queue originally passed
  /// as an argument to DNSServiceSetDispatchQueue().
  DartDNSServiceErrorType DNSServiceSetDispatchQueue(
    DNSServiceRef service,
    Dartdispatch_queue_t queue,
  ) {
    return _DNSServiceSetDispatchQueue(
      service,
      queue._id,
    );
  }

  late final _DNSServiceSetDispatchQueuePtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              DNSServiceRef, dispatch_queue_t)>>('DNSServiceSetDispatchQueue');
  late final _DNSServiceSetDispatchQueue = _DNSServiceSetDispatchQueuePtr
      .asFunction<int Function(DNSServiceRef, dispatch_queue_t)>();

  int DNSServiceSleepKeepalive(
    ffi.Pointer<DNSServiceRef> sdRef,
    int flags,
    int fd,
    int timeout,
    DNSServiceSleepKeepaliveReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceSleepKeepalive(
      sdRef,
      flags,
      fd,
      timeout,
      callBack,
      context,
    );
  }

  late final _DNSServiceSleepKeepalivePtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>,
              DNSServiceFlags,
              ffi.Int,
              ffi.UnsignedInt,
              DNSServiceSleepKeepaliveReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceSleepKeepalive');
  late final _DNSServiceSleepKeepalive =
      _DNSServiceSleepKeepalivePtr.asFunction<
          int Function(ffi.Pointer<DNSServiceRef>, int, int, int,
              DNSServiceSleepKeepaliveReply, ffi.Pointer<ffi.Void>)>();

  DNSServiceAttributeRef DNSServiceAttributeCreate() {
    return _DNSServiceAttributeCreate();
  }

  late final _DNSServiceAttributeCreatePtr =
      _lookup<ffi.NativeFunction<DNSServiceAttributeRef Function()>>(
          'DNSServiceAttributeCreate');
  late final _DNSServiceAttributeCreate = _DNSServiceAttributeCreatePtr
      .asFunction<DNSServiceAttributeRef Function()>();

  int DNSServiceAttributeSetAAAAPolicy(
    DNSServiceAttributeRef attr,
    int policy,
  ) {
    return _DNSServiceAttributeSetAAAAPolicy(
      attr,
      policy,
    );
  }

  late final _DNSServiceAttributeSetAAAAPolicyPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(DNSServiceAttributeRef,
              ffi.Int32)>>('DNSServiceAttributeSetAAAAPolicy');
  late final _DNSServiceAttributeSetAAAAPolicy =
      _DNSServiceAttributeSetAAAAPolicyPtr.asFunction<
          int Function(DNSServiceAttributeRef, int)>();

  int DNSServiceAttributeSetTimestamp(
    DNSServiceAttributeRef attr,
    int timestamp,
  ) {
    return _DNSServiceAttributeSetTimestamp(
      attr,
      timestamp,
    );
  }

  late final _DNSServiceAttributeSetTimestampPtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(DNSServiceAttributeRef,
              ffi.Uint32)>>('DNSServiceAttributeSetTimestamp');
  late final _DNSServiceAttributeSetTimestamp =
      _DNSServiceAttributeSetTimestampPtr.asFunction<
          int Function(DNSServiceAttributeRef, int)>();

  void DNSServiceAttributeDeallocate(
    DNSServiceAttributeRef attr,
  ) {
    return _DNSServiceAttributeDeallocate(
      attr,
    );
  }

  late final _DNSServiceAttributeDeallocatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(DNSServiceAttributeRef)>>(
          'DNSServiceAttributeDeallocate');
  late final _DNSServiceAttributeDeallocate = _DNSServiceAttributeDeallocatePtr
      .asFunction<void Function(DNSServiceAttributeRef)>();

  int DNSServiceQueryRecordWithAttribute(
    ffi.Pointer<DNSServiceRef> sdRef,
    int flags,
    int ifindex,
    ffi.Pointer<ffi.Char> name,
    int rrtype,
    int rrclass,
    ffi.Pointer<DNSServiceAttribute> attr,
    DNSServiceQueryRecordReply callback,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceQueryRecordWithAttribute(
      sdRef,
      flags,
      ifindex,
      name,
      rrtype,
      rrclass,
      attr,
      callback,
      context,
    );
  }

  late final _DNSServiceQueryRecordWithAttributePtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>,
              DNSServiceFlags,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Pointer<DNSServiceAttribute>,
              DNSServiceQueryRecordReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceQueryRecordWithAttribute');
  late final _DNSServiceQueryRecordWithAttribute =
      _DNSServiceQueryRecordWithAttributePtr.asFunction<
          int Function(
              ffi.Pointer<DNSServiceRef>,
              int,
              int,
              ffi.Pointer<ffi.Char>,
              int,
              int,
              ffi.Pointer<DNSServiceAttribute>,
              DNSServiceQueryRecordReply,
              ffi.Pointer<ffi.Void>)>();

  int DNSServiceRegisterWithAttribute(
    ffi.Pointer<DNSServiceRef> sdRef,
    int flags,
    int interfaceIndex,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> domain,
    ffi.Pointer<ffi.Char> host,
    int portInNetworkByteOrder,
    int txtLen,
    ffi.Pointer<ffi.Void> txtRecord,
    DNSServiceAttributeRef attr,
    DNSServiceRegisterReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceRegisterWithAttribute(
      sdRef,
      flags,
      interfaceIndex,
      name,
      regtype,
      domain,
      host,
      portInNetworkByteOrder,
      txtLen,
      txtRecord,
      attr,
      callBack,
      context,
    );
  }

  late final _DNSServiceRegisterWithAttributePtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              ffi.Pointer<DNSServiceRef>,
              DNSServiceFlags,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Pointer<ffi.Void>,
              DNSServiceAttributeRef,
              DNSServiceRegisterReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceRegisterWithAttribute');
  late final _DNSServiceRegisterWithAttribute =
      _DNSServiceRegisterWithAttributePtr.asFunction<
          int Function(
              ffi.Pointer<DNSServiceRef>,
              int,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              DNSServiceAttributeRef,
              DNSServiceRegisterReply,
              ffi.Pointer<ffi.Void>)>();

  int DNSServiceRegisterRecordWithAttribute(
    DNSServiceRef sdRef,
    ffi.Pointer<DNSRecordRef> recordRef,
    int flags,
    int interfaceIndex,
    ffi.Pointer<ffi.Char> fullname,
    int rrtype,
    int rrclass,
    int rdlen,
    ffi.Pointer<ffi.Void> rdata,
    int ttl,
    DNSServiceAttributeRef attr,
    DNSServiceRegisterRecordReply callBack,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _DNSServiceRegisterRecordWithAttribute(
      sdRef,
      recordRef,
      flags,
      interfaceIndex,
      fullname,
      rrtype,
      rrclass,
      rdlen,
      rdata,
      ttl,
      attr,
      callBack,
      context,
    );
  }

  late final _DNSServiceRegisterRecordWithAttributePtr = _lookup<
      ffi.NativeFunction<
          DNSServiceErrorType Function(
              DNSServiceRef,
              ffi.Pointer<DNSRecordRef>,
              DNSServiceFlags,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Uint16,
              ffi.Pointer<ffi.Void>,
              ffi.Uint32,
              DNSServiceAttributeRef,
              DNSServiceRegisterRecordReply,
              ffi.Pointer<ffi.Void>)>>('DNSServiceRegisterRecordWithAttribute');
  late final _DNSServiceRegisterRecordWithAttribute =
      _DNSServiceRegisterRecordWithAttributePtr.asFunction<
          int Function(
              DNSServiceRef,
              ffi.Pointer<DNSRecordRef>,
              int,
              int,
              ffi.Pointer<ffi.Char>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              DNSServiceAttributeRef,
              DNSServiceRegisterRecordReply,
              ffi.Pointer<ffi.Void>)>();

  int DNSServiceSendQueuedRequests(
    DNSServiceRef sdRef,
  ) {
    return _DNSServiceSendQueuedRequests(
      sdRef,
    );
  }

  late final _DNSServiceSendQueuedRequestsPtr =
      _lookup<ffi.NativeFunction<DNSServiceErrorType Function(DNSServiceRef)>>(
          'DNSServiceSendQueuedRequests');
  late final _DNSServiceSendQueuedRequests = _DNSServiceSendQueuedRequestsPtr
      .asFunction<int Function(DNSServiceRef)>();
}

class _ObjCWrapper implements ffi.Finalizable {
  final ffi.Pointer<ObjCObject> _id;
  final BonjourFramework _lib;
  bool _pendingRelease;

  _ObjCWrapper._(this._id, this._lib,
      {bool retain = false, bool release = false})
      : _pendingRelease = release {
    if (retain) {
      _lib._objc_retain(_id.cast());
    }
    if (release) {
      _lib._objc_releaseFinalizer2.attach(this, _id.cast(), detach: this);
    }
  }

  /// Releases the reference to the underlying ObjC object held by this wrapper.
  /// Throws a StateError if this wrapper doesn't currently hold a reference.
  void release() {
    if (_pendingRelease) {
      _pendingRelease = false;
      _lib._objc_release(_id.cast());
      _lib._objc_releaseFinalizer2.detach(this);
    } else {
      throw StateError(
          'Released an ObjC object that was unowned or already released.');
    }
  }

  @override
  bool operator ==(Object other) {
    return other is _ObjCWrapper && _id == other._id;
  }

  @override
  int get hashCode => _id.hashCode;

  /// Return a pointer to this object.
  ffi.Pointer<ObjCObject> get pointer => _id;

  ffi.Pointer<ObjCObject> _retainAndReturnId() {
    _lib._objc_retain(_id.cast());
    return _id;
  }
}

class NSObject extends _ObjCWrapper {
  NSObject._(ffi.Pointer<ObjCObject> id, BonjourFramework lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSObject] that points to the same underlying object as [other].
  static NSObject castFrom<T extends _ObjCWrapper>(T other) {
    return NSObject._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSObject] that wraps the given raw object pointer.
  static NSObject castFromPointer(
      BonjourFramework lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSObject._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSObject].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSObject1);
  }

  static void load(BonjourFramework _lib) {
    _lib._objc_msgSend_1(_lib._class_NSObject1, _lib._sel_load1);
  }

  static void initialize(BonjourFramework _lib) {
    _lib._objc_msgSend_1(_lib._class_NSObject1, _lib._sel_initialize1);
  }

  NSObject init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject new1(BonjourFramework _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_new1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject allocWithZone_(
      BonjourFramework _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_allocWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject alloc(BonjourFramework _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_alloc1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  void dealloc() {
    _lib._objc_msgSend_1(_id, _lib._sel_dealloc1);
  }

  void finalize() {
    _lib._objc_msgSend_1(_id, _lib._sel_finalize1);
  }

  NSObject copy() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_copy1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  NSObject mutableCopy() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_mutableCopy1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject copyWithZone_(
      BonjourFramework _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_copyWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject mutableCopyWithZone_(
      BonjourFramework _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_mutableCopyWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static bool instancesRespondToSelector_(
      BonjourFramework _lib, ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_4(_lib._class_NSObject1,
        _lib._sel_instancesRespondToSelector_1, aSelector);
  }

  static bool conformsToProtocol_(BonjourFramework _lib, Protocol protocol) {
    return _lib._objc_msgSend_5(
        _lib._class_NSObject1, _lib._sel_conformsToProtocol_1, protocol._id);
  }

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> methodForSelector_(
      ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_6(_id, _lib._sel_methodForSelector_1, aSelector);
  }

  static ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      instanceMethodForSelector_(
          BonjourFramework _lib, ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_6(_lib._class_NSObject1,
        _lib._sel_instanceMethodForSelector_1, aSelector);
  }

  void doesNotRecognizeSelector_(ffi.Pointer<ObjCSel> aSelector) {
    _lib._objc_msgSend_7(_id, _lib._sel_doesNotRecognizeSelector_1, aSelector);
  }

  NSObject forwardingTargetForSelector_(ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_8(
        _id, _lib._sel_forwardingTargetForSelector_1, aSelector);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  void forwardInvocation_(NSInvocation anInvocation) {
    _lib._objc_msgSend_9(_id, _lib._sel_forwardInvocation_1, anInvocation._id);
  }

  NSMethodSignature methodSignatureForSelector_(
      ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_10(
        _id, _lib._sel_methodSignatureForSelector_1, aSelector);
    return NSMethodSignature._(_ret, _lib, retain: true, release: true);
  }

  static NSMethodSignature instanceMethodSignatureForSelector_(
      BonjourFramework _lib, ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_10(_lib._class_NSObject1,
        _lib._sel_instanceMethodSignatureForSelector_1, aSelector);
    return NSMethodSignature._(_ret, _lib, retain: true, release: true);
  }

  bool allowsWeakReference() {
    return _lib._objc_msgSend_11(_id, _lib._sel_allowsWeakReference1);
  }

  bool retainWeakReference() {
    return _lib._objc_msgSend_11(_id, _lib._sel_retainWeakReference1);
  }

  static bool isSubclassOfClass_(BonjourFramework _lib, NSObject aClass) {
    return _lib._objc_msgSend_0(
        _lib._class_NSObject1, _lib._sel_isSubclassOfClass_1, aClass._id);
  }

  static bool resolveClassMethod_(
      BonjourFramework _lib, ffi.Pointer<ObjCSel> sel) {
    return _lib._objc_msgSend_4(
        _lib._class_NSObject1, _lib._sel_resolveClassMethod_1, sel);
  }

  static bool resolveInstanceMethod_(
      BonjourFramework _lib, ffi.Pointer<ObjCSel> sel) {
    return _lib._objc_msgSend_4(
        _lib._class_NSObject1, _lib._sel_resolveInstanceMethod_1, sel);
  }

  static int hash(BonjourFramework _lib) {
    return _lib._objc_msgSend_12(_lib._class_NSObject1, _lib._sel_hash1);
  }

  static NSObject superclass(BonjourFramework _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_superclass1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject class1(BonjourFramework _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_class1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSString description(BonjourFramework _lib) {
    final _ret =
        _lib._objc_msgSend_17(_lib._class_NSObject1, _lib._sel_description1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString debugDescription(BonjourFramework _lib) {
    final _ret = _lib._objc_msgSend_17(
        _lib._class_NSObject1, _lib._sel_debugDescription1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }
}

final class ObjCSel extends ffi.Opaque {}

final class ObjCObject extends ffi.Opaque {}

typedef instancetype = ffi.Pointer<ObjCObject>;
typedef Dartinstancetype = NSObject;

final class _NSZone extends ffi.Opaque {}

class Protocol extends _ObjCWrapper {
  Protocol._(ffi.Pointer<ObjCObject> id, BonjourFramework lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [Protocol] that points to the same underlying object as [other].
  static Protocol castFrom<T extends _ObjCWrapper>(T other) {
    return Protocol._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [Protocol] that wraps the given raw object pointer.
  static Protocol castFromPointer(
      BonjourFramework lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return Protocol._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [Protocol].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_Protocol1);
  }
}

class NSInvocation extends _ObjCWrapper {
  NSInvocation._(ffi.Pointer<ObjCObject> id, BonjourFramework lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSInvocation] that points to the same underlying object as [other].
  static NSInvocation castFrom<T extends _ObjCWrapper>(T other) {
    return NSInvocation._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSInvocation] that wraps the given raw object pointer.
  static NSInvocation castFromPointer(
      BonjourFramework lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSInvocation._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSInvocation].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSInvocation1);
  }
}

class NSMethodSignature extends _ObjCWrapper {
  NSMethodSignature._(ffi.Pointer<ObjCObject> id, BonjourFramework lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSMethodSignature] that points to the same underlying object as [other].
  static NSMethodSignature castFrom<T extends _ObjCWrapper>(T other) {
    return NSMethodSignature._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSMethodSignature] that wraps the given raw object pointer.
  static NSMethodSignature castFromPointer(
      BonjourFramework lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSMethodSignature._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSMethodSignature].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSMethodSignature1);
  }
}

class NSString extends _ObjCWrapper {
  NSString._(ffi.Pointer<ObjCObject> id, BonjourFramework lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSString] that points to the same underlying object as [other].
  static NSString castFrom<T extends _ObjCWrapper>(T other) {
    return NSString._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSString] that wraps the given raw object pointer.
  static NSString castFromPointer(
      BonjourFramework lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSString._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSString].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSString1);
  }

  factory NSString(BonjourFramework _lib, String str) {
    final cstr = str.toNativeUtf16();
    final nsstr = stringWithCharacters_length_(_lib, cstr.cast(), str.length);
    pkg_ffi.calloc.free(cstr);
    return nsstr;
  }

  @override
  String toString() {
    final data =
        dataUsingEncoding_(0x94000100 /* NSUTF16LittleEndianStringEncoding */);
    return data!.bytes.cast<pkg_ffi.Utf16>().toDartString(length: length);
  }

  static NSString stringWithCharacters_length_(
      BonjourFramework _lib, ffi.Pointer<ffi.WChar> characters, int length) {
    final _ret = _lib._objc_msgSend_13(_lib._class_NSString1,
        _lib._sel_stringWithCharacters_length_1, characters, length);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSData dataUsingEncoding_(int encoding) {
    final _ret =
        _lib._objc_msgSend_15(_id, _lib._sel_dataUsingEncoding_1, encoding);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  int get length {
    return _lib._objc_msgSend_16(_id, _lib._sel_length1);
  }
}

extension StringToNSString on String {
  NSString toNSString(BonjourFramework lib) => NSString(lib, this);
}

class NSData extends _ObjCWrapper {
  NSData._(ffi.Pointer<ObjCObject> id, BonjourFramework lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSData] that points to the same underlying object as [other].
  static NSData castFrom<T extends _ObjCWrapper>(T other) {
    return NSData._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSData] that wraps the given raw object pointer.
  static NSData castFromPointer(
      BonjourFramework lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSData._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSData].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSData1);
  }

  ffi.Pointer<ffi.Void> get bytes {
    return _lib._objc_msgSend_14(_id, _lib._sel_bytes1);
  }
}

typedef dispatch_time_t = ffi.Uint64;
typedef Dartdispatch_time_t = int;

final class timespec extends ffi.Struct {
  @ffi.Long()
  external int tv_sec;

  @ffi.Long()
  external int tv_nsec;
}

typedef dispatch_object_t = ffi.Pointer<ObjCObject>;
typedef Dartdispatch_object_t = NSObject;
typedef dispatch_function_t
    = ffi.Pointer<ffi.NativeFunction<dispatch_function_tFunction>>;
typedef dispatch_function_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void>);
typedef Dartdispatch_function_tFunction = void Function(ffi.Pointer<ffi.Void>);

abstract class qos_class_t {
  static const int QOS_CLASS_USER_INTERACTIVE = 33;
  static const int QOS_CLASS_USER_INITIATED = 25;
  static const int QOS_CLASS_DEFAULT = 21;
  static const int QOS_CLASS_UTILITY = 17;
  static const int QOS_CLASS_BACKGROUND = 9;
  static const int QOS_CLASS_UNSPECIFIED = 0;
}

typedef dispatch_block_t = ffi.Pointer<_ObjCBlock>;
typedef Dartdispatch_block_t = ObjCBlock_ffiVoid;

class _ObjCBlockBase implements ffi.Finalizable {
  final ffi.Pointer<_ObjCBlock> _id;
  final BonjourFramework _lib;
  bool _pendingRelease;

  _ObjCBlockBase._(this._id, this._lib,
      {bool retain = false, bool release = false})
      : _pendingRelease = release {
    if (retain) {
      _lib._Block_copy(_id.cast());
    }
    if (release) {
      _lib._objc_releaseFinalizer11.attach(this, _id.cast(), detach: this);
    }
  }

  /// Releases the reference to the underlying ObjC block held by this wrapper.
  /// Throws a StateError if this wrapper doesn't currently hold a reference.
  void release() {
    if (_pendingRelease) {
      _pendingRelease = false;
      _lib._Block_release(_id.cast());
      _lib._objc_releaseFinalizer11.detach(this);
    } else {
      throw StateError(
          'Released an ObjC block that was unowned or already released.');
    }
  }

  @override
  bool operator ==(Object other) {
    return other is _ObjCBlockBase && _id == other._id;
  }

  @override
  int get hashCode => _id.hashCode;

  /// Return a pointer to this object.
  ffi.Pointer<_ObjCBlock> get pointer => _id;

  ffi.Pointer<_ObjCBlock> _retainAndReturnId() {
    _lib._Block_copy(_id.cast());
    return _id;
  }
}

void _ObjCBlock_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<_ObjCBlock> block,
) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function()>>()
        .asFunction<void Function()>()();
final _ObjCBlock_ffiVoid_closureRegistry = <int, void Function()>{};
int _ObjCBlock_ffiVoid_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_registerClosure(void Function() fn) {
  final id = ++_ObjCBlock_ffiVoid_closureRegistryIndex;
  _ObjCBlock_ffiVoid_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock_ffiVoid_closureTrampoline(
  ffi.Pointer<_ObjCBlock> block,
) =>
    _ObjCBlock_ffiVoid_closureRegistry[block.ref.target.address]!();

class ObjCBlock_ffiVoid extends _ObjCBlockBase {
  ObjCBlock_ffiVoid._(ffi.Pointer<_ObjCBlock> id, BonjourFramework lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid.fromFunctionPointer(BonjourFramework lib,
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock>)>(
                        _ObjCBlock_ffiVoid_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid.fromFunction(BonjourFramework lib, void Function() fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock>)>(
                        _ObjCBlock_ffiVoid_closureTrampoline)
                    .cast(),
                _ObjCBlock_ffiVoid_registerClosure(() => fn())),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid.listener(BonjourFramework lib, void Function() fn)
      : this._(
            lib._newBlock1(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>)>.listener(
                        _ObjCBlock_ffiVoid_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                _ObjCBlock_ffiVoid_registerClosure(() => fn())),
            lib);
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<_ObjCBlock>)>?
      _dartFuncListenerTrampoline;

  void call() => _id.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<_ObjCBlock> block)>>()
          .asFunction<void Function(ffi.Pointer<_ObjCBlock>)>()(
        _id,
      );
}

final class _ObjCBlockDesc extends ffi.Struct {
  @ffi.UnsignedLong()
  external int reserved;

  @ffi.UnsignedLong()
  external int size;

  external ffi.Pointer<ffi.Void> copy_helper;

  external ffi.Pointer<ffi.Void> dispose_helper;

  external ffi.Pointer<ffi.Char> signature;
}

final class _ObjCBlock extends ffi.Struct {
  external ffi.Pointer<ffi.Void> isa;

  @ffi.Int()
  external int flags;

  @ffi.Int()
  external int reserved;

  external ffi.Pointer<ffi.Void> invoke;

  external ffi.Pointer<_ObjCBlockDesc> descriptor;

  external ffi.Pointer<ffi.Void> target;
}

typedef dispatch_queue_t = ffi.Pointer<ObjCObject>;
typedef Dartdispatch_queue_t = NSObject;
void _ObjCBlock_ffiVoid_ffiSize_fnPtrTrampoline(
        ffi.Pointer<_ObjCBlock> block, int arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Size arg0)>>()
        .asFunction<void Function(int)>()(arg0);
final _ObjCBlock_ffiVoid_ffiSize_closureRegistry = <int, void Function(int)>{};
int _ObjCBlock_ffiVoid_ffiSize_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiSize_registerClosure(
    void Function(int) fn) {
  final id = ++_ObjCBlock_ffiVoid_ffiSize_closureRegistryIndex;
  _ObjCBlock_ffiVoid_ffiSize_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock_ffiVoid_ffiSize_closureTrampoline(
        ffi.Pointer<_ObjCBlock> block, int arg0) =>
    _ObjCBlock_ffiVoid_ffiSize_closureRegistry[block.ref.target.address]!(arg0);

class ObjCBlock_ffiVoid_ffiSize extends _ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiSize._(ffi.Pointer<_ObjCBlock> id, BonjourFramework lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiSize.fromFunctionPointer(BonjourFramework lib,
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Size arg0)>> ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>, ffi.Size)>(
                        _ObjCBlock_ffiVoid_ffiSize_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiSize.fromFunction(
      BonjourFramework lib, void Function(int) fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>, ffi.Size)>(
                        _ObjCBlock_ffiVoid_ffiSize_closureTrampoline)
                    .cast(),
                _ObjCBlock_ffiVoid_ffiSize_registerClosure(
                    (int arg0) => fn(arg0))),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiSize.listener(
      BonjourFramework lib, void Function(int) fn)
      : this._(
            lib._newBlock1(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>, ffi.Size)>.listener(
                        _ObjCBlock_ffiVoid_ffiSize_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                _ObjCBlock_ffiVoid_ffiSize_registerClosure(
                    (int arg0) => fn(arg0))),
            lib);
  static ffi
      .NativeCallable<ffi.Void Function(ffi.Pointer<_ObjCBlock>, ffi.Size)>?
      _dartFuncListenerTrampoline;

  void call(int arg0) => _id.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<_ObjCBlock> block, ffi.Size arg0)>>()
      .asFunction<void Function(ffi.Pointer<_ObjCBlock>, int)>()(_id, arg0);
}

final class dispatch_queue_s extends ffi.Opaque {}

typedef dispatch_queue_global_t = ffi.Pointer<ObjCObject>;
typedef Dartdispatch_queue_global_t = NSObject;

final class dispatch_queue_attr_s extends ffi.Opaque {}

typedef dispatch_queue_attr_t = ffi.Pointer<ObjCObject>;
typedef Dartdispatch_queue_attr_t = NSObject;

abstract class dispatch_autorelease_frequency_t {
  static const int DISPATCH_AUTORELEASE_FREQUENCY_INHERIT = 0;
  static const int DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM = 1;
  static const int DISPATCH_AUTORELEASE_FREQUENCY_NEVER = 2;
}

abstract class dispatch_block_flags_t {
  static const int DISPATCH_BLOCK_BARRIER = 1;
  static const int DISPATCH_BLOCK_DETACHED = 2;
  static const int DISPATCH_BLOCK_ASSIGN_CURRENT = 4;
  static const int DISPATCH_BLOCK_NO_QOS_CLASS = 8;
  static const int DISPATCH_BLOCK_INHERIT_QOS_CLASS = 16;
  static const int DISPATCH_BLOCK_ENFORCE_QOS_CLASS = 32;
}

final class dispatch_source_type_s extends ffi.Opaque {}

typedef dispatch_source_t = ffi.Pointer<ObjCObject>;
typedef Dartdispatch_source_t = NSObject;
typedef dispatch_source_type_t = ffi.Pointer<dispatch_source_type_s>;
typedef dispatch_group_t = ffi.Pointer<ObjCObject>;
typedef Dartdispatch_group_t = NSObject;
typedef dispatch_semaphore_t = ffi.Pointer<ObjCObject>;
typedef Dartdispatch_semaphore_t = NSObject;
typedef dispatch_once_t = ffi.IntPtr;
typedef Dartdispatch_once_t = int;

final class dispatch_data_s extends ffi.Opaque {}

typedef dispatch_data_t = ffi.Pointer<ObjCObject>;
typedef Dartdispatch_data_t = NSObject;
typedef dispatch_data_applier_t = ffi.Pointer<_ObjCBlock>;
typedef Dartdispatch_data_applier_t
    = ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize;
bool _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_fnPtrTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        dispatch_data_t arg0,
        int arg1,
        ffi.Pointer<ffi.Void> arg2,
        int arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(dispatch_data_t arg0, ffi.Size arg1,
                    ffi.Pointer<ffi.Void> arg2, ffi.Size arg3)>>()
        .asFunction<
            bool Function(dispatch_data_t, int, ffi.Pointer<ffi.Void>,
                int)>()(arg0, arg1, arg2, arg3);
final _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureRegistry =
    <int, bool Function(dispatch_data_t, int, ffi.Pointer<ffi.Void>, int)>{};
int _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureRegistryIndex =
    0;
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_registerClosure(
        bool Function(dispatch_data_t, int, ffi.Pointer<ffi.Void>, int) fn) {
  final id =
      ++_ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureRegistryIndex;
  _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureRegistry[id] =
      fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

bool _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        dispatch_data_t arg0,
        int arg1,
        ffi.Pointer<ffi.Void> arg2,
        int arg3) =>
    _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureRegistry[
        block.ref.target.address]!(arg0, arg1, arg2, arg3);

class ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize
    extends _ObjCBlockBase {
  ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize._(
      ffi.Pointer<_ObjCBlock> id, BonjourFramework lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize.fromFunctionPointer(
      BonjourFramework lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Bool Function(dispatch_data_t arg0, ffi.Size arg1,
                      ffi.Pointer<ffi.Void> arg2, ffi.Size arg3)>>
          ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Bool Function(
                                ffi.Pointer<_ObjCBlock>,
                                dispatch_data_t,
                                ffi.Size,
                                ffi.Pointer<ffi.Void>,
                                ffi.Size)>(
                        _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_fnPtrTrampoline,
                        false)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize.fromFunction(
      BonjourFramework lib,
      bool Function(Dartdispatch_data_t, int, ffi.Pointer<ffi.Void>, int) fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Bool Function(
                                ffi.Pointer<_ObjCBlock>,
                                dispatch_data_t,
                                ffi.Size,
                                ffi.Pointer<ffi.Void>,
                                ffi.Size)>(
                        _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureTrampoline, false)
                    .cast(),
                _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_registerClosure(
                    (dispatch_data_t arg0, int arg1, ffi.Pointer<ffi.Void> arg2,
                            int arg3) =>
                        fn(NSObject._(arg0, lib, retain: true, release: true), arg1, arg2, arg3))),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  bool call(Dartdispatch_data_t arg0, int arg1, ffi.Pointer<ffi.Void> arg2,
          int arg3) =>
      _id.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<_ObjCBlock> block,
                      dispatch_data_t arg0,
                      ffi.Size arg1,
                      ffi.Pointer<ffi.Void> arg2,
                      ffi.Size arg3)>>()
          .asFunction<
              bool Function(
                  ffi.Pointer<_ObjCBlock>,
                  dispatch_data_t,
                  int,
                  ffi.Pointer<ffi.Void>,
                  int)>()(_id, arg0._id, arg1, arg2, arg3);
}

typedef dispatch_fd_t = ffi.Int;
typedef Dartdispatch_fd_t = int;
void _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_fnPtrTrampoline(
        ffi.Pointer<_ObjCBlock> block, dispatch_data_t arg0, int arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(dispatch_data_t arg0, ffi.Int arg1)>>()
        .asFunction<void Function(dispatch_data_t, int)>()(arg0, arg1);
final _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureRegistry =
    <int, void Function(dispatch_data_t, int)>{};
int _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_registerClosure(
    void Function(dispatch_data_t, int) fn) {
  final id = ++_ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureRegistryIndex;
  _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureTrampoline(
        ffi.Pointer<_ObjCBlock> block, dispatch_data_t arg0, int arg1) =>
    _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureRegistry[
        block.ref.target.address]!(arg0, arg1);

class ObjCBlock_ffiVoid_dispatchdatat_ffiInt extends _ObjCBlockBase {
  ObjCBlock_ffiVoid_dispatchdatat_ffiInt._(
      ffi.Pointer<_ObjCBlock> id, BonjourFramework lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_dispatchdatat_ffiInt.fromFunctionPointer(
      BonjourFramework lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(dispatch_data_t arg0, ffi.Int arg1)>>
          ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock>,
                                dispatch_data_t, ffi.Int)>(
                        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_dispatchdatat_ffiInt.fromFunction(
      BonjourFramework lib, void Function(Dartdispatch_data_t, int) fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock>,
                                dispatch_data_t, ffi.Int)>(
                        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureTrampoline)
                    .cast(),
                _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_registerClosure(
                    (dispatch_data_t arg0, int arg1) => fn(
                        NSObject._(arg0, lib, retain: true, release: true),
                        arg1))),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_dispatchdatat_ffiInt.listener(
      BonjourFramework lib, void Function(Dartdispatch_data_t, int) fn)
      : this._(
            lib._newBlock1(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock>,
                                dispatch_data_t, ffi.Int)>.listener(
                        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_registerClosure(
                    (dispatch_data_t arg0, int arg1) => fn(
                        NSObject._(arg0, lib, retain: true, release: true),
                        arg1))),
            lib);
  static ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<_ObjCBlock>, dispatch_data_t, ffi.Int)>?
      _dartFuncListenerTrampoline;

  void call(Dartdispatch_data_t arg0, int arg1) => _id.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                      dispatch_data_t arg0, ffi.Int arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<_ObjCBlock>, dispatch_data_t, int)>()(
      _id, arg0._id, arg1);
}

typedef dispatch_io_t = ffi.Pointer<ObjCObject>;
typedef Dartdispatch_io_t = NSObject;
typedef dispatch_io_type_t = ffi.UnsignedLong;
typedef Dartdispatch_io_type_t = int;
void _ObjCBlock_ffiVoid_ffiInt_fnPtrTrampoline(
        ffi.Pointer<_ObjCBlock> block, int arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Int arg0)>>()
        .asFunction<void Function(int)>()(arg0);
final _ObjCBlock_ffiVoid_ffiInt_closureRegistry = <int, void Function(int)>{};
int _ObjCBlock_ffiVoid_ffiInt_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiInt_registerClosure(
    void Function(int) fn) {
  final id = ++_ObjCBlock_ffiVoid_ffiInt_closureRegistryIndex;
  _ObjCBlock_ffiVoid_ffiInt_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock_ffiVoid_ffiInt_closureTrampoline(
        ffi.Pointer<_ObjCBlock> block, int arg0) =>
    _ObjCBlock_ffiVoid_ffiInt_closureRegistry[block.ref.target.address]!(arg0);

class ObjCBlock_ffiVoid_ffiInt extends _ObjCBlockBase {
  ObjCBlock_ffiVoid_ffiInt._(ffi.Pointer<_ObjCBlock> id, BonjourFramework lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiInt.fromFunctionPointer(BonjourFramework lib,
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int arg0)>> ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock>,
                            ffi.Int)>(_ObjCBlock_ffiVoid_ffiInt_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_ffiInt.fromFunction(
      BonjourFramework lib, void Function(int) fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>, ffi.Int)>(
                        _ObjCBlock_ffiVoid_ffiInt_closureTrampoline)
                    .cast(),
                _ObjCBlock_ffiVoid_ffiInt_registerClosure(
                    (int arg0) => fn(arg0))),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_ffiInt.listener(BonjourFramework lib, void Function(int) fn)
      : this._(
            lib._newBlock1(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock>, ffi.Int)>.listener(
                        _ObjCBlock_ffiVoid_ffiInt_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                _ObjCBlock_ffiVoid_ffiInt_registerClosure(
                    (int arg0) => fn(arg0))),
            lib);
  static ffi
      .NativeCallable<ffi.Void Function(ffi.Pointer<_ObjCBlock>, ffi.Int)>?
      _dartFuncListenerTrampoline;

  void call(int arg0) => _id.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<_ObjCBlock> block, ffi.Int arg0)>>()
      .asFunction<void Function(ffi.Pointer<_ObjCBlock>, int)>()(_id, arg0);
}

typedef dispatch_io_handler_t = ffi.Pointer<_ObjCBlock>;
typedef Dartdispatch_io_handler_t = ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt;
void _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_fnPtrTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        bool arg0,
        dispatch_data_t arg1,
        int arg2) =>
    block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Bool arg0, dispatch_data_t arg1, ffi.Int arg2)>>()
            .asFunction<void Function(bool, dispatch_data_t, int)>()(
        arg0, arg1, arg2);
final _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureRegistry =
    <int, void Function(bool, dispatch_data_t, int)>{};
int _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_registerClosure(
        void Function(bool, dispatch_data_t, int) fn) {
  final id =
      ++_ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureRegistryIndex;
  _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureTrampoline(
        ffi.Pointer<_ObjCBlock> block,
        bool arg0,
        dispatch_data_t arg1,
        int arg2) =>
    _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureRegistry[
        block.ref.target.address]!(arg0, arg1, arg2);

class ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt extends _ObjCBlockBase {
  ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt._(
      ffi.Pointer<_ObjCBlock> id, BonjourFramework lib,
      {bool retain = false, bool release = true})
      : super._(id, lib, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt.fromFunctionPointer(
      BonjourFramework lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Bool arg0, dispatch_data_t arg1, ffi.Int arg2)>>
          ptr)
      : this._(
            lib._newBlock1(
                _cFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock>, ffi.Bool,
                                dispatch_data_t, ffi.Int)>(
                        _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);
  static ffi.Pointer<ffi.Void>? _cFuncTrampoline;

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt.fromFunction(
      BonjourFramework lib, void Function(bool, Dartdispatch_data_t, int) fn)
      : this._(
            lib._newBlock1(
                _dartFuncTrampoline ??= ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock>, ffi.Bool,
                                dispatch_data_t, ffi.Int)>(
                        _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureTrampoline)
                    .cast(),
                _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_registerClosure(
                    (bool arg0, dispatch_data_t arg1, int arg2) => fn(
                        arg0,
                        NSObject._(arg1, lib, retain: true, release: true),
                        arg2))),
            lib);
  static ffi.Pointer<ffi.Void>? _dartFuncTrampoline;

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt.listener(
      BonjourFramework lib, void Function(bool, Dartdispatch_data_t, int) fn)
      : this._(
            lib._newBlock1(
                (_dartFuncListenerTrampoline ??= ffi.NativeCallable<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock>, ffi.Bool,
                                dispatch_data_t, ffi.Int)>.listener(
                        _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureTrampoline)
                      ..keepIsolateAlive = false)
                    .nativeFunction
                    .cast(),
                _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_registerClosure(
                    (bool arg0, dispatch_data_t arg1, int arg2) => fn(
                        arg0,
                        NSObject._(arg1, lib, retain: true, release: true),
                        arg2))),
            lib);
  static ffi.NativeCallable<
          ffi.Void Function(
              ffi.Pointer<_ObjCBlock>, ffi.Bool, dispatch_data_t, ffi.Int)>?
      _dartFuncListenerTrampoline;

  void call(bool arg0, Dartdispatch_data_t arg1, int arg2) => _id.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<_ObjCBlock> block, ffi.Bool arg0,
                  dispatch_data_t arg1, ffi.Int arg2)>>()
      .asFunction<
          void Function(ffi.Pointer<_ObjCBlock>, bool, dispatch_data_t,
              int)>()(_id, arg0, arg1._id, arg2);
}

typedef dispatch_io_close_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_io_close_flags_t = int;
typedef dispatch_io_interval_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_io_interval_flags_t = int;
typedef dispatch_workloop_t = ffi.Pointer<ObjCObject>;
typedef Dartdispatch_workloop_t = NSObject;

class OS_os_workgroup extends OS_object {
  OS_os_workgroup._(ffi.Pointer<ObjCObject> id, BonjourFramework lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [OS_os_workgroup] that points to the same underlying object as [other].
  static OS_os_workgroup castFrom<T extends _ObjCWrapper>(T other) {
    return OS_os_workgroup._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [OS_os_workgroup] that wraps the given raw object pointer.
  static OS_os_workgroup castFromPointer(
      BonjourFramework lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return OS_os_workgroup._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [OS_os_workgroup].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_OS_os_workgroup1);
  }

  @override
  OS_os_workgroup init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return OS_os_workgroup._(_ret, _lib, retain: true, release: true);
  }

  static OS_os_workgroup new1(BonjourFramework _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_OS_os_workgroup1, _lib._sel_new1);
    return OS_os_workgroup._(_ret, _lib, retain: false, release: true);
  }

  static OS_os_workgroup allocWithZone_(
      BonjourFramework _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_OS_os_workgroup1, _lib._sel_allocWithZone_1, zone);
    return OS_os_workgroup._(_ret, _lib, retain: false, release: true);
  }

  static OS_os_workgroup alloc(BonjourFramework _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_OS_os_workgroup1, _lib._sel_alloc1);
    return OS_os_workgroup._(_ret, _lib, retain: false, release: true);
  }
}

class OS_object extends NSObject {
  OS_object._(ffi.Pointer<ObjCObject> id, BonjourFramework lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [OS_object] that points to the same underlying object as [other].
  static OS_object castFrom<T extends _ObjCWrapper>(T other) {
    return OS_object._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [OS_object] that wraps the given raw object pointer.
  static OS_object castFromPointer(
      BonjourFramework lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return OS_object._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [OS_object].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_OS_object1);
  }

  @override
  OS_object init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return OS_object._(_ret, _lib, retain: true, release: true);
  }

  static OS_object new1(BonjourFramework _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_OS_object1, _lib._sel_new1);
    return OS_object._(_ret, _lib, retain: false, release: true);
  }

  static OS_object allocWithZone_(
      BonjourFramework _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_OS_object1, _lib._sel_allocWithZone_1, zone);
    return OS_object._(_ret, _lib, retain: false, release: true);
  }

  static OS_object alloc(BonjourFramework _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_OS_object1, _lib._sel_alloc1);
    return OS_object._(_ret, _lib, retain: false, release: true);
  }
}

final class DNSServiceAttribute_s extends ffi.Opaque {}

typedef DNSServiceErrorType = ffi.Int32;
typedef DartDNSServiceErrorType = int;

/// DNSServiceRef, DNSRecordRef
///
/// Opaque internal data types.
/// Note: client is responsible for serializing access to these structures if
/// they are shared between concurrent threads.
typedef DNSServiceRef = ffi.Pointer<_DNSServiceRef_t>;

final class _DNSServiceRef_t extends ffi.Opaque {}

typedef DNSServiceFlags = ffi.Uint32;
typedef DartDNSServiceFlags = int;

/// !
/// @brief
/// The definition of the DNSServiceEnumerateDomains callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceEnumerateDomains().
///
/// @param flags
/// Possible values are:
/// kDNSServiceFlagsMoreComing
/// kDNSServiceFlagsAdd
/// kDNSServiceFlagsDefault
///
/// @param interfaceIndex
/// Specifies the interface on which the domain exists. (The index for a given
/// interface is determined via the if_nametoindex() family of calls.)
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError (0) on success, otherwise indicates
/// the failure that occurred (other parameters are undefined if errorCode is nonzero).
///
/// @param replyDomain
/// The name of the domain.
///
/// @param context
/// The context pointer passed to DNSServiceEnumerateDomains.
typedef DNSServiceDomainEnumReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceDomainEnumReplyFunction>>;
typedef DNSServiceDomainEnumReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> replyDomain,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceDomainEnumReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> replyDomain,
    ffi.Pointer<ffi.Void> context);

/// !
/// @brief
/// The definition of the DNSServiceRegister callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceRegister().
///
/// @param flags
/// When a name is successfully registered, the callback will be
/// invoked with the kDNSServiceFlagsAdd flag set. When Wide-Area
/// DNS-SD is in use, it is possible for a single service to get
/// more than one success callback (e.g. one in the "local" multicast
/// DNS domain, and another in a wide-area unicast DNS domain).
/// If a successfully-registered name later suffers a name conflict
/// or similar problem and has to be deregistered, the callback will
/// be invoked with the kDNSServiceFlagsAdd flag not set. The callback
/// is *not* invoked in the case where the caller explicitly terminates
/// the service registration by calling DNSServiceRefDeallocate(ref);
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError on success, otherwise will
/// indicate the failure that occurred (including name conflicts,
/// if the kDNSServiceFlagsNoAutoRename flag was used when registering.)
/// Other parameters are undefined if errorCode is nonzero.
///
/// @param name
/// The service name registered (if the application did not specify a name in
/// DNSServiceRegister(), this indicates what name was automatically chosen).
///
/// @param regtype
/// The type of service registered, as it was passed to the callout.
///
/// @param domain
/// The domain on which the service was registered (if the application did not
/// specify a domain in DNSServiceRegister(), this indicates the default domain
/// on which the service was registered).
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceRegisterReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceRegisterReplyFunction>>;
typedef DNSServiceRegisterReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> domain,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceRegisterReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> domain,
    ffi.Pointer<ffi.Void> context);
typedef DNSRecordRef = ffi.Pointer<_DNSRecordRef_t>;

final class _DNSRecordRef_t extends ffi.Opaque {}

typedef DNSServiceAttributeRef = ffi.Pointer<DNSServiceAttribute>;
typedef DNSServiceAttribute = DNSServiceAttribute_s;

/// !
/// @brief
/// The definition of the DNSServiceBrowse callback function
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceBrowse().
///
/// @param flags
/// Possible values are kDNSServiceFlagsMoreComing and kDNSServiceFlagsAdd.
/// See flag definitions for details.
///
/// @param interfaceIndex
/// The interface on which the service is advertised. This index should
/// be passed to DNSServiceResolve() when resolving the service.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError (0) on success, otherwise will
/// indicate the failure that occurred. Other parameters are undefined if
/// the errorCode is nonzero.
///
/// @param serviceName
/// The discovered service name. This name should be displayed to the user,
/// and stored for subsequent use in the DNSServiceResolve() call.
///
/// @param regtype
/// The service type, which is usually (but not always) the same as was passed
/// to DNSServiceBrowse(). One case where the discovered service type may
/// not be the same as the requested service type is when using subtypes:
/// The client may want to browse for only those ftp servers that allow
/// anonymous connections. The client will pass the string "_ftp._tcp,_anon"
/// to DNSServiceBrowse(), but the type of the service that's discovered
/// is simply "_ftp._tcp". The regtype for each discovered service instance
/// should be stored along with the name, so that it can be passed to
/// DNSServiceResolve() when the service is later resolved.
///
/// @param replyDomain
/// The domain of the discovered service instance. This may or may not be the
/// same as the domain that was passed to DNSServiceBrowse(). The domain for each
/// discovered service instance should be stored along with the name, so that
/// it can be passed to DNSServiceResolve() when the service is later resolved.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceBrowseReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceBrowseReplyFunction>>;
typedef DNSServiceBrowseReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> serviceName,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> replyDomain,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceBrowseReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> serviceName,
    ffi.Pointer<ffi.Char> regtype,
    ffi.Pointer<ffi.Char> replyDomain,
    ffi.Pointer<ffi.Void> context);

/// !
/// @brief
/// The definition of the DNSServiceResolve callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceResolve().
///
/// @param flags
/// Possible values: kDNSServiceFlagsMoreComing
///
/// @param interfaceIndex
/// The interface on which the service was resolved.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError (0) on success, otherwise will
/// indicate the failure that occurred. Other parameters are undefined if
/// the errorCode is nonzero.
///
/// @param fullname
/// The full service domain name, in the form <servicename>.<protocol>.<domain>.
/// (This name is escaped following standard DNS rules, making it suitable for
/// passing to standard system DNS APIs such as res_query(), or to the
/// special-purpose functions included in this API that take fullname parameters.
/// See "Notes on DNS Name Escaping" earlier in this file for more details.)
///
/// @param hosttarget
/// The target hostname of the machine providing the service. This name can
/// be passed to functions like gethostbyname() to identify the host's IP address.
///
/// @param port
/// The port, in network byte order, on which connections are accepted for this service.
///
/// @param txtLen
/// The length of the txt record, in bytes.
///
/// @param txtRecord
/// The service's primary txt record, in standard txt record format.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceResolveReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceResolveReplyFunction>>;
typedef DNSServiceResolveReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> fullname,
    ffi.Pointer<ffi.Char> hosttarget,
    ffi.Uint16 port,
    ffi.Uint16 txtLen,
    ffi.Pointer<ffi.UnsignedChar> txtRecord,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceResolveReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> fullname,
    ffi.Pointer<ffi.Char> hosttarget,
    int port,
    int txtLen,
    ffi.Pointer<ffi.UnsignedChar> txtRecord,
    ffi.Pointer<ffi.Void> context);

/// !
/// @brief
/// The definition of the DNSServiceQueryRecord callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceQueryRecord().
///
/// @param flags
/// Possible values are kDNSServiceFlagsMoreComing and
/// kDNSServiceFlagsAdd. The Add flag is NOT set for PTR records
/// with a ttl of 0, i.e. "Remove" events.
///
/// @param interfaceIndex
/// The interface on which the query was resolved (the index for a given
/// interface is determined via the if_nametoindex() family of calls).
/// See "Constants for specifying an interface index" for more details.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError on success, otherwise will
/// indicate the failure that occurred. Other parameters are undefined if
/// errorCode is nonzero.
///
/// @param fullname
/// The resource record's full domain name.
///
/// @param rrtype
/// The resource record's type (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
///
/// @param rrclass
/// The class of the resource record (usually kDNSServiceClass_IN).
///
/// @param rdlen
/// The length, in bytes, of the resource record rdata.
///
/// @param rdata
/// The raw rdata of the resource record.
///
/// @param ttl
/// If the client wishes to cache the result for performance reasons,
/// the TTL indicates how long the client may legitimately hold onto
/// this result, in seconds. After the TTL expires, the client should
/// consider the result no longer valid, and if it requires this data
/// again, it should be re-fetched with a new query. Of course, this
/// only applies to clients that cancel the asynchronous operation when
/// they get a result. Clients that leave the asynchronous operation
/// running can safely assume that the data remains valid until they
/// get another callback telling them otherwise. The ttl value is not
/// updated when the daemon answers from the cache, hence relying on
/// the accuracy of the ttl value is not recommended.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceQueryRecordReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceQueryRecordReplyFunction>>;
typedef DNSServiceQueryRecordReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> fullname,
    ffi.Uint16 rrtype,
    ffi.Uint16 rrclass,
    ffi.Uint16 rdlen,
    ffi.Pointer<ffi.Void> rdata,
    ffi.Uint32 ttl,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceQueryRecordReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> fullname,
    int rrtype,
    int rrclass,
    int rdlen,
    ffi.Pointer<ffi.Void> rdata,
    int ttl,
    ffi.Pointer<ffi.Void> context);
typedef DNSServiceProtocol = ffi.Uint32;
typedef DartDNSServiceProtocol = int;

/// !
/// @brief
/// The definition of the DNSServiceGetAddrInfo callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceGetAddrInfo().
///
/// @param flags
/// Possible values are kDNSServiceFlagsMoreComing and
/// kDNSServiceFlagsAdd.
///
/// @param interfaceIndex
/// The interface to which the answers pertain.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError on success, otherwise will
/// indicate the failure that occurred.  Other parameters are
/// undefined if errorCode is nonzero.
///
/// @param hostname
/// The fully qualified domain name of the host to be queried for.
///
/// @param address
/// IPv4 or IPv6 address.
///
/// @param ttl
/// If the client wishes to cache the result for performance reasons,
/// the TTL indicates how long the client may legitimately hold onto
/// this result, in seconds. After the TTL expires, the client should
/// consider the result no longer valid, and if it requires this data
/// again, it should be re-fetched with a new query. Of course, this
/// only applies to clients that cancel the asynchronous operation when
/// they get a result. Clients that leave the asynchronous operation
/// running can safely assume that the data remains valid until they
/// get another callback telling them otherwise. The ttl value is not
/// updated when the daemon answers from the cache, hence relying on
/// the accuracy of the ttl value is not recommended.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceGetAddrInfoReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceGetAddrInfoReplyFunction>>;
typedef DNSServiceGetAddrInfoReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> hostname,
    ffi.Pointer<sockaddr> address,
    ffi.Uint32 ttl,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceGetAddrInfoReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Char> hostname,
    ffi.Pointer<sockaddr> address,
    int ttl,
    ffi.Pointer<ffi.Void> context);

final class sockaddr extends ffi.Opaque {}

/// !
/// @brief
/// The definition of the DNSServiceRegisterRecord callback function.
///
/// @param sdRef
/// The connected DNSServiceRef initialized by
/// DNSServiceCreateConnection().
///
/// @param RecordRef
/// The DNSRecordRef initialized by DNSServiceRegisterRecord(). If the above
/// DNSServiceRef is passed to DNSServiceRefDeallocate(), this DNSRecordRef is
/// invalidated, and may not be used further.
///
/// @param flags
/// Currently unused, reserved for future use.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError on success, otherwise will
/// indicate the failure that occurred (including name conflicts.)
/// Other parameters are undefined if errorCode is nonzero.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceRegisterRecordReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceRegisterRecordReplyFunction>>;
typedef DNSServiceRegisterRecordReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSRecordRef RecordRef,
    DNSServiceFlags flags,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceRegisterRecordReplyFunction = void Function(
    DNSServiceRef sdRef,
    DNSRecordRef RecordRef,
    DartDNSServiceFlags flags,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Void> context);

/// !
/// @brief
/// The definition of the DNSServiceNATPortMappingCreate callback function.
///
/// @param sdRef
/// The DNSServiceRef initialized by DNSServiceNATPortMappingCreate().
///
/// @param flags
/// Currently unused, reserved for future use.
///
/// @param interfaceIndex
/// The interface through which the NAT gateway is reached.
///
/// @param errorCode
/// Will be kDNSServiceErr_NoError on success.
/// Will be kDNSServiceErr_DoubleNAT when the NAT gateway is itself behind one or
/// more layers of NAT, in which case the other parameters have the defined values.
/// For other failures, will indicate the failure that occurred, and the other
/// parameters are undefined.
///
/// @param externalAddress
/// Four byte IPv4 address in network byte order.
///
/// @param protocol
/// Will be kDNSServiceProtocol_UDP or kDNSServiceProtocol_TCP or both.
///
/// @param internalPort
/// The port on the local machine that was mapped.
///
/// @param externalPort
/// The actual external port in the NAT gateway that was mapped.
/// This is likely to be different than the requested external port.
///
/// @param ttl
/// The lifetime of the NAT port mapping created on the gateway.
/// This controls how quickly stale mappings will be garbage-collected
/// if the client machine crashes, suffers a power failure, is disconnected
/// from the network, or suffers some other unfortunate demise which
/// causes it to vanish without explicitly removing its NAT port mapping.
/// It's possible that the ttl value will differ from the requested ttl value.
///
/// @param context
/// The context pointer that was passed to the callout.
typedef DNSServiceNATPortMappingReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceNATPortMappingReplyFunction>>;
typedef DNSServiceNATPortMappingReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceFlags flags,
    ffi.Uint32 interfaceIndex,
    DNSServiceErrorType errorCode,
    ffi.Uint32 externalAddress,
    DNSServiceProtocol protocol,
    ffi.Uint16 internalPort,
    ffi.Uint16 externalPort,
    ffi.Uint32 ttl,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceNATPortMappingReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceFlags flags,
    int interfaceIndex,
    DartDNSServiceErrorType errorCode,
    int externalAddress,
    DartDNSServiceProtocol protocol,
    int internalPort,
    int externalPort,
    int ttl,
    ffi.Pointer<ffi.Void> context);
typedef DNSServiceSleepKeepaliveReply
    = ffi.Pointer<ffi.NativeFunction<DNSServiceSleepKeepaliveReplyFunction>>;
typedef DNSServiceSleepKeepaliveReplyFunction = ffi.Void Function(
    DNSServiceRef sdRef,
    DNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Void> context);
typedef DartDNSServiceSleepKeepaliveReplyFunction = void Function(
    DNSServiceRef sdRef,
    DartDNSServiceErrorType errorCode,
    ffi.Pointer<ffi.Void> context);

abstract class DNSServiceAAAAPolicy {
  static const int kDNSServiceAAAAPolicyNone = 0;

  /// If AAAA record doesn't exist, query for A.
  static const int kDNSServiceAAAAPolicyFallback = 1;
}

const int kDNSServiceFlagsMoreComing = 1;

const int kDNSServiceFlagsQueueRequest = 1;

const int kDNSServiceFlagsAutoTrigger = 1;

const int kDNSServiceFlagsAdd = 2;

const int kDNSServiceFlagsDefault = 4;

const int kDNSServiceFlagsNoAutoRename = 8;

const int kDNSServiceFlagsShared = 16;

const int kDNSServiceFlagsUnique = 32;

const int kDNSServiceFlagsBrowseDomains = 64;

const int kDNSServiceFlagsRegistrationDomains = 128;

const int kDNSServiceFlagsLongLivedQuery = 256;

const int kDNSServiceFlagsAllowRemoteQuery = 512;

const int kDNSServiceFlagsForceMulticast = 1024;

const int kDNSServiceFlagsForce = 2048;

const int kDNSServiceFlagsKnownUnique = 2048;

const int kDNSServiceFlagsReturnIntermediates = 4096;

const int kDNSServiceFlagsShareConnection = 16384;

const int kDNSServiceFlagsSuppressUnusable = 32768;

const int kDNSServiceFlagsTimeout = 65536;

const int kDNSServiceFlagsIncludeP2P = 131072;

const int kDNSServiceFlagsWakeOnResolve = 262144;

const int kDNSServiceFlagsBackgroundTrafficClass = 524288;

const int kDNSServiceFlagsIncludeAWDL = 1048576;

const int kDNSServiceFlagsEnableDNSSEC = 2097152;

const int kDNSServiceFlagsValidate = 2097152;

const int kDNSServiceFlagsSecure = 2097168;

const int kDNSServiceFlagsInsecure = 2097184;

const int kDNSServiceFlagsBogus = 2097216;

const int kDNSServiceFlagsIndeterminate = 2097280;

const int kDNSServiceFlagsUnicastResponse = 4194304;

const int kDNSServiceFlagsValidateOptional = 8388608;

const int kDNSServiceFlagsWakeOnlyService = 16777216;

const int kDNSServiceFlagsThresholdOne = 33554432;

const int kDNSServiceFlagsThresholdFinder = 67108864;

const int kDNSServiceFlagsThresholdReached = 33554432;

const int kDNSServiceFlagsPrivateOne = 8192;

const int kDNSServiceFlagsPrivateTwo = 134217728;

const int kDNSServiceFlagsPrivateThree = 268435456;

const int kDNSServiceFlagsPrivateFour = 536870912;

const int kDNSServiceFlagsPrivateFive = 1073741824;

const int kDNSServiceFlagAnsweredFromCache = 1073741824;

const int kDNSServiceFlagsAllowExpiredAnswers = -2147483648;

const int kDNSServiceFlagsExpiredAnswer = -2147483648;

const int kDNSServiceProtocol_IPv4 = 1;

const int kDNSServiceProtocol_IPv6 = 2;

const int kDNSServiceProtocol_UDP = 16;

const int kDNSServiceProtocol_TCP = 32;

const int kDNSServiceClass_IN = 1;

const int kDNSServiceType_A = 1;

const int kDNSServiceType_NS = 2;

const int kDNSServiceType_MD = 3;

const int kDNSServiceType_MF = 4;

const int kDNSServiceType_CNAME = 5;

const int kDNSServiceType_SOA = 6;

const int kDNSServiceType_MB = 7;

const int kDNSServiceType_MG = 8;

const int kDNSServiceType_MR = 9;

const int kDNSServiceType_NULL = 10;

const int kDNSServiceType_WKS = 11;

const int kDNSServiceType_PTR = 12;

const int kDNSServiceType_HINFO = 13;

const int kDNSServiceType_MINFO = 14;

const int kDNSServiceType_MX = 15;

const int kDNSServiceType_TXT = 16;

const int kDNSServiceType_RP = 17;

const int kDNSServiceType_AFSDB = 18;

const int kDNSServiceType_X25 = 19;

const int kDNSServiceType_ISDN = 20;

const int kDNSServiceType_RT = 21;

const int kDNSServiceType_NSAP = 22;

const int kDNSServiceType_NSAP_PTR = 23;

const int kDNSServiceType_SIG = 24;

const int kDNSServiceType_KEY = 25;

const int kDNSServiceType_PX = 26;

const int kDNSServiceType_GPOS = 27;

const int kDNSServiceType_AAAA = 28;

const int kDNSServiceType_LOC = 29;

const int kDNSServiceType_NXT = 30;

const int kDNSServiceType_EID = 31;

const int kDNSServiceType_NIMLOC = 32;

const int kDNSServiceType_SRV = 33;

const int kDNSServiceType_ATMA = 34;

const int kDNSServiceType_NAPTR = 35;

const int kDNSServiceType_KX = 36;

const int kDNSServiceType_CERT = 37;

const int kDNSServiceType_A6 = 38;

const int kDNSServiceType_DNAME = 39;

const int kDNSServiceType_SINK = 40;

const int kDNSServiceType_OPT = 41;

const int kDNSServiceType_APL = 42;

const int kDNSServiceType_DS = 43;

const int kDNSServiceType_SSHFP = 44;

const int kDNSServiceType_IPSECKEY = 45;

const int kDNSServiceType_RRSIG = 46;

const int kDNSServiceType_NSEC = 47;

const int kDNSServiceType_DNSKEY = 48;

const int kDNSServiceType_DHCID = 49;

const int kDNSServiceType_NSEC3 = 50;

const int kDNSServiceType_NSEC3PARAM = 51;

const int kDNSServiceType_HIP = 55;

const int kDNSServiceType_SVCB = 64;

const int kDNSServiceType_HTTPS = 65;

const int kDNSServiceType_SPF = 99;

const int kDNSServiceType_UINFO = 100;

const int kDNSServiceType_UID = 101;

const int kDNSServiceType_GID = 102;

const int kDNSServiceType_UNSPEC = 103;

const int kDNSServiceType_TKEY = 249;

const int kDNSServiceType_TSIG = 250;

const int kDNSServiceType_IXFR = 251;

const int kDNSServiceType_AXFR = 252;

const int kDNSServiceType_MAILB = 253;

const int kDNSServiceType_MAILA = 254;

const int kDNSServiceType_ANY = 255;

const int kDNSServiceErr_NoError = 0;

const int kDNSServiceErr_Unknown = -65537;

const int kDNSServiceErr_NoSuchName = -65538;

const int kDNSServiceErr_NoMemory = -65539;

const int kDNSServiceErr_BadParam = -65540;

const int kDNSServiceErr_BadReference = -65541;

const int kDNSServiceErr_BadState = -65542;

const int kDNSServiceErr_BadFlags = -65543;

const int kDNSServiceErr_Unsupported = -65544;

const int kDNSServiceErr_NotInitialized = -65545;

const int kDNSServiceErr_AlreadyRegistered = -65547;

const int kDNSServiceErr_NameConflict = -65548;

const int kDNSServiceErr_Invalid = -65549;

const int kDNSServiceErr_Firewall = -65550;

const int kDNSServiceErr_Incompatible = -65551;

const int kDNSServiceErr_BadInterfaceIndex = -65552;

const int kDNSServiceErr_Refused = -65553;

const int kDNSServiceErr_NoSuchRecord = -65554;

const int kDNSServiceErr_NoAuth = -65555;

const int kDNSServiceErr_NoSuchKey = -65556;

const int kDNSServiceErr_NATTraversal = -65557;

const int kDNSServiceErr_DoubleNAT = -65558;

const int kDNSServiceErr_BadTime = -65559;

const int kDNSServiceErr_BadSig = -65560;

const int kDNSServiceErr_BadKey = -65561;

const int kDNSServiceErr_Transient = -65562;

const int kDNSServiceErr_ServiceNotRunning = -65563;

const int kDNSServiceErr_NATPortMappingUnsupported = -65564;

const int kDNSServiceErr_NATPortMappingDisabled = -65565;

const int kDNSServiceErr_NoRouter = -65566;

const int kDNSServiceErr_PollingMode = -65567;

const int kDNSServiceErr_Timeout = -65568;

const int kDNSServiceErr_DefunctConnection = -65569;

const int kDNSServiceErr_PolicyDenied = -65570;

const int kDNSServiceErr_NotPermitted = -65571;
