// Generated by Celest. This file should not be modified manually, but
// it can be checked into version control.
// ignore_for_file: type=lint, unused_local_variable, unnecessary_cast, unnecessary_import, deprecated_member_use, invalid_use_of_internal_member

library; // ignore_for_file: no_leading_underscores_for_library_prefixes

import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';

import 'package:_common/_common.dart' as _$_common__common;
import 'package:api_client/api_client.dart';
import 'package:celest/celest.dart' as _$celest;
import 'package:celest_backend/exceptions/demo.dart';
import 'package:celest_backend/exceptions/exceptions.dart';
import 'package:celest_backend/exceptions/overrides.dart';
import 'package:celest_backend/models/classes.dart';
import 'package:celest_backend/models/cycles.dart';
import 'package:celest_backend/models/demo.dart';
import 'package:celest_backend/models/exceptions.dart';
import 'package:celest_backend/models/extension_types.dart';
import 'package:celest_backend/models/generic_wrappers.dart';
import 'package:celest_backend/models/metadata.dart';
import 'package:celest_backend/models/overrides.dart';
import 'package:celest_backend/models/parameter_types.dart';
import 'package:celest_backend/models/records.dart';
import 'package:celest_backend/models/sealed_classes.dart';
import 'package:celest_backend/models/typedefs.dart';
import 'package:celest_backend/src/functions/metadata.dart';
import 'package:celest_core/celest_core.dart' as _$celest;
import 'package:celest_core/src/exception/cloud_exception.dart' as _$celest;
import 'package:celest_core/src/exception/serialization_exception.dart'
    as _$celest;
import 'package:celest_core/src/serialization/json_value.dart' as _$celest;
import 'package:fast_immutable_collections/src/ilist/ilist.dart'
    as _$fast_immutable_collections_ilist;
import 'package:fast_immutable_collections/src/imap/imap.dart'
    as _$fast_immutable_collections_imap;

class CelestFunctions {
  final asserts = CelestFunctionsAsserts();

  /// Tests that classes with and without explicit fromJson/toJson methods are
  /// serializable and deserializable.
  final classes = CelestFunctionsClasses();

  /// Tests that collections (e.g. Lists/Maps) can be used as parameter and
  /// return types.
  final collections = CelestFunctionsCollections();

  /// Tests that some cycles are allowed, e.g. when there is at least one level
  /// of indirection.
  final cycles = CelestFunctionsCycles();

  final demo = CelestFunctionsDemo();

  final exceptions = CelestFunctionsExceptions();

  /// Tests that extension types are correctly handled by the analyzer.
  final extensionTypes = CelestFunctionsExtensionTypes();

  /// Tests that classes which wrap generic types are generated correctly when
  /// those generic types follow the specifications of `json_serializable`, e.g.
  /// having a `toJson` method with function parameters for mapping the
  /// underlying types to JSON (Object Function(T) toJsonT).
  final genericWrappers = CelestFunctionsGenericWrappers();

  /// Tests that metadata associated with functions and parameters are correctly
  /// parsed and transferred to the generated client.
  final metadata = CelestFunctionsMetadata();

  /// Tests that types can be recursively overriden in the serialization protocol
  /// using extension types.
  final overrides = CelestFunctionsOverrides();

  final parameterTypes = CelestFunctionsParameterTypes();

  final parameters = CelestFunctionsParameters();

  /// Tests that records with and without aliases are serializable and
  /// deserializable.
  final records = CelestFunctionsRecords();

  /// Validates all permutations of return types.
  final returnTypes = CelestFunctionsReturnTypes();

  final sealedClasses = CelestFunctionsSealedClasses();

  /// Checks that typedefs work as expected.
  final typedefs = CelestFunctionsTypedefs();
}

class CelestFunctionsAsserts {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  /// Tests that asserts are enabled when running the local API.
  @_$celest.CloudFunction(
    api: 'asserts',
    function: 'assertsEnabled',
  )
  Future<bool> assertsEnabled() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/asserts/asserts-enabled'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as bool);
  }
}

/// Tests that classes with and without explicit fromJson/toJson methods are
/// serializable and deserializable.
class CelestFunctionsClasses {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'empty',
  )
  Future<Empty> empty(Empty value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/empty'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'value': _$celest.Serializers.instance.serialize<Empty>(value)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Empty>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncEmpty',
  )
  Future<Empty> asyncEmpty(Empty value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-empty'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'value': _$celest.Serializers.instance.serialize<Empty>(value)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Empty>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'fields',
  )
  Future<Fields> fields(Fields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'value': _$celest.Serializers.instance.serialize<Fields>(value)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Fields>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncFields',
  )
  Future<Fields> asyncFields(Fields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'value': _$celest.Serializers.instance.serialize<Fields>(value)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Fields>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'nullableFields',
  )
  Future<Fields?> nullableFields(Fields? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/nullable-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'value': _$celest.Serializers.instance.serialize<Fields?>(value)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Fields?>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncNullableFields',
  )
  Future<Fields?> asyncNullableFields(Fields? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-nullable-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'value': _$celest.Serializers.instance.serialize<Fields?>(value)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Fields?>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'namedFields',
  )
  Future<NamedFields> namedFields(NamedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/named-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<NamedFields>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NamedFields>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncNamedFields',
  )
  Future<NamedFields> asyncNamedFields(NamedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-named-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<NamedFields>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NamedFields>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'mixedFields',
  )
  Future<MixedFields> mixedFields(MixedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/mixed-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<MixedFields>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<MixedFields>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncMixedFields',
  )
  Future<MixedFields> asyncMixedFields(MixedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-mixed-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<MixedFields>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<MixedFields>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'defaultValues',
  )
  Future<DefaultValues> defaultValues(DefaultValues value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/default-values'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<DefaultValues>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<DefaultValues>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncDefaultValues',
  )
  Future<DefaultValues> asyncDefaultValues(DefaultValues value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-default-values'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<DefaultValues>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<DefaultValues>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'nestedClass',
  )
  Future<NestedClass> nestedClass(NestedClass value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/nested-class'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<NestedClass>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NestedClass>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncNestedClass',
  )
  Future<NestedClass> asyncNestedClass(NestedClass value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-nested-class'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<NestedClass>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NestedClass>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'onlyFromJson',
  )
  Future<OnlyFromJson> onlyFromJson(OnlyFromJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/only-from-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<OnlyFromJson>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<OnlyFromJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncOnlyFromJson',
  )
  Future<OnlyFromJson> asyncOnlyFromJson(OnlyFromJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-only-from-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<OnlyFromJson>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<OnlyFromJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'onlyToJson',
  )
  Future<OnlyToJson> onlyToJson(OnlyToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/only-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<OnlyToJson>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<OnlyToJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncOnlyToJson',
  )
  Future<OnlyToJson> asyncOnlyToJson(OnlyToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-only-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<OnlyToJson>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<OnlyToJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'onlyToJsonWithDefaults',
  )
  Future<OnlyToJsonWithDefaults> onlyToJsonWithDefaults(
      OnlyToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/only-to-json-with-defaults'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance
            .serialize<OnlyToJsonWithDefaults>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<OnlyToJsonWithDefaults>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncOnlyToJsonWithDefaults',
  )
  Future<OnlyToJsonWithDefaults> asyncOnlyToJsonWithDefaults(
      OnlyToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-only-to-json-with-defaults'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance
            .serialize<OnlyToJsonWithDefaults>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<OnlyToJsonWithDefaults>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'fromAndToJson',
  )
  Future<FromJsonAndToJson> fromAndToJson(FromJsonAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/from-and-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value':
            _$celest.Serializers.instance.serialize<FromJsonAndToJson>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<FromJsonAndToJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncFromAndToJson',
  )
  Future<FromJsonAndToJson> asyncFromAndToJson(FromJsonAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-from-and-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value':
            _$celest.Serializers.instance.serialize<FromJsonAndToJson>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<FromJsonAndToJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'nonMapToJson',
  )
  Future<NonMapToJson> nonMapToJson(NonMapToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/non-map-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<NonMapToJson>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NonMapToJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncNonMapToJson',
  )
  Future<NonMapToJson> asyncNonMapToJson(NonMapToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-non-map-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<NonMapToJson>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NonMapToJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'nonMapToJsonWithDefaults',
  )
  Future<NonMapToJsonWithDefaults> nonMapToJsonWithDefaults(
      NonMapToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/non-map-to-json-with-defaults'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance
            .serialize<NonMapToJsonWithDefaults>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<NonMapToJsonWithDefaults>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncNonMapToJsonWithDefaults',
  )
  Future<NonMapToJsonWithDefaults> asyncNonMapToJsonWithDefaults(
      NonMapToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-non-map-to-json-with-defaults'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance
            .serialize<NonMapToJsonWithDefaults>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<NonMapToJsonWithDefaults>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'nonMapFromAndToJson',
  )
  Future<NonMapFromAndToJson> nonMapFromAndToJson(
      NonMapFromAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/non-map-from-and-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value':
            _$celest.Serializers.instance.serialize<NonMapFromAndToJson>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<NonMapFromAndToJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'asyncNonMapFromAndToJson',
  )
  Future<NonMapFromAndToJson> asyncNonMapFromAndToJson(
      NonMapFromAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-non-map-from-and-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value':
            _$celest.Serializers.instance.serialize<NonMapFromAndToJson>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<NonMapFromAndToJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'classes',
    function: 'fromJsonStatic',
  )
  Future<FromJsonStatic> fromJsonStatic(FromJsonStatic value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/from-json-static'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<FromJsonStatic>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<FromJsonStatic>($body);
  }
}

/// Tests that collections (e.g. Lists/Maps) can be used as parameter and
/// return types.
class CelestFunctionsCollections {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'collections',
    function: 'simpleList',
  )
  Future<List<String>> simpleList(List<String> list) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/simple-list'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({r'list': list}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>).map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'collections',
    function: 'complexList',
  )
  Future<List<SimpleClass>> complexList(List<SimpleClass> list) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/complex-list'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'list': list
            .map((el) =>
                _$celest.Serializers.instance.serialize<SimpleClass>(el))
            .toList()
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) => _$celest.Serializers.instance.deserialize<SimpleClass>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'collections',
    function: 'simpleMap',
  )
  Future<Map<String, String>> simpleMap(Map<String, String> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/simple-map'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({r'map': map}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  @_$celest.CloudFunction(
    api: 'collections',
    function: 'dynamicMap',
  )
  Future<Map<String, dynamic>> dynamicMap(Map<String, dynamic> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/dynamic-map'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({r'map': map}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>);
  }

  @_$celest.CloudFunction(
    api: 'collections',
    function: 'objectMap',
  )
  Future<Map<String, Object>> objectMap(Map<String, Object> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/object-map'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({r'map': map}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          value!,
        ));
  }

  @_$celest.CloudFunction(
    api: 'collections',
    function: 'objectNullableMap',
  )
  Future<Map<String, Object?>> objectNullableMap(
      Map<String, Object?> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/object-nullable-map'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({r'map': map}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>);
  }

  @_$celest.CloudFunction(
    api: 'collections',
    function: 'complexMap',
  )
  Future<Map<String, SimpleClass>> complexMap(
      Map<String, SimpleClass> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/complex-map'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'map': map.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<SimpleClass>(value),
            ))
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          _$celest.Serializers.instance.deserialize<SimpleClass>(value),
        ));
  }
}

/// Tests that some cycles are allowed, e.g. when there is at least one level
/// of indirection.
class CelestFunctionsCycles {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'cycles',
    function: 'createTree',
  )
  Future<Node> createTree() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/create-tree'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Node>($body);
  }

  @_$celest.CloudFunction(
    api: 'cycles',
    function: 'printTree',
  )
  Future<void> printTree(Node node) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/print-tree'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'node': _$celest.Serializers.instance.serialize<Node>(node)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'cycles',
    function: 'combineTrees',
  )
  Future<Node> combineTrees(
    Node tree1, [
    Parent? tree2,
    Node? tree3,
    List<Node?> additionalChildren = const [],
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/combine-trees'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'tree1': _$celest.Serializers.instance.serialize<Node>(tree1),
        r'tree2': _$celest.Serializers.instance.serialize<Parent?>(tree2),
        r'tree3': _$celest.Serializers.instance.serialize<Node?>(tree3),
        r'additionalChildren': additionalChildren
            .map((el) => _$celest.Serializers.instance.serialize<Node?>(el))
            .toList(),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Node>($body);
  }

  /// Tests that self-referencing is allowed when there is a level
  /// of indirection, e.g. nullability, generics, or a wrapper.
  @_$celest.CloudFunction(
    api: 'cycles',
    function: 'selfReferencing',
  )
  Future<SelfReferencing> selfReferencing(
      SelfReferencing selfReferencing) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/self-referencing'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'selfReferencing': _$celest.Serializers.instance
            .serialize<SelfReferencing>(selfReferencing)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SelfReferencing>($body);
  }
}

class CelestFunctionsDemo {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      case 'api.v1.BadNameException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<BadNameException>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  /// Says hello to a [person].
  @_$celest.CloudFunction(
    api: 'demo',
    function: 'sayHello',
  )
  Future<String> sayHello({required Person person}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/demo/say-hello'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'person': _$celest.Serializers.instance.serialize<Person>(person)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as String);
  }
}

class CelestFunctionsExceptions {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      case 'api.v1.CustomException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<CustomException>(errorValue),
          stackTrace,
        );
      case 'api.v1.CustomExceptionToFromJson':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<CustomExceptionToFromJson>(errorValue),
          stackTrace,
        );
      case 'api.v1.CustomError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<CustomError>(errorValue),
          stackTrace,
        );
      case 'api.v1.CustomErrorToFromJson':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<CustomErrorToFromJson>(errorValue),
          stackTrace,
        );
      case 'api.v1.CustomErrorWithStackTrace':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<CustomErrorWithStackTrace>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'exceptions',
    function: 'throwsException',
  )
  Future<void> throwsException({required SupportedExceptionType type}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-exception'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'type': _$celest.Serializers.instance
            .serialize<SupportedExceptionType>(type)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'exceptions',
    function: 'throwsError',
  )
  Future<void> throwsError({required SupportedErrorType type}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-error'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'type':
            _$celest.Serializers.instance.serialize<SupportedErrorType>(type)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'exceptions',
    function: 'throwsCustomException',
  )
  Future<void> throwsCustomException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-custom-exception'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'exceptions',
    function: 'throwsCustomExceptionToFromJson',
  )
  Future<void> throwsCustomExceptionToFromJson() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/exceptions/throws-custom-exception-to-from-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'exceptions',
    function: 'throwsCustomError',
  )
  Future<void> throwsCustomError() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-custom-error'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'exceptions',
    function: 'throwsCustomErrorToFromJson',
  )
  Future<void> throwsCustomErrorToFromJson() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-custom-error-to-from-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'exceptions',
    function: 'throwsCustomErrorWithStackTrace',
  )
  Future<void> throwsCustomErrorWithStackTrace() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/exceptions/throws-custom-error-with-stack-trace'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }
}

/// Tests that extension types are correctly handled by the analyzer.
class CelestFunctionsExtensionTypes {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'string',
  )
  Future<StringX> string(StringX s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringX>(
          s,
          const _$celest.TypeToken<StringX>('StringX'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringX>(
      $body,
      const _$celest.TypeToken<StringX>('StringX'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'asyncOrString',
  )
  Future<StringX> asyncOrString(StringX s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/async-or-string'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringX>(
          s,
          const _$celest.TypeToken<StringX>('StringX'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringX>(
      $body,
      const _$celest.TypeToken<StringX>('StringX'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'asyncString',
  )
  Future<StringX> asyncString(StringX s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/async-string'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringX>(
          s,
          const _$celest.TypeToken<StringX>('StringX'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringX>(
      $body,
      const _$celest.TypeToken<StringX>('StringX'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringImpl',
  )
  Future<StringXImpl> stringImpl(StringXImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXImpl>(
          s,
          const _$celest.TypeToken<StringXImpl>('StringXImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXImpl>(
      $body,
      const _$celest.TypeToken<StringXImpl>('StringXImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringToFromJson',
  )
  Future<StringXToFromJson> stringToFromJson(StringXToFromJson s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-to-from-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXToFromJson>(
          s,
          const _$celest.TypeToken<StringXToFromJson>('StringXToFromJson'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXToFromJson>(
      $body,
      const _$celest.TypeToken<StringXToFromJson>('StringXToFromJson'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringToJson',
  )
  Future<StringXToJson> stringToJson(StringXToJson s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXToJson>(
          s,
          const _$celest.TypeToken<StringXToJson>('StringXToJson'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXToJson>(
      $body,
      const _$celest.TypeToken<StringXToJson>('StringXToJson'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringToJsonImpl',
  )
  Future<StringXToJsonImpl> stringToJsonImpl(StringXToJsonImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-to-json-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXToJsonImpl>(
          s,
          const _$celest.TypeToken<StringXToJsonImpl>('StringXToJsonImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXToJsonImpl>(
      $body,
      const _$celest.TypeToken<StringXToJsonImpl>('StringXToJsonImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringFromJson',
  )
  Future<StringXFromJson> stringFromJson(StringXFromJson s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-from-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXFromJson>(
          s,
          const _$celest.TypeToken<StringXFromJson>('StringXFromJson'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXFromJson>(
      $body,
      const _$celest.TypeToken<StringXFromJson>('StringXFromJson'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringFromJsonImpl',
  )
  Future<StringXFromJsonImpl> stringFromJsonImpl(StringXFromJsonImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-from-json-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXFromJsonImpl>(
          s,
          const _$celest.TypeToken<StringXFromJsonImpl>('StringXFromJsonImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXFromJsonImpl>(
      $body,
      const _$celest.TypeToken<StringXFromJsonImpl>('StringXFromJsonImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringFromJsonStatic',
  )
  Future<StringXFromJsonStatic> stringFromJsonStatic(
      StringXFromJsonStatic s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-from-json-static'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXFromJsonStatic>(
          s,
          const _$celest.TypeToken<StringXFromJsonStatic>(
              'StringXFromJsonStatic'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXFromJsonStatic>(
      $body,
      const _$celest.TypeToken<StringXFromJsonStatic>('StringXFromJsonStatic'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringPrivateField',
  )
  Future<StringXPrivateField> stringPrivateField(StringXPrivateField s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-field'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXPrivateField>(
          s,
          const _$celest.TypeToken<StringXPrivateField>('StringXPrivateField'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXPrivateField>(
      $body,
      const _$celest.TypeToken<StringXPrivateField>('StringXPrivateField'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringPrivateFieldImpl',
  )
  Future<StringXPrivateFieldImpl> stringPrivateFieldImpl(
      StringXPrivateFieldImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-field-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXPrivateFieldImpl>(
          s,
          const _$celest.TypeToken<StringXPrivateFieldImpl>(
              'StringXPrivateFieldImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXPrivateFieldImpl>(
      $body,
      const _$celest.TypeToken<StringXPrivateFieldImpl>(
          'StringXPrivateFieldImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringPrivateCtor',
  )
  Future<StringXPrivateCtor> stringPrivateCtor(StringXPrivateCtor s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-ctor'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXPrivateCtor>(
          s,
          const _$celest.TypeToken<StringXPrivateCtor>('StringXPrivateCtor'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXPrivateCtor>(
      $body,
      const _$celest.TypeToken<StringXPrivateCtor>('StringXPrivateCtor'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'stringPrivateCtorImpl',
  )
  Future<StringXPrivateCtorImpl> stringPrivateCtorImpl(
      StringXPrivateCtorImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-ctor-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r's': _$celest.Serializers.instance.serialize<StringXPrivateCtorImpl>(
          s,
          const _$celest.TypeToken<StringXPrivateCtorImpl>(
              'StringXPrivateCtorImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<StringXPrivateCtorImpl>(
      $body,
      const _$celest.TypeToken<StringXPrivateCtorImpl>(
          'StringXPrivateCtorImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'value',
  )
  Future<Value> value(Value v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'v': _$celest.Serializers.instance.serialize<Value>(v)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Value>($body);
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'valueX',
  )
  Future<ValueX> valueX(ValueX v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'v': _$celest.Serializers.instance.serialize<ValueX>(
          v,
          const _$celest.TypeToken<ValueX>('ValueX'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ValueX>(
      $body,
      const _$celest.TypeToken<ValueX>('ValueX'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'valueXImpl',
  )
  Future<ValueXImpl> valueXImpl(ValueXImpl v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'v': _$celest.Serializers.instance.serialize<ValueXImpl>(
          v,
          const _$celest.TypeToken<ValueXImpl>('ValueXImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ValueXImpl>(
      $body,
      const _$celest.TypeToken<ValueXImpl>('ValueXImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'valueXToFromJson',
  )
  Future<ValueXToFromJson> valueXToFromJson(ValueXToFromJson v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-to-from-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'v': _$celest.Serializers.instance.serialize<ValueXToFromJson>(
          v,
          const _$celest.TypeToken<ValueXToFromJson>('ValueXToFromJson'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ValueXToFromJson>(
      $body,
      const _$celest.TypeToken<ValueXToFromJson>('ValueXToFromJson'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'valueXToJson',
  )
  Future<ValueXToJson> valueXToJson(ValueXToJson v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'v': _$celest.Serializers.instance.serialize<ValueXToJson>(
          v,
          const _$celest.TypeToken<ValueXToJson>('ValueXToJson'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ValueXToJson>(
      $body,
      const _$celest.TypeToken<ValueXToJson>('ValueXToJson'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'valueXToJsonImpl',
  )
  Future<ValueXToJsonImpl> valueXToJsonImpl(ValueXToJsonImpl v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-to-json-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'v': _$celest.Serializers.instance.serialize<ValueXToJsonImpl>(
          v,
          const _$celest.TypeToken<ValueXToJsonImpl>('ValueXToJsonImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ValueXToJsonImpl>(
      $body,
      const _$celest.TypeToken<ValueXToJsonImpl>('ValueXToJsonImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'valueXFromJson',
  )
  Future<ValueXFromJson> valueXFromJson(ValueXFromJson v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-from-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'v': _$celest.Serializers.instance.serialize<ValueXFromJson>(
          v,
          const _$celest.TypeToken<ValueXFromJson>('ValueXFromJson'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ValueXFromJson>(
      $body,
      const _$celest.TypeToken<ValueXFromJson>('ValueXFromJson'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'valueXFromJsonImpl',
  )
  Future<ValueXFromJsonImpl> valueXFromJsonImpl(ValueXFromJsonImpl v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-from-json-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'v': _$celest.Serializers.instance.serialize<ValueXFromJsonImpl>(
          v,
          const _$celest.TypeToken<ValueXFromJsonImpl>('ValueXFromJsonImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ValueXFromJsonImpl>(
      $body,
      const _$celest.TypeToken<ValueXFromJsonImpl>('ValueXFromJsonImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'valueXFromJsonStatic',
  )
  Future<ValueXFromJsonStatic> valueXFromJsonStatic(
      ValueXFromJsonStatic v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-from-json-static'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'v': _$celest.Serializers.instance.serialize<ValueXFromJsonStatic>(
          v,
          const _$celest.TypeToken<ValueXFromJsonStatic>(
              'ValueXFromJsonStatic'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ValueXFromJsonStatic>(
      $body,
      const _$celest.TypeToken<ValueXFromJsonStatic>('ValueXFromJsonStatic'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'color',
  )
  Future<Color> color(Color color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'color': _$celest.Serializers.instance.serialize<Color>(color)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Color>($body);
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'colorX',
  )
  Future<ColorX> colorX(ColorX color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'color': _$celest.Serializers.instance.serialize<ColorX>(
          color,
          const _$celest.TypeToken<ColorX>('ColorX'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ColorX>(
      $body,
      const _$celest.TypeToken<ColorX>('ColorX'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'colorXImpl',
  )
  Future<ColorXImpl> colorXImpl(ColorXImpl color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'color': _$celest.Serializers.instance.serialize<ColorXImpl>(
          color,
          const _$celest.TypeToken<ColorXImpl>('ColorXImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ColorXImpl>(
      $body,
      const _$celest.TypeToken<ColorXImpl>('ColorXImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'colorXToFromJson',
  )
  Future<ColorXToFromJson> colorXToFromJson(ColorXToFromJson color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-to-from-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'color': _$celest.Serializers.instance.serialize<ColorXToFromJson>(
          color,
          const _$celest.TypeToken<ColorXToFromJson>('ColorXToFromJson'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ColorXToFromJson>(
      $body,
      const _$celest.TypeToken<ColorXToFromJson>('ColorXToFromJson'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'colorXToJson',
  )
  Future<ColorXToJson> colorXToJson(ColorXToJson color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-to-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'color': _$celest.Serializers.instance.serialize<ColorXToJson>(
          color,
          const _$celest.TypeToken<ColorXToJson>('ColorXToJson'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ColorXToJson>(
      $body,
      const _$celest.TypeToken<ColorXToJson>('ColorXToJson'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'colorXToJsonImpl',
  )
  Future<ColorXToJsonImpl> colorXToJsonImpl(ColorXToJsonImpl color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-to-json-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'color': _$celest.Serializers.instance.serialize<ColorXToJsonImpl>(
          color,
          const _$celest.TypeToken<ColorXToJsonImpl>('ColorXToJsonImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ColorXToJsonImpl>(
      $body,
      const _$celest.TypeToken<ColorXToJsonImpl>('ColorXToJsonImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'colorXFromJson',
  )
  Future<ColorXFromJson> colorXFromJson(ColorXFromJson color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-from-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'color': _$celest.Serializers.instance.serialize<ColorXFromJson>(
          color,
          const _$celest.TypeToken<ColorXFromJson>('ColorXFromJson'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ColorXFromJson>(
      $body,
      const _$celest.TypeToken<ColorXFromJson>('ColorXFromJson'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'colorXFromJsonImpl',
  )
  Future<ColorXFromJsonImpl> colorXFromJsonImpl(
      ColorXFromJsonImpl color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-from-json-impl'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'color': _$celest.Serializers.instance.serialize<ColorXFromJsonImpl>(
          color,
          const _$celest.TypeToken<ColorXFromJsonImpl>('ColorXFromJsonImpl'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ColorXFromJsonImpl>(
      $body,
      const _$celest.TypeToken<ColorXFromJsonImpl>('ColorXFromJsonImpl'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'colorXFromJsonStatic',
  )
  Future<ColorXFromJsonStatic> colorXFromJsonStatic(
      ColorXFromJsonStatic color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-from-json-static'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'color': _$celest.Serializers.instance.serialize<ColorXFromJsonStatic>(
          color,
          const _$celest.TypeToken<ColorXFromJsonStatic>(
              'ColorXFromJsonStatic'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ColorXFromJsonStatic>(
      $body,
      const _$celest.TypeToken<ColorXFromJsonStatic>('ColorXFromJsonStatic'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'jsonValue',
  )
  Future<_$celest.JsonValue> jsonValue(_$celest.JsonValue value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-value'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<_$celest.JsonValue>(
          value,
          const _$celest.TypeToken<_$celest.JsonValue>('JsonValue'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<_$celest.JsonValue>(
      $body,
      const _$celest.TypeToken<_$celest.JsonValue>('JsonValue'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'jsonString',
  )
  Future<_$celest.JsonString> jsonString(_$celest.JsonString value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-string'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<_$celest.JsonString>(
          value,
          const _$celest.TypeToken<_$celest.JsonString>('JsonString'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<_$celest.JsonString>(
      $body,
      const _$celest.TypeToken<_$celest.JsonString>('JsonString'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'jsonNum',
  )
  Future<_$celest.JsonNum> jsonNum(_$celest.JsonNum value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-num'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<_$celest.JsonNum>(
          value,
          const _$celest.TypeToken<_$celest.JsonNum>('JsonNum'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<_$celest.JsonNum>(
      $body,
      const _$celest.TypeToken<_$celest.JsonNum>('JsonNum'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'jsonInt',
  )
  Future<_$celest.JsonInt> jsonInt(_$celest.JsonInt value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-int'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<_$celest.JsonInt>(
          value,
          const _$celest.TypeToken<_$celest.JsonInt>('JsonInt'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<_$celest.JsonInt>(
      $body,
      const _$celest.TypeToken<_$celest.JsonInt>('JsonInt'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'jsonDouble',
  )
  Future<_$celest.JsonDouble> jsonDouble(_$celest.JsonDouble value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-double'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<_$celest.JsonDouble>(
          value,
          const _$celest.TypeToken<_$celest.JsonDouble>('JsonDouble'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<_$celest.JsonDouble>(
      $body,
      const _$celest.TypeToken<_$celest.JsonDouble>('JsonDouble'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'jsonBool',
  )
  Future<_$celest.JsonBool> jsonBool(_$celest.JsonBool value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-bool'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<_$celest.JsonBool>(
          value,
          const _$celest.TypeToken<_$celest.JsonBool>('JsonBool'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<_$celest.JsonBool>(
      $body,
      const _$celest.TypeToken<_$celest.JsonBool>('JsonBool'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'jsonList',
  )
  Future<_$celest.JsonList> jsonList(_$celest.JsonList value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-list'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<_$celest.JsonList>(
          value,
          const _$celest.TypeToken<_$celest.JsonList>('JsonList'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<_$celest.JsonList>(
      $body,
      const _$celest.TypeToken<_$celest.JsonList>('JsonList'),
    );
  }

  @_$celest.CloudFunction(
    api: 'extension_types',
    function: 'jsonMap',
  )
  Future<_$celest.JsonMap> jsonMap(_$celest.JsonMap value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-map'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance.serialize<_$celest.JsonMap>(
          value,
          const _$celest.TypeToken<_$celest.JsonMap>('JsonMap'),
        )
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<_$celest.JsonMap>(
      $body,
      const _$celest.TypeToken<_$celest.JsonMap>('JsonMap'),
    );
  }
}

/// Tests that classes which wrap generic types are generated correctly when
/// those generic types follow the specifications of `json_serializable`, e.g.
/// having a `toJson` method with function parameters for mapping the
/// underlying types to JSON (Object Function(T) toJsonT).
class CelestFunctionsGenericWrappers {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'generic_wrappers',
    function: 'genericWrappers',
  )
  Future<GenericWrappers> genericWrappers(GenericWrappers value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/generic-wrappers/generic-wrappers'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value':
            _$celest.Serializers.instance.serialize<GenericWrappers>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<GenericWrappers>($body);
  }

  @_$celest.CloudFunction(
    api: 'generic_wrappers',
    function: 'genericWrappersAsync',
  )
  Future<GenericWrappers> genericWrappersAsync(GenericWrappers value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/generic-wrappers/generic-wrappers-async'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value':
            _$celest.Serializers.instance.serialize<GenericWrappers>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<GenericWrappers>($body);
  }

  @_$celest.CloudFunction(
    api: 'generic_wrappers',
    function: 'genericWrapperParameters',
  )
  Future<GenericWrappers> genericWrapperParameters({
    required _$fast_immutable_collections_ilist.IList<String> listOfString,
    required _$fast_immutable_collections_ilist.IList<Uri> listOfUri,
    required _$fast_immutable_collections_ilist.IList<SimpleClass>
        listOfSimpleClass,
    required _$fast_immutable_collections_ilist
        .IList<_$fast_immutable_collections_ilist.IList<String>>
        listOfListOfString,
    required _$fast_immutable_collections_ilist
        .IList<_$fast_immutable_collections_ilist.IList<Uri>>
        listOfListOfUri,
    required _$fast_immutable_collections_ilist
        .IList<_$fast_immutable_collections_ilist.IList<SimpleClass>>
        listOfListOfSimpleClass,
    required _$fast_immutable_collections_imap.IMap<String, String> mapOfString,
    required _$fast_immutable_collections_imap.IMap<String, Uri> mapOfUri,
    required _$fast_immutable_collections_imap.IMap<String, SimpleClass>
        mapOfSimpleClass,
    required _$fast_immutable_collections_imap
        .IMap<String, _$fast_immutable_collections_ilist.IList<String>>
        mapOfListOfString,
    required _$fast_immutable_collections_imap
        .IMap<String, _$fast_immutable_collections_ilist.IList<Uri>>
        mapOfListOfUri,
    required _$fast_immutable_collections_imap
        .IMap<String, _$fast_immutable_collections_ilist.IList<SimpleClass>>
        mapOfListOfSimpleClass,
    required _$fast_immutable_collections_imap
        .IMap<String, _$fast_immutable_collections_imap.IMap<String, String>>
        mapOfMapOfString,
    required _$fast_immutable_collections_imap
        .IMap<String, _$fast_immutable_collections_imap.IMap<String, Uri>>
        mapOfMapOfUri,
    required _$fast_immutable_collections_imap.IMap<String,
            _$fast_immutable_collections_imap.IMap<String, SimpleClass>>
        mapOfMapOfSimpleClass,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/generic-wrappers/generic-wrapper-parameters'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'listOfString': _$celest.Serializers.instance
            .serialize<_$fast_immutable_collections_ilist.IList<String>>(
                listOfString),
        r'listOfUri': _$celest.Serializers.instance
            .serialize<_$fast_immutable_collections_ilist.IList<Uri>>(
                listOfUri),
        r'listOfSimpleClass': _$celest.Serializers.instance
            .serialize<_$fast_immutable_collections_ilist.IList<SimpleClass>>(
                listOfSimpleClass),
        r'listOfListOfString': _$celest.Serializers.instance.serialize<
                _$fast_immutable_collections_ilist
                .IList<_$fast_immutable_collections_ilist.IList<String>>>(
            listOfListOfString),
        r'listOfListOfUri': _$celest.Serializers.instance.serialize<
                _$fast_immutable_collections_ilist
                .IList<_$fast_immutable_collections_ilist.IList<Uri>>>(
            listOfListOfUri),
        r'listOfListOfSimpleClass': _$celest.Serializers.instance.serialize<
                _$fast_immutable_collections_ilist
                .IList<_$fast_immutable_collections_ilist.IList<SimpleClass>>>(
            listOfListOfSimpleClass),
        r'mapOfString': _$celest.Serializers.instance
            .serialize<_$fast_immutable_collections_imap.IMap<String, String>>(
                mapOfString),
        r'mapOfUri': _$celest.Serializers.instance
            .serialize<_$fast_immutable_collections_imap.IMap<String, Uri>>(
                mapOfUri),
        r'mapOfSimpleClass': _$celest.Serializers.instance.serialize<
            _$fast_immutable_collections_imap
            .IMap<String, SimpleClass>>(mapOfSimpleClass),
        r'mapOfListOfString': _$celest.Serializers.instance.serialize<
            _$fast_immutable_collections_imap.IMap<
                String,
                _$fast_immutable_collections_ilist
                .IList<String>>>(mapOfListOfString),
        r'mapOfListOfUri': _$celest.Serializers.instance.serialize<
            _$fast_immutable_collections_imap.IMap<String,
                _$fast_immutable_collections_ilist.IList<Uri>>>(mapOfListOfUri),
        r'mapOfListOfSimpleClass': _$celest.Serializers.instance.serialize<
            _$fast_immutable_collections_imap.IMap<
                String,
                _$fast_immutable_collections_ilist
                .IList<SimpleClass>>>(mapOfListOfSimpleClass),
        r'mapOfMapOfString': _$celest.Serializers.instance.serialize<
            _$fast_immutable_collections_imap.IMap<
                String,
                _$fast_immutable_collections_imap
                .IMap<String, String>>>(mapOfMapOfString),
        r'mapOfMapOfUri': _$celest.Serializers.instance.serialize<
            _$fast_immutable_collections_imap.IMap<
                String,
                _$fast_immutable_collections_imap
                .IMap<String, Uri>>>(mapOfMapOfUri),
        r'mapOfMapOfSimpleClass': _$celest.Serializers.instance.serialize<
            _$fast_immutable_collections_imap.IMap<
                String,
                _$fast_immutable_collections_imap
                .IMap<String, SimpleClass>>>(mapOfMapOfSimpleClass),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<GenericWrappers>($body);
  }
}

/// Tests that metadata associated with functions and parameters are correctly
/// parsed and transferred to the generated client.
class CelestFunctionsMetadata {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  /// A function that has doc comments.
  ///
  /// This is a doc comment.
  ///
  /// # This is an H1
  /// ## This is an H2
  /// ### This is an H3
  /// * This is a list item
  ///
  /// This is an example:
  ///
  /// ```dart
  /// void hasDocComments() {}
  /// ```
  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'hasDocComments',
  )
  Future<void> hasDocComments() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-doc-comments'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @deprecated
  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'hasDeprecatedAnnotation',
  )
  Future<void> hasDeprecatedAnnotation() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-deprecated-annotation'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @Deprecated.new('Do not use this function.')
  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'hasConstructedDeprecatedAnnotation',
  )
  Future<void> hasConstructedDeprecatedAnnotation() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-constructed-deprecated-annotation'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @MyAnnotation.create(
    'positional',
    named: 'named',
  )
  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'hasNamedConstructedAnnotation',
  )
  Future<void> hasNamedConstructedAnnotation() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-named-constructed-annotation'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @Literals.new(
    string: 'string',
    intValue: 1,
    doubleValue: 1.0,
    boolValue: true,
    list: const ['list'],
    map: const {'map': 'map'},
    enumValue: LiteralEnum.a,
    recordValue: const (a: 'a', b: 'b', c: 'c'),
  )
  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'hasLiteralsAnnotation',
  )
  Future<void> hasLiteralsAnnotation(
    @Literals.new(
      string: 'string',
      intValue: 1,
      doubleValue: 1.0,
      boolValue: true,
      list: const ['list'],
      map: const {'map': 'map'},
      enumValue: LiteralEnum.a,
      recordValue: const (a: 'a', b: 'b', c: 'c'),
    )
    String value, {
    @Literals.new(
      string: 'string',
      intValue: 1,
      doubleValue: 1.0,
      boolValue: true,
      list: const ['list'],
      map: const {'map': 'map'},
      enumValue: LiteralEnum.a,
      recordValue: const (a: 'a', b: 'b', c: 'c'),
    )
    required String named,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-literals-annotation'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @exportable
  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'hasExportableAnnotation',
  )
  Future<void> hasExportableAnnotation(
    @exportable String value, {
    @exportable String named = 'named',
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-exportable-annotation'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @Exportable.new()
  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'hasExportableConstructedAnnotation',
  )
  Future<void> hasExportableConstructedAnnotation(
    @Exportable.new() String value, {
    @Exportable.new() String named = 'named',
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-exportable-constructed-annotation'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @notExportable
  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'hasNotExportableAnnotation',
  )
  Future<void> hasNotExportableAnnotation(
    @notExportable String value, {
    @notExportable String named = 'named',
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-not-exportable-annotation'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'positionalDefaultValues',
  )
  Future<void> positionalDefaultValues([
    String value = 'value',
    int intValue = 1,
    double doubleValue = 1.0,
    bool boolValue = true,
    List<String> list = const ['list'],
    Map<String, String> map = const {'map': 'map'},
    Exportable exportable = const Exportable.new(),
    Serializable serializable = const Serializable.forType('String'),
    LiteralEnum enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/positional-default-values'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            _$celest.Serializers.instance.serialize<Serializable>(serializable),
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'nullablePositionalDefaultValues',
  )
  Future<void> nullablePositionalDefaultValues([
    String? value = 'value',
    int? intValue = 1,
    double? doubleValue = 1.0,
    bool? boolValue = true,
    List<String>? list = const ['list'],
    Map<String, String>? map = const {'map': 'map'},
    Exportable? exportable = const Exportable.new(),
    Serializable? serializable = const Serializable.forType('String'),
    LiteralEnum? enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/nullable-positional-default-values'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable': _$celest.Serializers.instance
            .serialize<Serializable?>(serializable),
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'namedDefaultValues',
  )
  Future<void> namedDefaultValues({
    String value = 'value',
    int intValue = 1,
    double doubleValue = 1.0,
    bool boolValue = true,
    List<String> list = const ['list'],
    Map<String, String> map = const {'map': 'map'},
    Exportable exportable = const Exportable.new(),
    Serializable serializable = const Serializable.forType('String'),
    LiteralEnum enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/named-default-values'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            _$celest.Serializers.instance.serialize<Serializable>(serializable),
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'nullableNamedDefaultValues',
  )
  Future<void> nullableNamedDefaultValues({
    String? value = 'value',
    int? intValue = 1,
    double? doubleValue = 1.0,
    bool? boolValue = true,
    List<String>? list = const ['list'],
    Map<String, String>? map = const {'map': 'map'},
    Exportable? exportable = const Exportable.new(),
    Serializable? serializable = const Serializable.forType('String'),
    LiteralEnum? enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/nullable-named-default-values'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable': _$celest.Serializers.instance
            .serialize<Serializable?>(serializable),
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'positionalDefaultValueVars',
  )
  Future<void> positionalDefaultValueVars([
    int value = defaultInt,
    double doubleValue = defaultDouble,
    bool boolValue = defaultBool,
    String stringValue = defaultString,
    List<String> listValue = defaultList,
    Map<String, String> mapValue = defaultMap,
    LiteralEnum enumValue = defaultEnum,
    ({String a, String b, String c}) recordValue = defaultRecord,
    Exportable exportable = defaultExportable,
    Serializable serializable = defaultSerializable,
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/positional-default-value-vars'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            _$celest.Serializers.instance.serialize<Serializable>(serializable),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'nullablePositionalDefaultValueVars',
  )
  Future<void> nullablePositionalDefaultValueVars([
    int? value = defaultInt,
    double? doubleValue = defaultDouble,
    bool? boolValue = defaultBool,
    String? stringValue = defaultString,
    List<String>? listValue = defaultList,
    Map<String, String>? mapValue = defaultMap,
    LiteralEnum? enumValue = defaultEnum,
    ({String a, String b, String c})? recordValue = defaultRecord,
    Exportable? exportable = defaultExportable,
    Serializable? serializable = defaultSerializable,
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/metadata/nullable-positional-default-value-vars'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable': _$celest.Serializers.instance
            .serialize<Serializable?>(serializable),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'namedDefaultValueVars',
  )
  Future<void> namedDefaultValueVars({
    int value = defaultInt,
    double doubleValue = defaultDouble,
    bool boolValue = defaultBool,
    String stringValue = defaultString,
    List<String> listValue = defaultList,
    Map<String, String> mapValue = defaultMap,
    LiteralEnum enumValue = defaultEnum,
    ({String a, String b, String c}) recordValue = defaultRecord,
    Exportable exportable = defaultExportable,
    Serializable serializable = defaultSerializable,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/named-default-value-vars'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            _$celest.Serializers.instance.serialize<Serializable>(serializable),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'nullableNamedDefaultValueVars',
  )
  Future<void> nullableNamedDefaultValueVars({
    int? value = defaultInt,
    double? doubleValue = defaultDouble,
    bool? boolValue = defaultBool,
    String? stringValue = defaultString,
    List<String>? listValue = defaultList,
    Map<String, String>? mapValue = defaultMap,
    LiteralEnum? enumValue = defaultEnum,
    ({String a, String b, String c})? recordValue = defaultRecord,
    Exportable? exportable = defaultExportable,
    Serializable? serializable = defaultSerializable,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/nullable-named-default-value-vars'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable': _$celest.Serializers.instance
            .serialize<Serializable?>(serializable),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'positionalDefaultValueVarsPrivate',
  )
  Future<void> positionalDefaultValueVarsPrivate([
    int value = 42,
    double doubleValue = 42.0,
    bool boolValue = true,
    String stringValue = 'default',
    List<String> listValue = const ['default'],
    Map<String, String> mapValue = const {'default': 'default'},
    LiteralEnum enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable exportable = const Exportable.new(),
    Serializable serializable = const Serializable.forType('String'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/positional-default-value-vars-private'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            _$celest.Serializers.instance.serialize<Serializable>(serializable),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'nullablePositionalDefaultValueVarsPrivate',
  )
  Future<void> nullablePositionalDefaultValueVarsPrivate([
    int? value = 42,
    double? doubleValue = 42.0,
    bool? boolValue = true,
    String? stringValue = 'default',
    List<String>? listValue = const ['default'],
    Map<String, String>? mapValue = const {'default': 'default'},
    LiteralEnum? enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable? exportable = const Exportable.new(),
    Serializable? serializable = const Serializable.forType('String'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/metadata/nullable-positional-default-value-vars-private'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable': _$celest.Serializers.instance
            .serialize<Serializable?>(serializable),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'namedDefaultValueVarsPrivate',
  )
  Future<void> namedDefaultValueVarsPrivate({
    int value = 42,
    double doubleValue = 42.0,
    bool boolValue = true,
    String stringValue = 'default',
    List<String> listValue = const ['default'],
    Map<String, String> mapValue = const {'default': 'default'},
    LiteralEnum enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable exportable = const Exportable.new(),
    Serializable serializable = const Serializable.forType('String'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/named-default-value-vars-private'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            _$celest.Serializers.instance.serialize<Serializable>(serializable),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'metadata',
    function: 'nullableNamedDefaultValueVarsPrivate',
  )
  Future<void> nullableNamedDefaultValueVarsPrivate({
    int? value = 42,
    double? doubleValue = 42.0,
    bool? boolValue = true,
    String? stringValue = 'default',
    List<String>? listValue = const ['default'],
    Map<String, String>? mapValue = const {'default': 'default'},
    LiteralEnum? enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable? exportable = const Exportable.new(),
    Serializable? serializable = const Serializable.forType('String'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/metadata/nullable-named-default-value-vars-private'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            _$celest.Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': _$celest.Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable':
            _$celest.Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable': _$celest.Serializers.instance
            .serialize<Serializable?>(serializable),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }
}

/// Tests that types can be recursively overriden in the serialization protocol
/// using extension types.
class CelestFunctionsOverrides {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      case '_common.CustomException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$_common__common.CustomException>(errorValue),
          stackTrace,
        );
      case '_common.CommonException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$_common__common.CommonException>(errorValue),
          stackTrace,
        );
      case 'api.v1.OverriddenException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OverriddenException>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'overrides',
    function: 'commonNestedParent',
  )
  Future<_$_common__common.NestedParent> commonNestedParent(
      _$_common__common.NestedParent parent) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/common-nested-parent'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'parent': _$celest.Serializers.instance
            .serialize<_$_common__common.NestedParent>(parent)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<_$_common__common.NestedParent>($body);
  }

  @_$celest.CloudFunction(
    api: 'overrides',
    function: 'commonNestedChild',
  )
  Future<_$_common__common.NestedChild> commonNestedChild(
      _$_common__common.NestedChild child) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/common-nested-child'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'child': _$celest.Serializers.instance
            .serialize<_$_common__common.NestedChild>(child)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<_$_common__common.NestedChild>($body);
  }

  @_$celest.CloudFunction(
    api: 'overrides',
    function: 'nestedGrandparent',
  )
  Future<NestedGrandparent> nestedGrandparent(
      NestedGrandparent grandparent) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/nested-grandparent'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'grandparent': _$celest.Serializers.instance
            .serialize<NestedGrandparent>(grandparent)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NestedGrandparent>($body);
  }

  @_$celest.CloudFunction(
    api: 'overrides',
    function: 'nestedParent',
  )
  Future<NestedParent> nestedParent(NestedParent parent) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/nested-parent'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'parent': _$celest.Serializers.instance.serialize<NestedParent>(parent)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NestedParent>($body);
  }

  @_$celest.CloudFunction(
    api: 'overrides',
    function: 'nestedChild',
  )
  Future<NestedChild> nestedChild(NestedChild child) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/nested-child'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'child': _$celest.Serializers.instance.serialize<NestedChild>(child)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NestedChild>($body);
  }

  @_$celest.CloudFunction(
    api: 'overrides',
    function: 'callsThrowsCommonOverriddenException',
  )
  Future<void> callsThrowsCommonOverriddenException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/overrides/calls-throws-common-overridden-exception'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'overrides',
    function: 'throwsCommonOverriddenException',
  )
  Future<void> throwsCommonOverriddenException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/throws-common-overridden-exception'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'overrides',
    function: 'throwsOverriddenException',
  )
  Future<void> throwsOverriddenException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/throws-overridden-exception'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'overrides',
    function: 'callsThrowsOverriddenException',
  )
  Future<void> callsThrowsOverriddenException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/calls-throws-overridden-exception'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }
}

class CelestFunctionsParameterTypes {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'parameter_types',
    function: 'simple',
  )
  Future<void> simple(
    String aString,
    int anInt,
    double aDouble,
    bool aBool,
    MyEnum anEnum,
    Null aNull,
    BigInt aBigInt,
    DateTime aDateTime,
    Duration aDuration,
    RegExp aRegExp,
    StackTrace aStackTrace,
    Uri aUri,
    UriData aUriData,
    Uint8List aUint8List,
    Iterable<String> anIterableOfString,
    Iterable<Uint8List> anIterableOfUint8List,
    List<String> aListOfString,
    List<int> aListOfInt,
    List<double> aListOfDouble,
    List<bool> aListOfBool,
    List<MyEnum> aListOfEnum,
    List<Null> aListOfNull,
    List<BigInt> aListOfBigInt,
    List<DateTime> aListOfDateTime,
    List<Duration> aListOfDuration,
    List<RegExp> aListOfRegExp,
    List<StackTrace> aListOfStackTrace,
    List<Uri> aListOfUri,
    List<UriData> aListOfUriData,
    List<Uint8List> aListOfUint8List,
    Map<String, String> aMapOfString,
    Map<String, int> aMapOfInt,
    Map<String, double> aMapOfDouble,
    Map<String, bool> aMapOfBool,
    Map<String, MyEnum> aMapOfEnum,
    Map<String, Null> aMapOfNull,
    Map<String, BigInt> aMapOfBigInt,
    Map<String, DateTime> aMapOfDateTime,
    Map<String, Duration> aMapOfDuration,
    Map<String, RegExp> aMapOfRegExp,
    Map<String, StackTrace> aMapOfStackTrace,
    Map<String, Uri> aMapOfUri,
    Map<String, UriData> aMapOfUriData,
    Map<String, Uint8List> aMapOfUint8List,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameter-types/simple'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'aString': aString,
        r'anInt': anInt,
        r'aDouble': aDouble,
        r'aBool': aBool,
        r'anEnum': _$celest.Serializers.instance.serialize<MyEnum>(anEnum),
        r'aNull': aNull,
        r'aBigInt': _$celest.Serializers.instance.serialize<BigInt>(aBigInt),
        r'aDateTime':
            _$celest.Serializers.instance.serialize<DateTime>(aDateTime),
        r'aDuration':
            _$celest.Serializers.instance.serialize<Duration>(aDuration),
        r'aRegExp': _$celest.Serializers.instance.serialize<RegExp>(aRegExp),
        r'aStackTrace':
            _$celest.Serializers.instance.serialize<StackTrace>(aStackTrace),
        r'aUri': _$celest.Serializers.instance.serialize<Uri>(aUri),
        r'aUriData': _$celest.Serializers.instance.serialize<UriData>(aUriData),
        r'aUint8List':
            _$celest.Serializers.instance.serialize<Uint8List>(aUint8List),
        r'anIterableOfString': anIterableOfString,
        r'anIterableOfUint8List': anIterableOfUint8List
            .map((el) => _$celest.Serializers.instance.serialize<Uint8List>(el))
            .toList(),
        r'aListOfString': aListOfString,
        r'aListOfInt': aListOfInt,
        r'aListOfDouble': aListOfDouble,
        r'aListOfBool': aListOfBool,
        r'aListOfEnum': aListOfEnum
            .map((el) => _$celest.Serializers.instance.serialize<MyEnum>(el))
            .toList(),
        r'aListOfNull': aListOfNull,
        r'aListOfBigInt': aListOfBigInt
            .map((el) => _$celest.Serializers.instance.serialize<BigInt>(el))
            .toList(),
        r'aListOfDateTime': aListOfDateTime
            .map((el) => _$celest.Serializers.instance.serialize<DateTime>(el))
            .toList(),
        r'aListOfDuration': aListOfDuration
            .map((el) => _$celest.Serializers.instance.serialize<Duration>(el))
            .toList(),
        r'aListOfRegExp': aListOfRegExp
            .map((el) => _$celest.Serializers.instance.serialize<RegExp>(el))
            .toList(),
        r'aListOfStackTrace': aListOfStackTrace
            .map(
                (el) => _$celest.Serializers.instance.serialize<StackTrace>(el))
            .toList(),
        r'aListOfUri': aListOfUri
            .map((el) => _$celest.Serializers.instance.serialize<Uri>(el))
            .toList(),
        r'aListOfUriData': aListOfUriData
            .map((el) => _$celest.Serializers.instance.serialize<UriData>(el))
            .toList(),
        r'aListOfUint8List': aListOfUint8List
            .map((el) => _$celest.Serializers.instance.serialize<Uint8List>(el))
            .toList(),
        r'aMapOfString': aMapOfString,
        r'aMapOfInt': aMapOfInt,
        r'aMapOfDouble': aMapOfDouble,
        r'aMapOfBool': aMapOfBool,
        r'aMapOfEnum': aMapOfEnum.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<MyEnum>(value),
            )),
        r'aMapOfNull': aMapOfNull,
        r'aMapOfBigInt': aMapOfBigInt.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<BigInt>(value),
            )),
        r'aMapOfDateTime': aMapOfDateTime.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<DateTime>(value),
            )),
        r'aMapOfDuration': aMapOfDuration.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<Duration>(value),
            )),
        r'aMapOfRegExp': aMapOfRegExp.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<RegExp>(value),
            )),
        r'aMapOfStackTrace': aMapOfStackTrace.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<StackTrace>(value),
            )),
        r'aMapOfUri': aMapOfUri.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<Uri>(value),
            )),
        r'aMapOfUriData': aMapOfUriData.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<UriData>(value),
            )),
        r'aMapOfUint8List': aMapOfUint8List.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<Uint8List>(value),
            )),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'parameter_types',
    function: 'simpleOptional',
  )
  Future<void> simpleOptional(
    String? aString,
    int? anInt,
    double? aDouble,
    bool? aBool,
    MyEnum? anEnum,
    Null aNull,
    BigInt? aBigInt,
    DateTime? aDateTime,
    Duration? aDuration,
    RegExp? aRegExp,
    StackTrace? aStackTrace,
    Uri? aUri,
    UriData? aUriData,
    Uint8List? aUint8List,
    Iterable<String>? anIterableOfString,
    Iterable<Uint8List>? anIterableOfUint8List,
    List<String>? aListOfString,
    List<int>? aListOfInt,
    List<double>? aListOfDouble,
    List<bool>? aListOfBool,
    List<MyEnum>? aListOfEnum,
    List<Null>? aListOfNull,
    List<BigInt>? aListOfBigInt,
    List<DateTime>? aListOfDateTime,
    List<Duration>? aListOfDuration,
    List<RegExp>? aListOfRegExp,
    List<StackTrace>? aListOfStackTrace,
    List<Uri>? aListOfUri,
    List<UriData>? aListOfUriData,
    List<Uint8List>? aListOfUint8List,
    Map<String, String>? aMapOfString,
    Map<String, int>? aMapOfInt,
    Map<String, double>? aMapOfDouble,
    Map<String, bool>? aMapOfBool,
    Map<String, MyEnum>? aMapOfEnum,
    Map<String, Null>? aMapOfNull,
    Map<String, BigInt>? aMapOfBigInt,
    Map<String, DateTime>? aMapOfDateTime,
    Map<String, Duration>? aMapOfDuration,
    Map<String, RegExp>? aMapOfRegExp,
    Map<String, StackTrace>? aMapOfStackTrace,
    Map<String, Uri>? aMapOfUri,
    Map<String, UriData>? aMapOfUriData,
    Map<String, Uint8List>? aMapOfUint8List,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameter-types/simple-optional'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'aString': aString,
        r'anInt': anInt,
        r'aDouble': aDouble,
        r'aBool': aBool,
        r'anEnum': _$celest.Serializers.instance.serialize<MyEnum?>(anEnum),
        r'aNull': aNull,
        r'aBigInt': _$celest.Serializers.instance.serialize<BigInt?>(aBigInt),
        r'aDateTime':
            _$celest.Serializers.instance.serialize<DateTime?>(aDateTime),
        r'aDuration':
            _$celest.Serializers.instance.serialize<Duration?>(aDuration),
        r'aRegExp': _$celest.Serializers.instance.serialize<RegExp?>(aRegExp),
        r'aStackTrace':
            _$celest.Serializers.instance.serialize<StackTrace?>(aStackTrace),
        r'aUri': _$celest.Serializers.instance.serialize<Uri?>(aUri),
        r'aUriData':
            _$celest.Serializers.instance.serialize<UriData?>(aUriData),
        r'aUint8List':
            _$celest.Serializers.instance.serialize<Uint8List?>(aUint8List),
        r'anIterableOfString': anIterableOfString,
        r'anIterableOfUint8List': anIterableOfUint8List
            ?.map(
                (el) => _$celest.Serializers.instance.serialize<Uint8List>(el))
            .toList(),
        r'aListOfString': aListOfString,
        r'aListOfInt': aListOfInt,
        r'aListOfDouble': aListOfDouble,
        r'aListOfBool': aListOfBool,
        r'aListOfEnum': aListOfEnum
            ?.map((el) => _$celest.Serializers.instance.serialize<MyEnum>(el))
            .toList(),
        r'aListOfNull': aListOfNull,
        r'aListOfBigInt': aListOfBigInt
            ?.map((el) => _$celest.Serializers.instance.serialize<BigInt>(el))
            .toList(),
        r'aListOfDateTime': aListOfDateTime
            ?.map((el) => _$celest.Serializers.instance.serialize<DateTime>(el))
            .toList(),
        r'aListOfDuration': aListOfDuration
            ?.map((el) => _$celest.Serializers.instance.serialize<Duration>(el))
            .toList(),
        r'aListOfRegExp': aListOfRegExp
            ?.map((el) => _$celest.Serializers.instance.serialize<RegExp>(el))
            .toList(),
        r'aListOfStackTrace': aListOfStackTrace
            ?.map(
                (el) => _$celest.Serializers.instance.serialize<StackTrace>(el))
            .toList(),
        r'aListOfUri': aListOfUri
            ?.map((el) => _$celest.Serializers.instance.serialize<Uri>(el))
            .toList(),
        r'aListOfUriData': aListOfUriData
            ?.map((el) => _$celest.Serializers.instance.serialize<UriData>(el))
            .toList(),
        r'aListOfUint8List': aListOfUint8List
            ?.map(
                (el) => _$celest.Serializers.instance.serialize<Uint8List>(el))
            .toList(),
        r'aMapOfString': aMapOfString,
        r'aMapOfInt': aMapOfInt,
        r'aMapOfDouble': aMapOfDouble,
        r'aMapOfBool': aMapOfBool,
        r'aMapOfEnum': aMapOfEnum?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<MyEnum>(value),
            )),
        r'aMapOfNull': aMapOfNull,
        r'aMapOfBigInt': aMapOfBigInt?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<BigInt>(value),
            )),
        r'aMapOfDateTime': aMapOfDateTime?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<DateTime>(value),
            )),
        r'aMapOfDuration': aMapOfDuration?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<Duration>(value),
            )),
        r'aMapOfRegExp': aMapOfRegExp?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<RegExp>(value),
            )),
        r'aMapOfStackTrace': aMapOfStackTrace?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<StackTrace>(value),
            )),
        r'aMapOfUri': aMapOfUri?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<Uri>(value),
            )),
        r'aMapOfUriData': aMapOfUriData?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<UriData>(value),
            )),
        r'aMapOfUint8List': aMapOfUint8List?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<Uint8List>(value),
            )),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'parameter_types',
    function: 'complex',
  )
  Future<void> complex(
    SimpleStruct aSimpleStruct,
    ComplexStruct aComplexStruct,
    SimpleClass aSimpleClass,
    ComplexClass aComplexClass,
    SimpleStruct? aNullableSimpleStruct,
    ComplexStruct? aNullableComplexStruct,
    SimpleClass? aNullableSimpleClass,
    ComplexClass? aNullableComplexClass,
    Iterable<SimpleStruct> anIterableOfSimpleStruct,
    Iterable<ComplexStruct> anIterableOfComplexStruct,
    Iterable<SimpleClass> anIterableOfSimpleClass,
    Iterable<ComplexClass> anIterableOfComplexClass,
    Iterable<SimpleStruct>? aNullableIterableOfSimpleStruct,
    Iterable<ComplexStruct>? aNullableIterableOfComplexStruct,
    Iterable<SimpleClass>? aNullableIterableOfSimpleClass,
    Iterable<ComplexClass>? aNullableIterableOfComplexClass,
    Iterable<SimpleStruct?> anIterableOfNullableSimpleStruct,
    Iterable<ComplexStruct?> anIterableOfNullableComplexStruct,
    Iterable<SimpleClass?> anIterableOfNullableSimpleClass,
    Iterable<ComplexClass?> anIterableOfNullableComplexClass,
    List<SimpleStruct> aListOfSimpleStruct,
    List<ComplexStruct> aListOfComplexStruct,
    List<SimpleClass> aListOfSimpleClass,
    List<ComplexClass> aListOfComplexClass,
    List<SimpleStruct>? aNullableListOfSimpleStruct,
    List<ComplexStruct>? aNullableListOfComplexStruct,
    List<SimpleClass>? aNullableListOfSimpleClass,
    List<ComplexClass>? aNullableListOfComplexClass,
    List<SimpleStruct?> aListOfNullableSimpleStruct,
    List<ComplexStruct?> aListOfNullableComplexStruct,
    List<SimpleClass?> aListOfNullableSimpleClass,
    List<ComplexClass?> aListOfNullableComplexClass,
    Map<String, SimpleStruct> aMapOfSimpleStruct,
    Map<String, ComplexStruct> aMapOfComplexStruct,
    Map<String, SimpleClass> aMapOfSimpleClass,
    Map<String, ComplexClass> aMapOfComplexClass,
    Map<String, SimpleStruct>? aNullableMapOfSimpleStruct,
    Map<String, ComplexStruct>? aNullableMapOfComplexStruct,
    Map<String, SimpleClass>? aNullableMapOfSimpleClass,
    Map<String, ComplexClass>? aNullableMapOfComplexClass,
    Map<String, SimpleStruct?> aMapOfNullableSimpleStruct,
    Map<String, ComplexStruct?> aMapOfNullableComplexStruct,
    Map<String, SimpleClass?> aMapOfNullableSimpleClass,
    Map<String, ComplexClass?> aMapOfNullableComplexClass,
    Map<String, SimpleStruct?>? aNullableMapOfNullableSimpleStruct,
    Map<String, ComplexStruct?>? aNullableMapOfNullableComplexStruct,
    Map<String, SimpleClass?>? aNullableMapOfNullableSimpleClass,
    Map<String, ComplexClass?>? aNullableMapOfNullableComplexClass,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameter-types/complex'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'aSimpleStruct': _$celest.Serializers.instance
            .serialize<SimpleStruct>(aSimpleStruct),
        r'aComplexStruct': _$celest.Serializers.instance
            .serialize<ComplexStruct>(aComplexStruct),
        r'aSimpleClass':
            _$celest.Serializers.instance.serialize<SimpleClass>(aSimpleClass),
        r'aComplexClass': _$celest.Serializers.instance
            .serialize<ComplexClass>(aComplexClass),
        r'aNullableSimpleStruct': _$celest.Serializers.instance
            .serialize<SimpleStruct?>(aNullableSimpleStruct),
        r'aNullableComplexStruct': _$celest.Serializers.instance
            .serialize<ComplexStruct?>(aNullableComplexStruct),
        r'aNullableSimpleClass': _$celest.Serializers.instance
            .serialize<SimpleClass?>(aNullableSimpleClass),
        r'aNullableComplexClass': _$celest.Serializers.instance
            .serialize<ComplexClass?>(aNullableComplexClass),
        r'anIterableOfSimpleStruct': anIterableOfSimpleStruct
            .map((el) =>
                _$celest.Serializers.instance.serialize<SimpleStruct>(el))
            .toList(),
        r'anIterableOfComplexStruct': anIterableOfComplexStruct
            .map((el) =>
                _$celest.Serializers.instance.serialize<ComplexStruct>(el))
            .toList(),
        r'anIterableOfSimpleClass': anIterableOfSimpleClass
            .map((el) =>
                _$celest.Serializers.instance.serialize<SimpleClass>(el))
            .toList(),
        r'anIterableOfComplexClass': anIterableOfComplexClass
            .map((el) =>
                _$celest.Serializers.instance.serialize<ComplexClass>(el))
            .toList(),
        r'aNullableIterableOfSimpleStruct': aNullableIterableOfSimpleStruct
            ?.map((el) =>
                _$celest.Serializers.instance.serialize<SimpleStruct>(el))
            .toList(),
        r'aNullableIterableOfComplexStruct': aNullableIterableOfComplexStruct
            ?.map((el) =>
                _$celest.Serializers.instance.serialize<ComplexStruct>(el))
            .toList(),
        r'aNullableIterableOfSimpleClass': aNullableIterableOfSimpleClass
            ?.map((el) =>
                _$celest.Serializers.instance.serialize<SimpleClass>(el))
            .toList(),
        r'aNullableIterableOfComplexClass': aNullableIterableOfComplexClass
            ?.map((el) =>
                _$celest.Serializers.instance.serialize<ComplexClass>(el))
            .toList(),
        r'anIterableOfNullableSimpleStruct': anIterableOfNullableSimpleStruct
            .map((el) =>
                _$celest.Serializers.instance.serialize<SimpleStruct?>(el))
            .toList(),
        r'anIterableOfNullableComplexStruct': anIterableOfNullableComplexStruct
            .map((el) =>
                _$celest.Serializers.instance.serialize<ComplexStruct?>(el))
            .toList(),
        r'anIterableOfNullableSimpleClass': anIterableOfNullableSimpleClass
            .map((el) =>
                _$celest.Serializers.instance.serialize<SimpleClass?>(el))
            .toList(),
        r'anIterableOfNullableComplexClass': anIterableOfNullableComplexClass
            .map((el) =>
                _$celest.Serializers.instance.serialize<ComplexClass?>(el))
            .toList(),
        r'aListOfSimpleStruct': aListOfSimpleStruct
            .map((el) =>
                _$celest.Serializers.instance.serialize<SimpleStruct>(el))
            .toList(),
        r'aListOfComplexStruct': aListOfComplexStruct
            .map((el) =>
                _$celest.Serializers.instance.serialize<ComplexStruct>(el))
            .toList(),
        r'aListOfSimpleClass': aListOfSimpleClass
            .map((el) =>
                _$celest.Serializers.instance.serialize<SimpleClass>(el))
            .toList(),
        r'aListOfComplexClass': aListOfComplexClass
            .map((el) =>
                _$celest.Serializers.instance.serialize<ComplexClass>(el))
            .toList(),
        r'aNullableListOfSimpleStruct': aNullableListOfSimpleStruct
            ?.map((el) =>
                _$celest.Serializers.instance.serialize<SimpleStruct>(el))
            .toList(),
        r'aNullableListOfComplexStruct': aNullableListOfComplexStruct
            ?.map((el) =>
                _$celest.Serializers.instance.serialize<ComplexStruct>(el))
            .toList(),
        r'aNullableListOfSimpleClass': aNullableListOfSimpleClass
            ?.map((el) =>
                _$celest.Serializers.instance.serialize<SimpleClass>(el))
            .toList(),
        r'aNullableListOfComplexClass': aNullableListOfComplexClass
            ?.map((el) =>
                _$celest.Serializers.instance.serialize<ComplexClass>(el))
            .toList(),
        r'aListOfNullableSimpleStruct': aListOfNullableSimpleStruct
            .map((el) =>
                _$celest.Serializers.instance.serialize<SimpleStruct?>(el))
            .toList(),
        r'aListOfNullableComplexStruct': aListOfNullableComplexStruct
            .map((el) =>
                _$celest.Serializers.instance.serialize<ComplexStruct?>(el))
            .toList(),
        r'aListOfNullableSimpleClass': aListOfNullableSimpleClass
            .map((el) =>
                _$celest.Serializers.instance.serialize<SimpleClass?>(el))
            .toList(),
        r'aListOfNullableComplexClass': aListOfNullableComplexClass
            .map((el) =>
                _$celest.Serializers.instance.serialize<ComplexClass?>(el))
            .toList(),
        r'aMapOfSimpleStruct': aMapOfSimpleStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<SimpleStruct>(value),
            )),
        r'aMapOfComplexStruct': aMapOfComplexStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<ComplexStruct>(value),
            )),
        r'aMapOfSimpleClass': aMapOfSimpleClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<SimpleClass>(value),
            )),
        r'aMapOfComplexClass': aMapOfComplexClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<ComplexClass>(value),
            )),
        r'aNullableMapOfSimpleStruct': aNullableMapOfSimpleStruct?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<SimpleStruct>(value),
            )),
        r'aNullableMapOfComplexStruct': aNullableMapOfComplexStruct?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<ComplexStruct>(value),
            )),
        r'aNullableMapOfSimpleClass': aNullableMapOfSimpleClass?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<SimpleClass>(value),
            )),
        r'aNullableMapOfComplexClass': aNullableMapOfComplexClass?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<ComplexClass>(value),
            )),
        r'aMapOfNullableSimpleStruct': aMapOfNullableSimpleStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<SimpleStruct?>(value),
            )),
        r'aMapOfNullableComplexStruct': aMapOfNullableComplexStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<ComplexStruct?>(value),
            )),
        r'aMapOfNullableSimpleClass': aMapOfNullableSimpleClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<SimpleClass?>(value),
            )),
        r'aMapOfNullableComplexClass': aMapOfNullableComplexClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              _$celest.Serializers.instance.serialize<ComplexClass?>(value),
            )),
        r'aNullableMapOfNullableSimpleStruct':
            aNullableMapOfNullableSimpleStruct?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  _$celest.Serializers.instance.serialize<SimpleStruct?>(value),
                )),
        r'aNullableMapOfNullableComplexStruct':
            aNullableMapOfNullableComplexStruct?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  _$celest.Serializers.instance
                      .serialize<ComplexStruct?>(value),
                )),
        r'aNullableMapOfNullableSimpleClass':
            aNullableMapOfNullableSimpleClass?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  _$celest.Serializers.instance.serialize<SimpleClass?>(value),
                )),
        r'aNullableMapOfNullableComplexClass':
            aNullableMapOfNullableComplexClass?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  _$celest.Serializers.instance.serialize<ComplexClass?>(value),
                )),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }
}

class CelestFunctionsParameters {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'parameters',
    function: 'optionalPositional',
  )
  Future<void> optionalPositional([
    String? optionalString,
    int? optionalInt,
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/optional-positional'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'optionalString': optionalString,
        r'optionalInt': optionalInt,
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'parameters',
    function: 'optionalNamed',
  )
  Future<void> optionalNamed({
    String? namedString,
    int? namedInt,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/optional-named'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'namedString': namedString,
        r'namedInt': namedInt,
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'parameters',
    function: 'requiredPositional',
  )
  Future<void> requiredPositional(
    String requiredString,
    int requiredInt,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/required-positional'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'requiredString': requiredString,
        r'requiredInt': requiredInt,
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'parameters',
    function: 'requiredNamed',
  )
  Future<void> requiredNamed({
    required String requiredString,
    required int requiredInt,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/required-named'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'requiredString': requiredString,
        r'requiredInt': requiredInt,
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }
}

/// Tests that records with and without aliases are serializable and
/// deserializable.
class CelestFunctionsRecords {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'records',
    function: 'nonAliasedNamedFields',
  )
  Future<({String anotherField, String field})> nonAliasedNamedFields(
      {required ({String anotherField, String field}) value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/non-aliased-named-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance
            .serialize<({String anotherField, String field})>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<({String anotherField, String field})>($body);
  }

  @_$celest.CloudFunction(
    api: 'records',
    function: 'asyncNonAliasedNamedFields',
  )
  Future<({String anotherField, String field})> asyncNonAliasedNamedFields(
      {required ({String anotherField, String field}) value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-non-aliased-named-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value': _$celest.Serializers.instance
            .serialize<({String anotherField, String field})>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<({String anotherField, String field})>($body);
  }

  @_$celest.CloudFunction(
    api: 'records',
    function: 'aliasedNamedFields',
  )
  Future<NamedFieldsRecord> aliasedNamedFields(
      {required NamedFieldsRecord value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/aliased-named-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value':
            _$celest.Serializers.instance.serialize<NamedFieldsRecord>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NamedFieldsRecord>($body);
  }

  @_$celest.CloudFunction(
    api: 'records',
    function: 'asyncAliasedNamedFields',
  )
  Future<NamedFieldsRecord> asyncAliasedNamedFields(
      {required NamedFieldsRecord value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-aliased-named-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value':
            _$celest.Serializers.instance.serialize<NamedFieldsRecord>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NamedFieldsRecord>($body);
  }

  @_$celest.CloudFunction(
    api: 'records',
    function: 'namedFields',
  )
  Future<
      ({
        NamedFieldsRecord aliased,
        ({String anotherField, String field}) nonAliased
      })> namedFields({
    required ({String anotherField, String field}) nonAliased,
    required NamedFieldsRecord aliased,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/named-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'nonAliased': _$celest.Serializers.instance
            .serialize<({String anotherField, String field})>(nonAliased),
        r'aliased':
            _$celest.Serializers.instance.serialize<NamedFieldsRecord>(aliased),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<
        ({
          NamedFieldsRecord aliased,
          ({String anotherField, String field}) nonAliased
        })>($body);
  }

  @_$celest.CloudFunction(
    api: 'records',
    function: 'asyncNamedFields',
  )
  Future<
      ({
        NamedFieldsRecord aliased,
        ({String anotherField, String field}) nonAliased
      })> asyncNamedFields({
    required ({String anotherField, String field}) nonAliased,
    required NamedFieldsRecord aliased,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-named-fields'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'nonAliased': _$celest.Serializers.instance
            .serialize<({String anotherField, String field})>(nonAliased),
        r'aliased':
            _$celest.Serializers.instance.serialize<NamedFieldsRecord>(aliased),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<
        ({
          NamedFieldsRecord aliased,
          ({String anotherField, String field}) nonAliased
        })>($body);
  }

  @_$celest.CloudFunction(
    api: 'records',
    function: 'nested',
  )
  Future<Nested> nested(Nested value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/nested'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'value': _$celest.Serializers.instance.serialize<Nested>(value)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Nested>($body);
  }

  @_$celest.CloudFunction(
    api: 'records',
    function: 'asyncNested',
  )
  Future<Nested> asyncNested(Nested value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-nested'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'value': _$celest.Serializers.instance.serialize<Nested>(value)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Nested>($body);
  }

  @_$celest.CloudFunction(
    api: 'records',
    function: 'nullableNested',
  )
  Future<NullableNested?> nullableNested(NullableNested? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/nullable-nested'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value':
            _$celest.Serializers.instance.serialize<NullableNested?>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NullableNested?>($body);
  }

  @_$celest.CloudFunction(
    api: 'records',
    function: 'asyncNullableNested',
  )
  Future<NullableNested?> asyncNullableNested(NullableNested? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-nullable-nested'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'value':
            _$celest.Serializers.instance.serialize<NullableNested?>(value)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<NullableNested?>($body);
  }
}

/// Validates all permutations of return types.
class CelestFunctionsReturnTypes {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncVoidReturn',
  )
  Future<void> asyncVoidReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-void-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncStringReturn',
  )
  Future<String> asyncStringReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-string-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as String);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncIntReturn',
  )
  Future<int> asyncIntReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-int-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num).toInt();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncDoubleReturn',
  )
  Future<double> asyncDoubleReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-double-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num).toDouble();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncBoolReturn',
  )
  Future<bool> asyncBoolReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-bool-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as bool);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncIterableReturn',
  )
  Future<Iterable<String>> asyncIterableReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-iterable-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>).map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncListReturn',
  )
  Future<List<String>> asyncListReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-list-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>).map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncMapReturn',
  )
  Future<Map<String, String>> asyncMapReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-map-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncStructReturn',
  )
  Future<SimpleStruct> asyncStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-struct-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SimpleStruct>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncStructReturnNullable',
  )
  Future<SimpleStruct?> asyncStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-struct-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SimpleStruct?>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncComplexStructReturn',
  )
  Future<ComplexStruct> asyncComplexStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-complex-struct-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ComplexStruct>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncComplexStructReturnNullable',
  )
  Future<ComplexStruct?> asyncComplexStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-complex-struct-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ComplexStruct?>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncComplexClassReturn',
  )
  Future<ComplexClass> asyncComplexClassReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-complex-class-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ComplexClass>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncClassReturnNullable',
  )
  Future<SimpleClass?> asyncClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-class-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SimpleClass?>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrVoidReturn',
  )
  Future<void> asyncOrVoidReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-void-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrStringReturn',
  )
  Future<String> asyncOrStringReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-string-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as String);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrIntReturn',
  )
  Future<int> asyncOrIntReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-int-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num).toInt();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrDoubleReturn',
  )
  Future<double> asyncOrDoubleReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-double-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num).toDouble();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrBoolReturn',
  )
  Future<bool> asyncOrBoolReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-bool-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as bool);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrIterableReturn',
  )
  Future<Iterable<String>> asyncOrIterableReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-iterable-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>).map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrListReturn',
  )
  Future<List<String>> asyncOrListReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-list-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>).map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrMapReturn',
  )
  Future<Map<String, String>> asyncOrMapReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-map-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrStructReturn',
  )
  Future<SimpleStruct> asyncOrStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-struct-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SimpleStruct>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrComplexStructReturn',
  )
  Future<ComplexStruct> asyncOrComplexStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-complex-struct-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ComplexStruct>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrVoidReturnNullable',
  )
  Future<void> asyncOrVoidReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-void-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrStringReturnNullable',
  )
  Future<String?> asyncOrStringReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-string-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as String?);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrIntReturnNullable',
  )
  Future<int?> asyncOrIntReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-int-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num?)?.toInt();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrDoubleReturnNullable',
  )
  Future<double?> asyncOrDoubleReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-double-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num?)?.toDouble();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrBoolReturnNullable',
  )
  Future<bool?> asyncOrBoolReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-bool-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as bool?);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrIterableReturnNullable',
  )
  Future<Iterable<String>?> asyncOrIterableReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-iterable-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>?)?.map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrListReturnNullable',
  )
  Future<List<String>?> asyncOrListReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-list-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>?)?.map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrMapReturnNullable',
  )
  Future<Map<String, String>?> asyncOrMapReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-map-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>?)?.map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrStructReturnNullable',
  )
  Future<SimpleStruct?> asyncOrStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-struct-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SimpleStruct?>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrComplexStructReturnNullable',
  )
  Future<ComplexStruct?> asyncOrComplexStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-or-complex-struct-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ComplexStruct?>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrSimpleClassReturnNullable',
  )
  Future<SimpleClass?> asyncOrSimpleClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-or-simple-class-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SimpleClass?>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'asyncOrComplexClassReturnNullable',
  )
  Future<ComplexClass?> asyncOrComplexClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-or-complex-class-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ComplexClass?>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'voidReturn',
  )
  Future<void> voidReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/void-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return;
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'stringReturn',
  )
  Future<String> stringReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/string-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as String);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'intReturn',
  )
  Future<int> intReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/int-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num).toInt();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'doubleReturn',
  )
  Future<double> doubleReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/double-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num).toDouble();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'boolReturn',
  )
  Future<bool> boolReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/bool-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as bool);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'iterableReturn',
  )
  Future<Iterable<String>> iterableReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/iterable-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>).map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'listReturn',
  )
  Future<List<String>> listReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/list-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>).map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'mapReturn',
  )
  Future<Map<String, String>> mapReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/map-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'structReturn',
  )
  Future<SimpleStruct> structReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/struct-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SimpleStruct>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'complexReturn',
  )
  Future<ComplexStruct> complexReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ComplexStruct>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'simpleClassReturn',
  )
  Future<SimpleClass> simpleClassReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/simple-class-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SimpleClass>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'complexClassReturn',
  )
  Future<ComplexClass> complexClassReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-class-return'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ComplexClass>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'stringReturnNullable',
  )
  Future<String?> stringReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/string-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as String?);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'intReturnNullable',
  )
  Future<int?> intReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/int-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num?)?.toInt();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'doubleReturnNullable',
  )
  Future<double?> doubleReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/double-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num?)?.toDouble();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'boolReturnNullable',
  )
  Future<bool?> boolReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/bool-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as bool?);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'iterableReturnNullable',
  )
  Future<Iterable<String>?> iterableReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/iterable-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>?)?.map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'listReturnNullable',
  )
  Future<List<String>?> listReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/list-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>?)?.map((el) => (el as String)).toList();
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'mapReturnNullable',
  )
  Future<Map<String, String>?> mapReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/map-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>?)?.map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'structReturnNullable',
  )
  Future<SimpleStruct?> structReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/struct-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SimpleStruct?>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'complexReturnNullable',
  )
  Future<ComplexStruct?> complexReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ComplexStruct?>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'simpleClassReturnNullable',
  )
  Future<SimpleClass?> simpleClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/simple-class-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<SimpleClass?>($body);
  }

  @_$celest.CloudFunction(
    api: 'return_types',
    function: 'complexClassReturnNullable',
  )
  Future<ComplexClass?> complexClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-class-return-nullable'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<ComplexClass?>($body);
  }
}

class CelestFunctionsSealedClasses {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      case 'api.v1.CustomException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<CustomException>(errorValue),
          stackTrace,
        );
      case 'api.v1.CustomExceptionToFromJson':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<CustomExceptionToFromJson>(errorValue),
          stackTrace,
        );
      case 'api.v1.CustomError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<CustomError>(errorValue),
          stackTrace,
        );
      case 'api.v1.CustomErrorToFromJson':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<CustomErrorToFromJson>(errorValue),
          stackTrace,
        );
      case 'api.v1.CustomErrorWithStackTrace':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<CustomErrorWithStackTrace>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'area',
  )
  Future<double> area(Shape shape) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/area'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'shape': _$celest.Serializers.instance.serialize<Shape>(shape)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as num).toDouble();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'sealedClass',
  )
  Future<List<Shape>> sealedClass({required List<Shape> shapes}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/sealed-class'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'shapes': shapes
            .map((el) => _$celest.Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) => _$celest.Serializers.instance.deserialize<Shape>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'rectangle',
  )
  Future<Rectangle> rectangle(Rectangle rectangle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/rectangle'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'rectangle':
            _$celest.Serializers.instance.serialize<Rectangle>(rectangle)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Rectangle>($body);
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'circle',
  )
  Future<Circle> circle(Circle circle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/circle'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'circle': _$celest.Serializers.instance.serialize<Circle>(circle)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Circle>($body);
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'sealedClassWithInheritedCustomJson',
  )
  Future<List<ShapeWithInheritedCustomJson>> sealedClassWithInheritedCustomJson(
      {required List<ShapeWithInheritedCustomJson> shapes}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/sealed-class-with-inherited-custom-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'shapes': shapes
            .map((el) => _$celest.Serializers.instance
                .serialize<ShapeWithInheritedCustomJson>(el))
            .toList()
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) => _$celest.Serializers.instance
            .deserialize<ShapeWithInheritedCustomJson>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'sealedClassWithCustomJson',
  )
  Future<List<ShapeWithCustomJson>> sealedClassWithCustomJson(
      {required List<ShapeWithCustomJson> shapes}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/sealed-class-with-custom-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'shapes': shapes
            .map((el) => _$celest.Serializers.instance
                .serialize<ShapeWithCustomJson>(el))
            .toList()
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) =>
            _$celest.Serializers.instance.deserialize<ShapeWithCustomJson>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'sealedClassWithOverriddenCustomJson',
  )
  Future<List<ShapeWithOverriddenCustomJson>>
      sealedClassWithOverriddenCustomJson({
    required CircleWithOverriddenCustomJson circle,
    required RectangleWithOverriddenCustomJson rectangle,
    required List<ShapeWithOverriddenCustomJson> other,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/sealed-class-with-overridden-custom-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'circle': _$celest.Serializers.instance
            .serialize<CircleWithOverriddenCustomJson>(circle),
        r'rectangle': _$celest.Serializers.instance
            .serialize<RectangleWithOverriddenCustomJson>(rectangle),
        r'other': other
            .map((el) => _$celest.Serializers.instance
                .serialize<ShapeWithOverriddenCustomJson>(el))
            .toList(),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) => _$celest.Serializers.instance
            .deserialize<ShapeWithOverriddenCustomJson>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'rectangleWithOverriddenCustomJson',
  )
  Future<ShapeWithOverriddenCustomJson> rectangleWithOverriddenCustomJson(
      RectangleWithOverriddenCustomJson rectangle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/rectangle-with-overridden-custom-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'rectangle': _$celest.Serializers.instance
            .serialize<RectangleWithOverriddenCustomJson>(rectangle)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<ShapeWithOverriddenCustomJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'circleWithOverriddenCustomJson',
  )
  Future<CircleWithOverriddenCustomJson> circleWithOverriddenCustomJson(
      ShapeWithOverriddenCustomJson circle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/circle-with-overridden-custom-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'circle': _$celest.Serializers.instance
            .serialize<ShapeWithOverriddenCustomJson>(circle)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<CircleWithOverriddenCustomJson>($body);
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'okShapeResults',
  )
  Future<List<OkResult<Shape>>> okShapeResults(List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/ok-shape-results'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'shapes': shapes
            .map((el) => _$celest.Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) =>
            _$celest.Serializers.instance.deserialize<OkResult<Shape>>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'errShapeResults',
  )
  Future<List<ErrResult<String>>> errShapeResults(List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/err-shape-results'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'shapes': shapes
            .map((el) => _$celest.Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) =>
            _$celest.Serializers.instance.deserialize<ErrResult<String>>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'shapeResults',
  )
  Future<List<Result<Shape, String>>> shapeResults(List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/shape-results'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'shapes': shapes
            .map((el) => _$celest.Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) => _$celest.Serializers.instance
            .deserialize<Result<Shape, String>>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'aliasedOkShapeResults',
  )
  Future<List<Result<Shape, String>>> aliasedOkShapeResults(
      List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/aliased-ok-shape-results'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'shapes': shapes
            .map((el) => _$celest.Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) => _$celest.Serializers.instance
            .deserialize<Result<Shape, String>>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'aliasedErrShapeResults',
  )
  Future<List<Result<Shape, String>>> aliasedErrShapeResults(
      List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/aliased-err-shape-results'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'shapes': shapes
            .map((el) => _$celest.Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) => _$celest.Serializers.instance
            .deserialize<Result<Shape, String>>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'aliasedShapeResults',
  )
  Future<List<Result<Shape, String>>> aliasedShapeResults(
      List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/aliased-shape-results'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'shapes': shapes
            .map((el) => _$celest.Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map((el) => _$celest.Serializers.instance
            .deserialize<Result<Shape, String>>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'swappedResult',
  )
  Future<SwappedResult<Shape, String>> swappedResult(
      Result<Shape, String> result) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/swapped-result'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'result': _$celest.Serializers.instance
            .serialize<Result<Shape, String>>(result)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance
        .deserialize<SwappedResult<Shape, String>>($body);
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'genericResult',
  )
  Future<OkResult<T>> genericResult<T extends Shape>(T data) async {
    const $T = {
      Shape: r'Shape',
      Circle: r'Circle',
      Rectangle: r'Rectangle',
    };
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/generic-result'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'$T': $T[T]!,
        r'data': _$celest.Serializers.instance.serialize<T>(data),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<OkResult<T>>($body);
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'multipleGenericResult',
  )
  Future<List<Result<T, E>>>
      multipleGenericResult<T extends Shape, E extends ShapeException>(
    T data,
    E error,
  ) async {
    const $T = {
      Shape: r'Shape',
      Circle: r'Circle',
      Rectangle: r'Rectangle',
    };
    const $E = {
      ShapeException: r'ShapeException',
      BadShapeException: r'BadShapeException',
    };
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/multiple-generic-result'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'$T': $T[T]!,
        r'$E': $E[E]!,
        r'data': _$celest.Serializers.instance.serialize<T>(data),
        r'error': _$celest.Serializers.instance.serialize<E>(error),
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Iterable<Object?>)
        .map(
            (el) => _$celest.Serializers.instance.deserialize<Result<T, E>>(el))
        .toList();
  }

  @_$celest.CloudFunction(
    api: 'sealed_classes',
    function: 'okShapeResult',
  )
  Future<OkShapeResult> okShapeResult(Shape shape) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/ok-shape-result'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode(
          {r'shape': _$celest.Serializers.instance.serialize<Shape>(shape)}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<OkShapeResult>($body);
  }
}

/// Checks that typedefs work as expected.
class CelestFunctionsTypedefs {
  Never _throwError({
    int? code,
    required Map<String, Object?> body,
  }) {
    final status = body['@status'] as Map<String, Object?>?;
    final message = status?['message'] as String?;
    final details = status?['details'] as _$celest.JsonList?;
    final (errorType, errorValue, stackTrace) = switch (details) {
      null || [] => const (null, null, StackTrace.empty),
      [
        final errorDetails as Map<String, Object?>,
        {
          '@type': 'dart.core.StackTrace',
          'value': final stackTraceValue as String
        },
        ...
      ] =>
        (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.fromString(stackTraceValue),
        ),
      [final errorDetails as Map<String, Object?>, ...] => (
          errorDetails['@type'],
          errorDetails['value'],
          StackTrace.empty,
        ),
    };

    switch (errorType) {
      case 'celest.core.v1.CloudException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CloudException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.CancelledException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.CancelledException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnknownError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnknownError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.BadRequestException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.BadRequestException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnauthorizedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnauthorizedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.NotFoundException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.NotFoundException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AlreadyExistsException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AlreadyExistsException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.PermissionDeniedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.PermissionDeniedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.ResourceExhaustedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.ResourceExhaustedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.FailedPreconditionException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.FailedPreconditionException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.AbortedException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.AbortedException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.OutOfRangeException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.OutOfRangeException>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.InternalServerError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.InternalServerError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.UnavailableError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.UnavailableError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DataLossError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DataLossError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.DeadlineExceededError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.DeadlineExceededError>(errorValue),
          stackTrace,
        );
      case 'celest.core.v1.SerializationException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<_$celest.SerializationException>(errorValue),
          stackTrace,
        );
      case 'dart.core.Error':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Error>(errorValue),
          stackTrace,
        );
      case 'dart.core.AssertionError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AssertionError>(errorValue),
          stackTrace,
        );
      case 'dart.core.TypeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<TypeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ArgumentError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<ArgumentError>(errorValue),
          stackTrace,
        );
      case 'dart.core.RangeError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<RangeError>(errorValue),
          stackTrace,
        );
      case 'dart.core.IndexError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<IndexError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnsupportedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnsupportedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.UnimplementedError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<UnimplementedError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StateError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<StateError>(errorValue),
          stackTrace,
        );
      case 'dart.core.ConcurrentModificationError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<ConcurrentModificationError>(errorValue),
          stackTrace,
        );
      case 'dart.core.OutOfMemoryError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<OutOfMemoryError>(errorValue),
          stackTrace,
        );
      case 'dart.core.StackOverflowError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<StackOverflowError>(errorValue),
          stackTrace,
        );
      case 'dart.core.Exception':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<Exception>(errorValue),
          stackTrace,
        );
      case 'dart.core.FormatException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<FormatException>(errorValue),
          stackTrace,
        );
      case 'dart.core.IntegerDivisionByZeroException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<IntegerDivisionByZeroException>(errorValue),
          stackTrace,
        );
      case 'dart.async.AsyncError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance.deserialize<AsyncError>(errorValue),
          stackTrace,
        );
      case 'dart.async.TimeoutException':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<TimeoutException>(errorValue),
          stackTrace,
        );
      case 'dart.convert.JsonUnsupportedObjectError':
        Error.throwWithStackTrace(
          _$celest.Serializers.instance
              .deserialize<JsonUnsupportedObjectError>(errorValue),
          stackTrace,
        );
      default:
        Error.throwWithStackTrace(
          _$celest.CloudException.http(
            code: code,
            message: message,
            details: ((details ?? body) as _$celest.JsonValue),
          ),
          StackTrace.empty,
        );
    }
  }

  @_$celest.CloudFunction(
    api: 'typedefs',
    function: 'portfolio',
  )
  Future<Portfolio> portfolio(Portfolio portfolio) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/typedefs/portfolio'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({
        r'portfolio':
            _$celest.Serializers.instance.serialize<Portfolio>(portfolio)
      }),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return _$celest.Serializers.instance.deserialize<Portfolio>($body);
  }

  @_$celest.CloudFunction(
    api: 'typedefs',
    function: 'json',
  )
  Future<Map<String, dynamic>> json(Map<String, dynamic> json) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/typedefs/json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({r'json': json}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>);
  }

  @_$celest.CloudFunction(
    api: 'typedefs',
    function: 'nullableJson',
  )
  Future<Map<String, dynamic>?> nullableJson(Map<String, dynamic>? json) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/typedefs/nullable-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({r'json': json}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>?);
  }

  @_$celest.CloudFunction(
    api: 'typedefs',
    function: 'mixedJson',
  )
  Future<Map<String, dynamic>?> mixedJson(Map<String, dynamic> json) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/typedefs/mixed-json'),
      headers: const {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: _$celest.JsonUtf8.encode({r'json': json}),
    );
    final $body = _$celest.JsonUtf8.decode($response.bodyBytes);
    if ($response.statusCode != 200) {
      _throwError(
        code: $response.statusCode,
        body: ($body as Map<String, Object?>),
      );
    }
    return ($body as Map<String, Object?>?);
  }
}
